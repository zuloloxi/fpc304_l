<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="rtl">

<!--
  ====================================================================
    unicodedata
  ====================================================================
-->

<module name="unicodedata">
<short>Unicode data management</short>
<descr>
<p>
The <link id="fpwidestring"/> unit relies on having relevant unicode collation data linked
in the binary. The unicode data is managed using the routines in the <file>unicodedata</file> unit.
The FPC project distributes some unicode collation data in <var>.bco</var> files which can be loaded 
using the <link id="#rtl.unicodedata.LoadCollation">LoadCollation</link> routines.
The <var>LoadCollation</var> is the main routine of this unit.
</p>
<p>
All collation data requires at least the Default Unicode Collation 
Element Table to be registered (called <var>DUCET</var>). 
The DUCET encoding is provided by the <file>unicodeducet</file> unit, part of the rtl-unicode package.
</p>
<p>
There are two ways to register collations :
</p>
<ol>
<li><b>at compile time</b>: by including the desired collation unit, for example
for Russian and Japanese languages to be available you will have to include
<file>collation_ru</file> and <file>collation_ja</file> from package "rtl-unicode".
</li>
<li>
<b> at runtime</b> using the abovementioned <var>LoadCollation</var> function.
</li>
</ol>
<p>
The two ways can co-exist: some collations may be compile time included
(for example for most used collations) and others can be loaded at runtime 
in the same application.
</p>
<p>
The binary collation files are endian sensitive:
</p>
<ul>
<li> 
there are files for little endian systems named <file>collation_<b>lang</b>_le.bco</file>
(such as collation_ru_le.bco and collation_ja_le.bco)
</li>
<li>
there are files for big endian systems named <file>collation_<b>lang</b>_be.bco</file> 
(such as collation_ru_be.bco and collation_ja_be.bco).
</li>
</ul>
<p>
Note that the compile time units collation units (collation_<b>lang</b>.pas)
include already the unicodeducet.pas (DUCET) unit so it is not necessary to
include it manually, contrary to the binary files. So an application that
only uses the binary collation files should at least include the
<file>unicodeducet</file> unit or manually load the binary collation
collation_ducet_le.bco or collation_ducet_be.bco, depending on the
endianness of the platform. The <link id="LoadCollation"/> call using a
directory and the language <var>ducet</var> automatically select the correct
file.
</p>
</descr>
<seealso>
<link id="LoadCollation"/> 
</seealso>

<!-- constant Visibility: default -->
<element name="MAX_WORD">
<short>Maximum value of a WORD typed value</short>
<descr>
<var>MAX_WORD</var> is the maximum value of a WORD typed value.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LOW_SURROGATE_BEGIN">
<short>First value for low surrogate values.</short>
<seealso>
<link id="LOW_SURROGATE_END"/>
<link id="HIGH_SURROGATE_END"/>
<link id="HIGH_SURROGATE_BEGIN"/>
<link id="HIGH_SURROGATE_COUNT"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LOW_SURROGATE_END">
<short>Last value for low surrogate values.</short>
<seealso>
<link id="LOW_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_END"/>
<link id="HIGH_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_COUNT"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGH_SURROGATE_BEGIN">
<short>First value for high surrogate values.</short>
<seealso>
<link id="LOW_SURROGATE_END"/>
<link id="LOW_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_END"/>
<link id="HIGH_SURROGATE_COUNT"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGH_SURROGATE_END">
<short>Last value for high surrogate values.</short>
<descr>
</descr>
<seealso>
<link id="LOW_SURROGATE_END"/>
<link id="LOW_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_COUNT"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="HIGH_SURROGATE_COUNT">
<short>Number of high surrogate values.</short>
<seealso>
<link id="LOW_SURROGATE_END"/>
<link id="LOW_SURROGATE_BEGIN"/>  
<link id="HIGH_SURROGATE_END"/>
<link id="HIGH_SURROGATE_BEGIN"/>  
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UCS4_HALF_BASE">
<short>Offset for UCS4 character encoding</short>
</element>

<!-- constant Visibility: default -->
<element name="UCS4_HALF_MASK">
<short>Unused currently</short>
</element>

<!-- constant Visibility: default -->
<element name="MAX_LEGAL_UTF32">
<short>Maximum value of a legally encoded UTF32 value (currently unused)</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_UppercaseLetter">
<short>Unicode general category: Uppercase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_LowercaseLetter">
<short>Unicode general category: Lowercase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_TitlecaseLetter">
<short>Unicode general category: Titlecase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_ModifierLetter">
<short>Unicode general category: modifier letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_OtherLetter">
<short>Unicode general category: Other letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_NonSpacingMark">
<short>Unicode general category: Non-spacing mark</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_CombiningMark">
<short>Unicode token category: Uppercase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_EnclosingMark">
<short>Unicode token category: Uppercase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_DecimalNumber">
<short>Unicode token category: Uppercase letter</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_LetterNumber">
<short>Unicode token category: Letter-number</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_OtherNumber">
<short>Unicode token category: Other number</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_ConnectPunctuation">
<short>Unicode token category: Connect punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_DashPunctuation">
<short>Unicode token category: Dash punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_OpenPunctuation">
<short>Unicode token category: Open puntctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_ClosePunctuation">
<short>Unicode token category: Close punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_InitialPunctuation">
<short>Unicode token category: Initial punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_FinalPunctuation">
<short>Unicode token category: Final punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_OtherPunctuation">
<short>Unicode token category: Other punctuation</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_MathSymbol">
<short>Unicode token category: Math symbol</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_CurrencySymbol">
<short>Unicode token category: Currency symbol</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_ModifierSymbol">
<short>Unicode token category: modifier symbol</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_OtherSymbol">
<short>Unicode token category: Other symbol</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_SpaceSeparator">
<short>Unicode token category: Space separator</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_LineSeparator">
<short>Unicode token category: Line separator</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_ParagraphSeparator">
<short>Unicode token category: Paragraph separator</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_Control">
<short>Unicode token category: control token</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_Format">
<short>Unicode token category: Formatting token</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_Surrogate">
<short>Unicode token category: Surrogate token</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_PrivateUse">
<short>Unicode token category: For private use</short>
</element>

<!-- constant Visibility: default -->
<element name="UGC_Unassigned">
<short>Unicode token category: As yet unassigned</short>
</element>

<!-- record type Visibility: default -->
<element name="TUInt24Rec">
<short>Unicode integer 24-bit data</short>
<descr>
Unicode data exists mostly of 24-bit data (3 bytes). This type is meant to deal efficiently with this data. 
it has members to split out the data in bytes, and functions to query the various properties stored in the data.
</descr>
<seealso> 
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TUInt24Rec.byte2">
<short>Third byte</short>
</element>

<!-- variable Visibility: public -->
<element name="TUInt24Rec.byte1">
<short>Second byte</short>
</element>

<!-- variable Visibility: public -->
<element name="TUInt24Rec.byte0">
<short>First byte</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Cardinal">
  <short>Assign <var>TUInt24Rec</var> to cardinal</short>
<descr>
Assign to cardinal, byte0 to MSB and so on. 
</descr>
<seealso>
<link id="TUInt24Rec.implicit(TUInt24Rec):LongInt"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Word"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Byte"/>
<link id="TUInt24Rec.implicit(Cardinal):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Longint):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Word):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Byte):TUInt24Rec"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Cardinal.Result">
<short>Cardinal to assign to</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Cardinal.a">
<short><var>TUInt24Rec</var> record to assign</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):LongInt">
<short>Assign <var>TUInt24Rec</var> to longint</short>
<descr>
Assign to cardinal, byte0 to MSB and so on. 
</descr>
<seealso>
<link id="TUInt24Rec.implicit(TUInt24Rec):Cardinal"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Word"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Byte"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):LongInt.Result">
<short>Longint to assign to </short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):LongInt.a">
<short><var>TUInt24Rec</var> record to assign</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Word">
<short>Assign <var>TUInt24Rec</var> to word</short>
<descr>
Assign to word, byte0 to MSB, byte1 to MSB.
</descr>
<errors>
If the value is too big  (&gt;$FFFF) to be assigned, an overflow error occurs.
</errors>
<seealso>
<link id="TUInt24Rec.implicit(TUInt24Rec):Cardinal"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Longint"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Byte"/>
<link id="TUInt24Rec.implicit(Cardinal):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Longint):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Word):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Byte):TUInt24Rec"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Word.Result">
<short>Word to assign to</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Word.a">
<short><var>TUInt24Rec</var> record to assign</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Byte">
<short>Assign <var>TUInt24Rec</var> to byte</short>
<descr>
Assign to byte, byte0 is assigned. 
</descr>
<errors>
If the value is too big (&gt;$FF) to be assigned, an overflow error occurs.
</errors>
<seealso>
<link id="TUInt24Rec.implicit(TUInt24Rec):Cardinal"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Longint"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Word"/>
<link id="TUInt24Rec.implicit(Cardinal):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Longint):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Word):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Byte):TUInt24Rec"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Byte.Result">
<short>Byte to assign to</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.implicit(TUInt24Rec):Byte.a">
<short><var>TUInt24Rec</var> record to assign</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.implicit(Cardinal):TUInt24Rec">
<short>Assign <var>TUInt24Rec</var>from Cardinal</short>
<descr>
Assign from cardinal, byte0 to MSB.
</descr>
<errors>
If the value is too big (&gt;$FFFFFF) to be assigned, an overflow error occurs.
</errors>
<seealso>
<link id="TUInt24Rec.implicit(TUInt24Rec):Longint"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Word"/>
<link id="TUInt24Rec.implicit(TUInt24Rec):Byte"/>
<link id="TUInt24Rec.implicit(Longint):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Word):TUInt24Rec"/>
<link id="TUInt24Rec.implicit(Byte):TUInt24Rec"/>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.implicit(Cardinal):TUInt24Rec.Result">
<short>Resulting <var>TUInt24Rec</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.implicit(Cardinal):TUInt24Rec.a">
<short>Cardinal to assign from</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,TUInt24Rec):Boolean">
<short>Determine equality of 2 <var>TUInt24Rec</var> records</short>
<descr>
The 2 records are considered equal if the 3 bytes are equal.
</descr>
<seealso>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> equals <var>b</var>.</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First record</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second record</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Cardinal):Boolean">
<short>Check if cardinal and <var>TUInt24Rec</var> are equal</short>
<descr>
The cardinal <var>b</var> is considered equal to <var>a</var> if the fourth byte 
(LSB) is zero, and the first three bytes equal <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a cardinal value.</short>
<descr>
The cardinal <var>a</var> is considered equal to <var>b</var> if the fourth byte 
(LSB) is zero, and the first three bytes equal <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,LongInt):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a longint value.</short>
<descr>
The longint <var>b</var> is considered equal to <var>a</var> if the fourth byte 
(LSB) is zero, and the first three bytes equal <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,LongInt):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,LongInt):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,LongInt):Boolean.b">
<short>Longint value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(LongInt,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a longint value.</short>
<descr>
The longint <var>a</var> is considered equal to <var>b</var> if the fourth byte 
(LSB) is zero, and the first three bytes equal <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(LongInt,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(LongInt,TUInt24Rec):Boolean.a">
<short>Longint value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(LongInt,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Word):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a word value.</short>
<descr>
The word <var>b</var> is considered equal to <var>a</var> if its 2 bytes equal <var>byte0</var>, <var>byte1</var>
and <var>byte2</var> is zero.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Word):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Word):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Word):Boolean.b">
<short>Word value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(Word,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a word value.</short>
<descr>
The word <var>a</var> is considered equal to <var>b</var> if its 2 bytes equal 
<var>byte0</var>, <var>byte1</var> and <var>byte2</var> is zero.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(Word,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Word,TUInt24Rec):Boolean.a">
<short>Word value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Word,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Byte):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a byte value.</short>
<descr>
The byte <var>b</var> is considered equal to <var>a</var> if it equals <var>byte0</var> and <var>byte1</var> and <var>byte1</var> are zero.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Byte):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Byte):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(TUInt24Rec,Byte):Boolean.b">
<short>Byte value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.equal(Byte,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value equals a byte value.</short>
<descr>
The byte <var>b</var> is considered equal to <var>a</var> if it equals <var>byte0</var> and <var>byte1</var> and <var>byte1</var> are zero.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.equal(Byte,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are equal</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Byte,TUInt24Rec):Boolean.a">
<short>Byte value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.equal(Byte,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,TUInt24Rec):Boolean">
<short>Check whether 2 <var>TUInt24Rec</var> values differ.</short>
<descr>
The comparison is done by comparing <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are different</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First <var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second <var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,Cardinal):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value differs from a cardinal value.</short>
<descr>
The cardinal <var>a</var> is considered not equal to <var>b</var> if the fourth byte 
(LSB) is nonzero, or one of the first three bytes differ from <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are different</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.notequal(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value differs from a cardinal value.</short>
<descr>
The cardinal <var>a</var> is considered not equal to <var>b</var> if the fourth byte 
(LSB) is nonzero, or one of the first three bytes differ from <var>byte0</var>, <var>byte1</var>,
and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.notequal(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> and <var>b</var> are different</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.notequal(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is greater than another <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing 3 bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is greater than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First <var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second <var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,Cardinal):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is greater than a cardinal value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> is greater than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthan(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a cardinal value is greater than a <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthan(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is greater than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthan(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is greater than or equal to a cardinal value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is greater than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First <var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second <var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,Cardinal):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is greater than or equal to a cardinal value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> is greater than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a cardinal value is greater than or equal to a <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is greater than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.greaterthanorequal(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is less than another <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing the bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is less than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First <var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second <var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,Cardinal):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is less than a cardinal value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> is less than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthan(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a cardinal value is less than a <var>TUInt24Rec</var> value</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthan(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is less than <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthan(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare></short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,TUInt24Rec):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is less than or equal to another <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing the bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is less than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,TUInt24Rec):Boolean.a">
<short>First <var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,TUInt24Rec):Boolean.b">
<short>Second <var>TUInt24Rec</var> to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,Cardinal):Boolean">
<short>Check whether a <var>TUInt24Rec</var> value is less than or equal to a cardinal value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,Cardinal):Boolean.Result">
<short>True if <var>a</var> is less than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,Cardinal):Boolean.a">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(TUInt24Rec,Cardinal):Boolean.b">
<short>Cardinal value to compare</short>
</element>

<!-- operator Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(Cardinal,TUInt24Rec):Boolean">
<short>Check whether a cardinal value is less than or equal to a <var>TUInt24Rec</var> value</short>
<descr>
The comparison is done by comparing 3 first bytes of the cardinal value with bytes <var>byte0</var>, <var>byte1</var> and <var>byte2</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(Cardinal,TUInt24Rec):Boolean.Result">
<short>True if <var>a</var> is less than or equal to <var>b</var></short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(Cardinal,TUInt24Rec):Boolean.a">
<short>Cardinal value to compare</short>
</element>

<!-- argument Visibility: public -->
<element name="TUInt24Rec.lessthanorequal(Cardinal,TUInt24Rec):Boolean.b">
<short><var>TUInt24Rec</var> to compare</short>
</element>

<!-- alias type Visibility: default -->
<element name="UInt24">
<short>Alias for <var>TUInt24Rec</var></short>
<seealso>
<link id="TUInt24Rec"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUInt24">
<short>Pointer to <var>TUInt24Rec</var></short>
<seealso>
<link id="TUInt24Rec"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ZERO_UINT24">
<short>Empty <var>TUInt24Rec</var> value</short>
<descr>
<var>TUInt24Rec</var> value with all bytes zero.
</descr>
<seealso>
<link id="TUInt24Rec"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUC_Prop">
<short>Pointer to <var>TUC_Prop</var> record</short>
<seealso>
<link id="TUC_Prop"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUC_Prop">
<short>Unicode character properties record</short>
<descr>
<var>TUC_Prop</var> describes the collation characteristics of a unicode character. 
It is an internal structure which should not be used directly, the actual structure is subject to change.
</descr>
</element>


<!-- variable Visibility: public -->
<element name="TUC_Prop.CategoryData">
<short>Category data</short>
<descr>
<var>CategoryData</var> is a bitmask encoding various characteristics of the unicode character.
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TUC_Prop.CCC">
<short></short>
<descr>
<var>CategoryData</var> is a bitmask encoding various characteristics of the unicode character.
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TUC_Prop.NumericIndex">
<short>Index in numeric values array</short>
</element>

<!-- variable Visibility: public -->
<element name="TUC_Prop.SimpleUpperCase">
<short>Simple uppercase version</short>
</element>

<!-- variable Visibility: public -->
<element name="TUC_Prop.SimpleLowerCase">
<short>Simple lowercase version</short>
</element>

<!-- variable Visibility: public -->
<element name="TUC_Prop.DecompositionID">
<short>Decomposition ID </short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TUC_Prop.Category">
<short>Get the category</short>
<descr>
<var>CategoryData</var> provides access to the category part of CategoryData (encoded).
</descr>
</element>

<!-- property Visibility: public -->
<element name="TUC_Prop.WhiteSpace">
<short>Is the character considered whitespace</short>
<descr>
<var>Whitespace</var> provides easy access to the Whitespace part of CategoryData (encoded).
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TUC_Prop.HangulSyllable">
<short>Is the character a hangul syllable</short>
<descr>
<var>Whitespace</var> provides easy access to the HangulSyllable part of CategoryData (encoded).
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TUC_Prop.NumericValue">
<short>Numeric value</short>
<descr>
<var>NumericValue</var> uses numericalindex to get the numerical value.
</descr>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_PropWeights">
<short>Weights </short>
<descr>
<var>TUC_PropWeights</var> describes the weights of collation characteristics of a unicode character. 
It is an internal structure which should not be used directly, the actual structure is subject to change.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TUCA_PropWeights.Weights">
<short>Weights of collation data</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_PropWeights">
<short>Pointer to <var>TUCA_PropWeights</var></short>
<seealso>
<link id="TUCA_PropWeights"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_PropItemContextRec">
<short>Internal structure for unicode collation data encoding.</short>
<descr>
This is an internal structure which should not be used directly, the actual structure is subject to change.
</descr>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextRec.CodePointCount">
<short>Number of code points.</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextRec.WeightCount">
<short>Number of weights.</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextRec.GetCodePoints">
<short>get the address of actual code points.</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextRec.GetCodePoints.Result">
<short>address of actual code points.</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextRec.GetWeights">
<short>Get the Address of actual weights.</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextRec.GetWeights.Result">
<short>Address of actual weights.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_PropItemContextRec">
<short>Pointer to <var>TUCA_PropItemContextRec</var></short>
<seealso>
<link id="TUCA_PropItemContextRec"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_PropItemContextTreeNodeRec">
<short>Pointer to <var>TUCA_PropItemContextTreeNodeRec</var></short>
<seealso>
<link id="TUCA_PropItemContextTreeNodeRec"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_PropItemContextTreeNodeRec">
<short>Internal tree node structure for sorted storage of unicode collation data.</short>
<descr>
This is an internal structure for the tree which should not be used directly, the actual structure is subject to change.
</descr>
<seealso>
<link id="TUCA_PropItemContextTreeRec"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.Left">
<short>Offset of left branch of the tree</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.Right">
<short>Offset of right branch of the tree</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.Data">
<short>Data for this node.</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.GetLeftNode">
<short>Access to left tree node data</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.GetLeftNode.Result">
<short>Address of left node</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.GetRightNode">
<short>Access to right tree node data</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextTreeNodeRec.GetRightNode.Result">
<short>Address of right node</short>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_PropItemContextTreeRec">
<short>Internal tree structure for sorted storage of unicode collation data</short>
<descr>
This is an internal tree structure for storing unicode collation data which should not be used directly, 
the actual structure is subject to change.
</descr>
<seealso>
<link id="TUCA_PropItemContextTreeNodeRec"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Size">
<short>Size of the tree data</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.GetData">
<short>Access to tree data (getter for Data property)</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.GetData.Result">
<short>Address of the tree data</short>
</element>

<!-- property Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Data">
<short>Read-only access to tree data</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Find">
<short>Find data for encoded character </short>
<descr>
<var>Find</var> searches the tree for the collation data for the character encoded in <var>AChars</var> (<var>ACharCount</var>). 
It returns true if the data was found, false if not. A pointer to the collation data is returned in <var>ANode</var>.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Find.Result">
<short>True if collation data was found</short>
</element>

<!-- argument Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Find.AChars">
<short>Unicode character to search</short>
</element>

<!-- argument Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Find.ACharCount">
<short>Number of encoding elements</short>
</element>

<!-- argument Visibility: public -->
<element name="TUCA_PropItemContextTreeRec.Find.ANode">
<short>Pointer to collation data.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_PropItemContextTreeRec">
<short>Pointer to <var>TUCA_PropItemContextTreeRec</var></short>
<seealso>
<link id="TUCA_PropItemContextTreeRec"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_PropItemRec">
<short>Unicode Collation data item properties</short>
<descr>
<var>TUCA_PropItemRec</var> encodes 1 entry from the Unicode Collation data in an encoded form.
</descr>
<seealso>
<link id="TUCA_PropItemContextTreeRec"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemRec.WeightLength">
<short>Number of weights</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemRec.ChildCount">
<short>Number of childs</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemRec.Size">
<short>Total size (in bytes) of data</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_PropItemRec.Flags">
<short>Flags for this item</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.HasCodePoint">
<short>Check flags whether a codepoint is present.</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.HasCodePoint.Result">
<short><var>True</var> if a codepoint is present.</short>
</element>

<!-- property Visibility: public -->
<element name="TUCA_PropItemRec.CodePoint">
<short>Get the codepoint</short>
<descr>
Access to codepoint if <var>HasCodePoint</var> returns true.
If <var>HasCodePoint</var> returns false, an exception will be raised.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.IsValid">
<short>Check flags for validity</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.IsValid.Result">
<short>true if the flags validity bit is set</short>
</element>

<!-- procedure Visibility: public -->
<element name="TUCA_PropItemRec.GetWeightArray">
<short>Return an array of weights</short>
<descr>
<var>GetWeightArray</var> returns an array with the weights in <var>ADest</var>.
<var>ADest</var> must point to enough room for <var>WeightLength</var> weights.
</descr>
</element>

<!-- argument Visibility: public -->
<element name="TUCA_PropItemRec.GetWeightArray.ADest">
<short>Memory location to which weight data will be copied.</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.GetSelfOnlySize">
<short>Size of this item data (in bytes).</short>
<descr>
Return the size of the item's data and properties.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.GetSelfOnlySize.Result">
<short>Size, in bytes</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.GetContextual">
<short>Check if the contextual bit is set in the flags (getter for Contextual)</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.GetContextual.Result">
<short>True if the bit is set.</short>
</element>

<!-- property Visibility: public -->
<element name="TUCA_PropItemRec.Contextual">
<short>Check if the contextual bit is set in the flags </short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.GetContext">
<short>Access to context data</short>
<descr>
<var>GetContext</var> returns a pointer to the context data.
It is <var>Nil</var> if the context flag is not set.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.GetContext.Result">
<short>Address of context data.</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.IsDeleted">
<short>Check flags if deleted bit is set</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.IsDeleted.Result">
<short><var>True</var> if the deleted bit is set</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.IsWeightCompress_1">
<short>Check whether weight compression flag 1 is set</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.IsWeightCompress_1.Result">
<short><var>True</var> if weight compression flag 1 is set</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_PropItemRec.IsWeightCompress_2">
<short>Check whether weight compression flag 2 is set</short>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_PropItemRec.IsWeightCompress_2.Result">
<short><var>True</var> if weight compression flag 2 is set</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_PropItemRec">
<short>Pointer to <var>TUCA_PropItemRec</var></short>
<seealso>
<link id="TUCA_PropItemRec"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TUCA_VariableKind">
<short>Options for weighting data</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TUCA_VariableKind.ucaShifted">
<short> Variable collation elements are reset to zero at levels one through three</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TUCA_VariableKind.ucaNonIgnorable">
<short> Variable collation elements are not reset to be quaternary collation elements</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TUCA_VariableKind.ucaBlanked">
<short>Variable collation elements and any subsequent ignorable collation elements are reset so that all weights (except for the identical level) are zero</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TUCA_VariableKind.ucaShiftedTrimmed">
<short>This option is the same as Shifted, except that all trailing FFFFs are trimmed from the sort key. </short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TUCA_VariableKind.ucaIgnoreSP">
<short>Not implemented (variant of Shifted that reduces the set of variable collation elements to include only spaces and punctuation)</short>
</element>

<!-- alias type Visibility: default -->
<element name="TCollationName">
<short>Collation name string type (fixed lenght)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCA_DataBook">
<short>Pointer to <var>TUCA_DataBook</var> type.</short>
<seealso>
<link id="TUCA_DataBook"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TUCA_DataBook">
<short>Collation data book</short>
<descr> 
<var>TUCA_DataBook</var> describes a Unicode Collation Alghorithm data set.
data sets can be registered using the <link id="RegisterCollation"/> function or loaded from file using <link id="LoadCollation"/>.
A collation data book must be specified when comparing unicode strings.
</descr>
<seealso>
<link id="RegisterCollation"/>
<link id="LoadCollation"/>
<link id="IncrementalCompareString"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.Base">
<short>Collation set on which this collation set is based.</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.Version">
<short>Version of this collation.</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.CollationName">
<short>Name of this collation</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.VariableWeight">
<short>How collation weights are encoded</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.Backwards">
<short>Is the collation weighting in backwards direction</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.BMP_Table1">
<short>Basic Multilingual Plane Data, table 1 (code points U+0000..U+FFFF)</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.BMP_Table2">
<short>Basic Multilingual Plane Data, table 2 (code points U+0000..U+FFFF)</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.OBMP_Table1">
<short>Data for code points above U+FFFF, table 1</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.OBMP_Table2">
<short>Data for code points above U+FFFF, table 2</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.PropCount">
<short>Property count (number of items in table)</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.Props">
<short>Property data.</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.VariableLowLimit">
<short>First variable weighted weight</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.VariableHighLimit">
<short>Last variable weighted weight</short>
</element>

<!-- variable Visibility: public -->
<element name="TUCA_DataBook.Dynamic">
<short>Indicates the data was loaded from file (True) or is compiled-in (False).</short>
</element>

<!-- function Visibility: public -->
<element name="TUCA_DataBook.IsVariable">
<short>Check if a weight is a variable weight</short>
<descr>
<var>IsVariable</var> checks whether <var>AWeight</var> is between 
the <var>VariableLowLimit</var> and <var>VariableHighLimit</var> limits.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TUCA_DataBook.IsVariable.Result">
<short>True if the weight is in the variable range.</short>
</element>

<!-- argument Visibility: public -->
<element name="TUCA_DataBook.IsVariable.AWeight">
<short>Weight to check</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCollationField">
<short>Options for the collation data</short>
<descr>
<var>TCollationField</var> describes some properties of the collation data items.
</descr>
<seealso>
<link id="TCollationFields"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollationField.BackWard">
<short>Backwards encoded</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollationField.VariableLowLimit">
<short>Has lower bound on variable weights</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollationField.VariableHighLimit">
<short>Has upper bound on variable weights</short>
</element>

<!-- set type Visibility: default -->
<element name="TCollationFields">
<short>Set of <var>TCollationField</var></short>
<descr>
</descr>
<seealso>
<link id="TCollationField"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="ROOT_COLLATION_NAME">
<short>Name of the root collation (used if no collation name is given)</short>
</element>

<!-- constant Visibility: default -->
<element name="ERROR_INVALID_CODEPOINT_SEQUENCE">
<short>Error exit code for UnicodeToLower/UnicodeToUpper</short>
<descr>
</descr>
<seealso>
<link id="UnicodeToLower"/>
<link id="UnicodeToUpper"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="FromUCS4">
<short>Convert UCS4 to UNicodeChar</short>
<descr>
<var>FromUCS4</var> converts the UCS4 encoded unicode character <var>AValue</var> to a set of unicode 
(surrogate pair) characters encoded in UTF16: <var>AHighS</var>, <var>ALowS</var>.
</descr>
<seealso>
<link id="ToUCS4"/>
<link id="UnicodeIsHighSurrogate"/>
<link id="UnicodeIsLowSurrogate"/>
<link id="UnicodeIsSurrogatePair"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FromUCS4.AValue">
<short>UCS4 encoded unicode character</short>
</element>

<!-- argument Visibility: default -->
<element name="FromUCS4.AHighS">
<short>High character of surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="FromUCS4.ALowS">
<short>Low character of surrogate pair</short>
</element>

<!-- function Visibility: default -->
<element name="ToUCS4">
<short>Encode unicode UTF16 surrogate pair to UCS4 character</short>
<descr>
<var>ToUCS4</var> converts set of unicode 
(surrogate pair) characters encoded in UTF16: <var>AHighS</var>, <var>ALowS</var> to 
a UCS4 encoded unicode character.
</descr>
<seealso>
<link id="FromUCS4"/>
<link id="UnicodeIsHighSurrogate"/>
<link id="UnicodeIsLowSurrogate"/>
<link id="UnicodeIsSurrogatePair"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ToUCS4.Result">
<short>UCS4 encoded unicode characte</short>
</element>

<!-- argument Visibility: default -->
<element name="ToUCS4.AHighS">
<short>High character of surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="ToUCS4.ALowS">
<short>Low character of surrogate pair</short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeIsSurrogatePair">
<short>Check if a pair of UTF16 encoded characters is a valid surrogate pair.</short>
<descr>
<var>UnicodeIsSurrogatePair</var> checks whether 
<var>AHighSurrogate</var>,<var>ALowSurrogate</var> constitute a valid surrogate pair, and returns <var>True</var> if this is the case.
It does this by checking whether the values are within the bounds for high and low surrogate pairs.
</descr>
<seealso>
<link id="FromUCS4"/>
<link id="ToUCS4"/>
<link id="UnicodeIsHighSurrogate"/>
<link id="UnicodeIsLowSurrogate"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnicodeIsSurrogatePair.Result">
<short>True if <var>AHighSurrogate</var>,<var>ALowSurrogate</var> are a valid surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeIsSurrogatePair.AHighSurrogate">
<short>High character in the surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeIsSurrogatePair.ALowSurrogate">
<short>Low character in the surrogate pair</short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeIsHighSurrogate">
<short>Check if a UTF16 character is the high character in a surrogate pair.</short>
<descr>
<var>UnicodeIsHighSurrogate</var> checks whether <var>AValue</var> is a valid high character 
of a surrogate pair, and returns <var>True</var> if this is the case.
It does this by checking whether the values are within the bounds for high characters in surrogate pairs.
</descr>
<seealso>
<link id="FromUCS4"/>
<link id="ToUCS4"/>
<link id="UnicodeIsHighSurrogate"/>
<link id="UnicodeIsLowSurrogate"/>
<link id="UnicodeIsSurrogatePair"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnicodeIsHighSurrogate.Result">
<short>True if <var>AValue</var> forms the high character of a surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeIsHighSurrogate.AValue">
<short>UTF16 character to check</short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeIsLowSurrogate">
<short>Check if a UTF16 character is the low character in a surrogate pair.</short>
<descr>
<var>UnicodeIsHighSurrogate</var> checks whether <var>AValue</var> is a valid high character 
of a surrogate pair, and returns <var>True</var> if this is the case.
It does this by checking whether the values are within the bounds for high characters in surrogate pairs.
</descr>
<seealso>
<link id="FromUCS4"/>
<link id="ToUCS4"/>
<link id="UnicodeIsHighSurrogate"/>
<link id="UnicodeIsSurrogatePair"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnicodeIsLowSurrogate.Result">
<short>True if <var>AValue</var> forms the low character of a surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeIsLowSurrogate.AValue">
<short>UTF16 character to check</short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeToUpper">
<short>Transform unicode string to uppercase</short>
<descr>
<p>
<var>UnicodeToUpper</var> transforms a UTF16 unicode string <var>AString</var> to its uppercase equivalent and returns this in <var>AResultString</var>.
If the transformation was succesful, then the function returns <var>0</var>. A nonzero return value means an error occurred. 
<var>AResultString</var> will remain untouched in that case.
</p>
<p>
If a character in <var>AString</var> cannot be found in the unicode data tables, an error will be reported, unless <var>AIgnoreInvalidSequence</var> 
is set to <var>True</var>, in which case the character will be copied as-is to the output.
</p>
<p>
Unicode collation data can be loaded using <link id="RegisterCollation"/> or <link id="LoadCollation"/>
</p>
</descr>
<errors>
On error, a nonzero value will be returned.
</errors>
<seealso>
<link id="UnicodeToLower"/>
<link id="RegisterCollation"/> 
<link id="LoadCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnicodeToUpper.Result">
<short>Zero if all went well, nonzero indicates an error.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToUpper.AString">
<short>String to convert to uppercase.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToUpper.AIgnoreInvalidSequence">
<short>Set to true to ignore invalid characters.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToUpper.AResultString">
<short>Uppercase equivalent of <var>AString</var></short>
</element>

<!-- function Visibility: default -->
<element name="UnicodeToLower">
<short>Transform unicode string to lowercase</short>
<descr>
<p>
<var>UnicodeToLower</var> transforms a UTF16 unicode string <var>AString</var> to its lowercase equivalent and returns this in <var>AResultString</var>.
If the transformation was succesful, then the function returns <var>0</var>. A nonzero return value means an error occurred. 
<var>AResultString</var> will remain untouched in that case.
</p>
<p>
If a character in <var>AString</var> cannot be found in the unicode data tables, an error will be reported, unless <var>AIgnoreInvalidSequence</var> 
is set to <var>True</var>, in which case the character will be copied as-is to the output.
</p>
<p>
Unicode collation data can be loaded using <link id="RegisterCollation"/> or <link id="LoadCollation"/>
</p>
</descr>
<errors>
On error, a nonzero value will be returned.
</errors>
<seealso>
<link id="UnicodeToUpper"/>
<link id="RegisterCollation"/> 
<link id="LoadCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnicodeToLower.Result">
<short>Zero if all went well, nonzero indicates an error.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToLower.AString">
<short>String to convert to lowercase.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToLower.AIgnoreInvalidSequence">
<short>Set to true to ignore invalid characters.</short>
</element>

<!-- argument Visibility: default -->
<element name="UnicodeToLower.AResultString">
<short>Lowercase equivalent of <var>AString</var></short>
</element>

<!-- function Visibility: default -->
<element name="GetProps">
<short>Get unicode character data</short>
<descr>
<p>
<var>GetProps</var> returns a pointer to a general unicode character property data structure.
The character can be specified using a word or cardinal sized codepoint (<var>ACodePoint</var>), 
or using a  UTF16 encoded surrogate pair (<var>AHighS</var>,<var>ALowS</var>).
</p>
<p>
The returned pointer must not be freed, it points to part of a static structure.
</p>
</descr>
<seealso>
<link id="GetPropUCA"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetProps.Result">
<short>Pointer to unicode character data</short>
</element>

<!-- argument Visibility: default -->
<element name="GetProps.ACodePoint">
<short>Code point (word or cardinal)</short>
</element>

<!-- argument Visibility: default -->
<element name="GetProps.AHighS">
<short>High character in a UTF16 surrogate pair</short>
</element>

<!-- argument Visibility: default -->
<element name="GetProps.ALowS">
<short>Low character in a UTF16 surrogate pair</short>
</element>

<!-- function Visibility: default -->
<element name="GetPropUCA">
<short>Get unicode collation algorithm properties for a unicode character</short>
<descr>
<var>GetPropUCA</var> returns UCA data for the unicode character (<var>AChar</var>) 
or surrogate pair <var>AHighS</var>, <var>ALowS</var>) in the collation data book <var>ABook</var>.
If no data is available, <var>Nil</var> is returned.
</descr>
<errors>
if an invalid <var>ABook</var> is specified, an access violation may occur.
</errors>
<seealso>
<link id="GetProps"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetPropUCA.Result">
<short>UCA data for the character, nil if none is available.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPropUCA.AHighS">
<short>High character of surrogate pair.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPropUCA.ALowS">
<short>Low character of surrogate pair.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPropUCA.ABook">
<short>Unicode Collation Algorithm data set.</short>
</element>

<!-- argument Visibility: default -->
<element name="GetPropUCA.AChar">
<short>Unicode character</short>
</element>

<!-- function Visibility: default -->
<element name="NormalizeNFD">
<short>Perform unicode normalization D on a string</short>
<descr>
<var>NormalizeNFD</var> normalizes the string <var>AString</var> (or the alternate form using a null-terminated <var>AStr</var> with length <var>Alength</var>) to
Unicode Normalization Form D. The resulting string can be used to determine equivalence of unicode strings.

</descr>
<seealso>
<link id="CanonicalOrder"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="NormalizeNFD.Result">
<short>Normalized form (D) of unicode string</short>
</element>

<!-- argument Visibility: default -->
<element name="NormalizeNFD.AString">
<short>Unicode string</short>
</element>

<!-- argument Visibility: default -->
<element name="NormalizeNFD.AStr">
<short>Null-terminated string with length specified in <var>ALength</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="NormalizeNFD.ALength">
<short>Length of null-terminated string <var>AStr</var>.</short>
</element>

<!-- procedure Visibility: default -->
<element name="CanonicalOrder">
<short>Put unicode string in canonical order.</short>
<descr>
<var>CanonicalOrder</var> transforms a unicode string <var>AString</var> 
(or the alternate form using a null-terminated <var>AStr</var> with length <var>Alength</var>)
so it is in canonical order (as defined by the unicode specification).
A string needs to be in canonical order to be able to compare strings.
This function is called as part of  <link id="NormalizeNFD"/>.
</descr>
<seealso>
<link id="NormalizeNFD"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="CanonicalOrder.AString">
<short>Unicode string</short>
</element>

<!-- argument Visibility: default -->
<element name="CanonicalOrder.AStr">
<short>Null-terminated string with length specified in <var>ALength</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="CanonicalOrder.ALength">
<short>Length of null-terminated string <var>AStr</var>.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TUCASortKeyItem">
<short>Alias for WORD</short>
</element>

<!-- array type Visibility: default -->
<element name="TUCASortKey">
<short>Array of <var>TUCASortKeyItem</var></short>
<seealso>
<link id="TUCASortKeyItem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ComputeSortKey">
<short>Compute the sort key for a string</short>
<descr>
<var>ComputeSortKey</var> computes the sort key for a unicode string <var>AString</var> 
(or the alternate form using a null-terminated <var>AStr</var> with length <var>Alength</var>) 
using the Unicode Collation Algorithm dat in <var>ACollation</var>. This key can then be used 
in <link id="CompareSortKey"/> to compare unicode strings.
</descr>
<seealso>
<link id="CompareSortKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ComputeSortKey.Result">
<short>Sort key for the string.</short>
</element>

<!-- argument Visibility: default -->
<element name="ComputeSortKey.AString">
<short>Unicode string</short>
</element>

<!-- argument Visibility: default -->
<element name="ComputeSortKey.ACollation">
<short>Unicode Collation Algorithm data to use.</short>
</element>

<!-- argument Visibility: default -->
<element name="ComputeSortKey.AStr">
<short>Null-terminated string with length specified in <var>ALength</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="ComputeSortKey.ALength">
<short>Length of null-terminated string <var>AStr</var>.</short>
</element>

<!-- function Visibility: default -->
<element name="CompareSortKey">
<short>Compare two sort keys.</short>
<descr>
<p>
<var>CompareSortKey</var> compares 2 sort keys <var>A</var> and <var>B</var>.
It returns
</p>
<ul>
<li>a negative number if <var>A</var> comes alphabetically ordered before <var>B</var>.</li>
<li>Zero if <var>A</var> is alphabetically identical to <var>B</var>.</li>
<li>A positive number iff <var>A</var> is alphabetically ordered after <var>B</var>.</li>
</ul>
<p>
Sort keys can be constructed from unicode strings using <link id="ComputeSortKey"/>.
</p>
</descr>
<seealso>
<link id="ComputeSortKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="CompareSortKey.Result">
<short>A signed number determining how A and B are alphabetically ordered.</short>
</element>

<!-- argument Visibility: default -->
<element name="CompareSortKey.A">
<short>First key to compare</short>
</element>

<!-- argument Visibility: default -->
<element name="CompareSortKey.B">
<short>Second key to compare</short>
</element>

<!-- function Visibility: default -->
<element name="IncrementalCompareString">
<short>Compare 2 strings using the specified collation</short>
<descr>
<var>IncrementalCompareString</var> creates 2 compare keys from the strings <var>AStrA</var> and <var>AStrB</var> using 
collation data in <var>ACollation</var>. The keys are computed only to the point where the two strings
differ. This means the keys cannot be reused for other comparisons if the strings differ. 
The two strings can be specified as a unicode string or as a pointer to a null-terminated character array with a length
 (<var>ALengthA</var> and <var>ALengthB</var>). It returns then the result of <link id="CompareSortKey"/>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ComputeSortKey"/>
<link id="CompareSortKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="IncrementalCompareString.Result">
<short>A signed integer indicating the alphabetic order of <var>AStrA</var> and <var>AStrB</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="IncrementalCompareString.AStrA">
<short>First string in comparison.</short>
</element>

<!-- argument Visibility: default -->
<element name="IncrementalCompareString.ALengthA">
<short>Length of string <var>AStrA</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="IncrementalCompareString.AStrB">
<short>Second string in comparison.</short>
</element>

<!-- argument Visibility: default -->
<element name="IncrementalCompareString.ALengthB">
<short>Length of string <var>AStrN</var></short>
</element>

<!-- argument Visibility: default -->
<element name="IncrementalCompareString.ACollation">
<short>Collation to use.</short>
</element>

<!-- function Visibility: default -->
<element name="RegisterCollation">
<short>Register a new collation</short>
<descr>
<p>
<var>RegisterCollation</var> registers a new collation <var>ACollation</var> in the list of known collations. 
The collation data can be specified directly (<var>ACollation</var>) or a name of a language (<var>ALanguage</var>)
in a directory (<var>ADirectory</var>). The latter option will load the binary encodeded collation from file 
using <link id="LoadCollation"/>.
</p>
<p>
If the collation is loaded correctly, <var>True</var> is returned, otherwise <var>False</var> is returned 
(for instance when a collation with the same name is already loaded).
</p>
</descr>
<seealso>
<link id="UnRegisterCollation"/>
<link id="UnRegisterCollations"/>
<link id="LoadCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="RegisterCollation.Result">
<short><var>True</var> if the collation is registered correctly.</short>
</element>

<!-- argument Visibility: default -->
<element name="RegisterCollation.ACollation">
<short>Pointer to collation data in memory</short>
</element>

<!-- argument Visibility: default -->
<element name="RegisterCollation.ADirectory">
<short>Directory to search for <var>ALanguage</var> collation data.</short>
</element>

<!-- argument Visibility: default -->
<element name="RegisterCollation.ALanguage">
<short>Name of language data.</short>
</element>

<!-- function Visibility: default -->
<element name="UnregisterCollation">
<short>Remove a collation from the list of known collections.</short>
<descr>
<var>UnRegisterCollation</var> removes a collation <var>AName</var> from the list of known collations. 
It returns <var>True</var> if the collation was found and succesfully removed. 
</descr>
<errors>
If the collation was not found, <var>False</var> is returned.
</errors>
<seealso>
<link id="RegisterCollation"/>
<link id="UnRegisterCollations"/>
<link id="LoadCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="UnregisterCollation.Result">
<short><var>True</var> if the collation was found and succesfully removed</short>
</element>

<!-- argument Visibility: default -->
<element name="UnregisterCollation.AName">
<short>Name of collation to remove.</short>
</element>

<!-- procedure Visibility: default -->
<element name="UnregisterCollations">
<short>Unregister all collations.</short>
<descr>
<var>UnregisterCollations</var> unregisters all known collations. 
If <var>AFreeDynamicCollations</var> is <var>True</var>, then dynamic collations will be removed from memory 
using <link id="FreeCollation"/>. This must normally be set to <var>true</var>.
</descr>
<seealso>
<link id="RegisterCollation"/>
<link id="UnRegisterCollation"/>
<link id="LoadCollation"/>
<link id="FreeCollation"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="UnregisterCollations.AFreeDynamicCollations">
<short>Should dynamic collations be freed from memory ?</short>
</element>

<!-- function Visibility: default -->
<element name="FindCollation">
<short>Find a collation by name</short>
<descr>
<var>FindCollection</var> searches a collation with name <var>AName</var> or index <var>AIndex</var>
in the list of known collations and returns a pointer to the collation data.
If the requested collation is not known, i.e. the name is not found, or the index is out of range,
then <var>Nil</var> is returned. The valid index range is 0 to <var>GetCollationCount-1</var>. 
</descr>
<seealso>
<link id="GetCollationCount"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="FindCollation.Result">
<short>Pointer to collation data</short>
</element>

<!-- argument Visibility: default -->
<element name="FindCollation.AName">
<short>Name of collation to find.</short>
</element>

<!-- argument Visibility: default -->
<element name="FindCollation.AIndex">
<short>Index of collation</short>
</element>

<!-- function Visibility: default -->
<element name="GetCollationCount">
<short>Return the number of known collations.</short>
<descr>
<var>GetCollationCount</var> returns the number of registered collations. 
The collation data can be retrieved by index using the <link id="FindCollation"/>. 
The maximum index is <var>GetCollationCount-1</var>.
</descr>
<seealso>
<link id="FindCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="GetCollationCount.Result">
<short>Number of known collations.</short>
</element>

<!-- procedure Visibility: default -->
<element name="PrepareCollation">
<short>Prepare a collation for use in the list</short>
<descr>
<p>
<var>PrepareCollation</var> will link collation definition <var>ACollation</var> to the base collection with name <var>ABaseName</var> 
(if empty, it defaults to the root collation). It will also initialize some fields in the definition, copying them from the base collation, 
but excludes the fields enumerated in <var>AChangedFields</var>.
</p>
<p>
It should normally not be needed to call this function, it is called as part of <link id="LoadCollation"/>.
</p>
</descr>
<seealso>
<link id="LoadCollation"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="PrepareCollation.ACollation">
<short>Collation data to prepare</short>
</element>

<!-- argument Visibility: default -->
<element name="PrepareCollation.ABaseName">
<short>Base collation to connect to</short>
</element>

<!-- argument Visibility: default -->
<element name="PrepareCollation.AChangedFields">
<short>Changed fields, which should not be initialized</short>
</element>

<!-- function Visibility: default -->
<element name="LoadCollation">
<short>Load a binary collation data file from file</short>
<descr>
<p>
<var>LoadCollation</var> loads collation data from file <var>AFileName</var>, or from a memory block 
<var>AData</var> with length <var>ADataLength</var>. If successful, it returns a pointer which can be 
used to register the collation using <link id="RegisterCollation"/>. if there is a problem with 
the data, <var>Nil</var> is returned.
</p>
<p>
The filename can also be specified as a <var>Directory</var> and language name <var>ALanguage</var>.
The latter is prepended with <var>collation_</var> and appended with the native endianness of the 
current platform, and has extension <var>.bco</var>
</p>
</descr>
<errors>
If the file containing data does not exist or has a size which is less than the encoded header size, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="RegisterCollation"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="LoadCollation.Result">
<short>Pointer to prepared collation data</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadCollation.AData">
<short>Memory area containing encoded collation data</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadCollation.ADataLength">
<short>Length of memory area <var>AData</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadCollation.AFileName">
<short>Filename to read data from</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadCollation.ADirectory">
<short>Directory containing collations.</short>
</element>

<!-- argument Visibility: default -->
<element name="LoadCollation.ALanguage">
<short>Language for which to load collation.</short>
</element>

<!-- procedure Visibility: default -->
<element name="FreeCollation">
<short>Free collation data.</short>
<descr>
<var>FreeCollation</var> removes all structures in the collation data from memory. 
It will not do anything when the header field <var>Dynamic</var> is <var>false</var>.
(collations loaded and registered using <link id="LoadCollation"/> are always dynamic and must be freed). 
</descr>
<seealso>
<link id="LoadCollation"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="FreeCollation.AItem">
<short>Collation to free</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TEndianKind">
<short>Endianness enumerator</short>
<descr>
<var>TEndianKind</var> is an auxiliary enumerated type to enumerate the endianness of platforms.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TEndianKind.Little">
<short>Little-endian platform</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TEndianKind.Big">
<short>Big-endian platform</short>
</element>

<!-- constant Visibility: default -->
<element name="ENDIAN_SUFFIX">
<short>Suffixes for endianness.</short>
<descr>
<var>ENDIAN_SUFFIX</var> contains the suffixes used in <link id="LoadCollation"/> when constructing a collation filename for a language.
</descr>
<seealso>
<link id="LoadCollation"/>
</seealso>
</element>

<!-- resource string Visibility: default -->
<element name="SCollationNotFound">
<short>Error message when a collation is not found.</short>
</element>

</module> <!-- unicodedata -->

</package>
</fpdoc-descriptions>
