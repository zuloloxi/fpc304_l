<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<!--

   $Id: oldlinux.xml,v 1.6 2004/10/22 22:03:17 michael Exp $
   This file is part of the FPC documentation.
   Copyright (C) 1997, by Michael Van Canneyt

   The FPC documentation is free text; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The FPC Documentation is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the FPC documentation; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
 -->
<package name="rtl">
<module name="oldlinux">
<short>1.0.X version of the Linux unit - for compatibility only.</short>
<!-- \FPCexampledir{olinuxex} -->
<descr>
This document describes the LINUX unit for Free Pascal. The unit was written
by Michael van Canneyt. It works only on the Linux/X86 operating system.
</descr>

<element name="PGlob">
<short>Pointer to <link id="TGlob"/> record.</short>
</element>
<element name="TGlob">
<short>Record containing one entry in the result of <link id="Glob"/></short>
</element>
<element name="TGlob.Name">
<short>Filename matching the search criteria</short>
</element>
<element name="TGlob.Next">
<short>Next element in result of <var>Glob</var> call.</short>
</element>

<element name="tfpreg">
<short>Record describing floating point register in signal handler.</short>
</element>
<element name="tfpreg.significand">
<short>Decimal part of floating point value</short>
</element>
<element name="tfpreg.exponent">
<short>Exponent of floating point value</short>
</element>

<element name="pfpstate">
<short>Pointer to <link id="tfpstate"/> record.</short>
</element>
<element name="tfpstate">
<short>Record describing floating point unit in signal handler.</short>
</element>
<element name="tfpstate.cw">
<short></short>
</element>
<element name="tfpstate.sw">
<short></short>
</element>
<element name="tfpstate.tag">
<short></short>
</element>
<element name="tfpstate.ipoff">
<short></short>
</element>
<element name="tfpstate.cssel">
<short></short>
</element>
<element name="tfpstate.dataoff">
<short></short>
</element>
<element name="tfpstate.datasel">
<short></short>
</element>
<element name="tfpstate.st">
<short></short>
</element>
<element name="tfpstate.status">
<short></short>
</element>

<element name="PSigContextRec">
<short>Pointer to <link id="SigContextRec"/> record</short>
</element>
<element name="SigContextRec">
<short>Record describing the context of the program when it receives a signal</short>
<descr>
The above records contain information about the processor state and process
state at the moment a signal is sent to your program.
</descr>
</element>
<element name="SigContextRec.gs">
<short>Low part of gs register</short>
</element>
<element name="SigContextRec.__gsh">
<short>High part of gs register</short>
</element>
<element name="SigContextRec.fs">
<short>Low part of FS register</short>
</element>
<element name="SigContextRec.__fsh">
<short>High part of FS register</short>
</element>
<element name="SigContextRec.es">
<short>Low part of ES register</short>
</element>
<element name="SigContextRec.__esh">
<short>High part of ES register</short>
</element>
<element name="SigContextRec.ds">
<short>Low part of DS register</short>
</element>
<element name="SigContextRec.__dsh">
<short>High  part of DS register</short>
</element>
<element name="SigContextRec.edi">
<short>EDI register</short>
</element>
<element name="SigContextRec.esi">
<short>ESI register</short>
</element>
<element name="SigContextRec.ebp">
<short>EBP register</short>
</element>
<element name="SigContextRec.esp">
<short>ESP register</short>
</element>
<element name="SigContextRec.ebx">
<short>EBX register</short>
</element>
<element name="SigContextRec.edx">
<short>EDX register</short>
</element>
<element name="SigContextRec.ecx">
<short>ECX register</short>
</element>
<element name="SigContextRec.eax">
<short>EAX register</short>
</element>
<element name="SigContextRec.trapno">
<short>Interrupt number</short>
</element>
<element name="SigContextRec.err">
<short>Error register (?)</short>
</element>
<element name="SigContextRec.eip">
<short>IP (Instruction Pointer) register</short>
</element>
<element name="SigContextRec.cs">
<short>Low part of CS register</short>
</element>
<element name="SigContextRec.__csh">
<short>High part of CS register</short>
</element>
<element name="SigContextRec.eflags">
<short>Flags register</short>
</element>
<element name="SigContextRec.esp_at_signal">
<short>ESP register at signal.</short>
</element>
<element name="SigContextRec.ss">
<short>Low part of SS register</short>
</element>
<element name="SigContextRec.__ssh">
<short>High part of SS register</short>
</element>
<element name="SigContextRec.fpstate">
<short>Floating Point unit state</short>
</element>
<element name="SigContextRec.oldmask">
<short>Old signal mask</short>
</element>
<element name="SigContextRec.cr2">
<short>?</short>
</element>

<element name="TSigAction">
<short>Function prototype for <link id="SigAction"/> call.</short>
</element>
<element name="SignalHandler">
<short>Function prototype for the <link id="Signal"/> call.</short>
</element>
<element name="PSignalHandler">
<short>Pointer to <link id="SignalHandler"/> type.</short>
</element>
<element name="SignalRestorer">
<short>Signal restorer function prototype</short>
</element>
<element name="PSignalrestorer">
<short>Pointer to <link id="SignalRestorer"/> type</short>
</element>
<element name="PSigActionRec">
<short>Pointer to <link id="SigActionRec"/> record.</short>
</element>
<element name="SigActionRec">
<short>Record used in <link id="SigAction"/> call.</short>
</element>
<element name="SigActionRec.Handler">
<short>Funcion called when signal is triggered.</short>
</element>
<element name="SigActionRec.Sa_Mask">
<short>Signal mask.</short>
</element>
<element name="SigActionRec.SA_FLAGS">
<short>Flags for SigAction</short>
</element>
<element name="SigActionRec.SA_RESTORER">
<short>Obsolete, don't use</short>
</element>

<element name="stat">
<short>Record describing an inode (file) in the <link id="fstat"/> call.</short>
</element>
<element name="stat.dev">
<short>Device number</short>
</element>
<element name="stat.pad1">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.ino">
<short>Inode number of file</short>
</element>
<element name="stat.mode">
<short>File mode</short>
</element>
<element name="stat.nlink">
<short>Number of links to file.</short>
</element>
<element name="stat.uid">
<short>File owner UID</short>
</element>
<element name="stat.gid">
<short>File owner GID</short>
</element>
<element name="stat.rdev">
<short></short>
</element>
<element name="stat.pad2">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.size">
<short>File size</short>
</element>
<element name="stat.blksize">
<short>Block size</short>
</element>
<element name="stat.blocks">
<short>Number of blocks used</short>
</element>
<element name="stat.atime">
<short>Last access time</short>
</element>
<element name="stat.unused1">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.mtime">
<short>Last modification time.</short>
</element>
<element name="stat.unused2">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.ctime">
<short>Creation time</short>
</element>
<element name="stat.unused3">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.unused4">
<short>Pad byte. Do not use</short>
</element>
<element name="stat.unused5">
<short>Pad byte. Do not use</short>
</element>

<element name="statfs">
<short>Record describing a file system in the <link id="fsstat"/> call.</short>
</element>
<element name="statfs.fstype">
<short>File system type</short>
</element>
<element name="statfs.bsize">
<short>Block size</short>
</element>
<element name="statfs.blocks">
<short>Total number of blocks</short>
</element>
<element name="statfs.bfree">
<short>Number of free blocks</short>
</element>
<element name="statfs.bavail">
<short>Number of available blocks</short>
</element>
<element name="statfs.files">
<short>Number of files</short>
</element>
<element name="statfs.ffree">
<short>?</short>
</element>
<element name="statfs.fsid">
<short>?</short>
</element>
<element name="statfs.namelen">
<short>Max name length for files.</short>
</element>
<element name="statfs.spare">
<short>Pad bytes. Do not use.</short>
</element>


<element name="PDir">
<short>Pointer to <link id="TDir"/> record</short>
</element>
<element name="TDir">
<short>Record used in <link id="OpenDir"/> and <link id="ReadDir"/> calls</short>
</element>
<element name="TDir.fd">
<short>File descriptor. Do not use.</short>
</element>
<element name="TDir.loc">
<short>Location in directory listing</short>
</element>
<element name="TDir.size">
<short>File size</short>
</element>
<element name="TDir.buf">
<short>Pointer to <link id="TDir"/> records</short>
</element>
<element name="TDir.nextoff">
<short>?</short>
</element>
<element name="TDir.dd_max">
<short>?</short>
</element>
<element name="TDir.lock">
<short>?</short>
</element>

<element name="PDirEnt">
<short>Pointer to <link id="Dirent"/> record.</short>
</element>
<element name="Dirent">
<short>Record used in the <link id="ReadDir"/> function to return files in a directory.</short>
</element>
<element name="Dirent.ino">
<short>Inode number of file</short>
</element>
<element name="Dirent.off">
<short>Offset in directory.</short>
</element>
<element name="Dirent.reclen">
<short>Record length</short>
</element>
<element name="Dirent.name">
<short>Name of file</short>
</element>

<element name="NCCS">
<short>Number of control characters in <link id="termios"/> record.</short>
</element>
<element name="NCC">
<short>Number of control characters in <link id="termio"/> record.</short>
</element>

<element name="termio">
<short>Terminal I/O description record (small)</short>
</element>
<element name="termio.c_iflag">
<short>input mode flags</short>
</element>
<element name="termio.c_oflag">
<short>output mode flags</short>
</element>
<element name="termio.c_cflag">
<short>control mode flags</short>
</element>
<element name="termio.c_lflag">
<short>local mode flags</short>
</element>
<element name="termio.c_line">
<short>line discipline</short>
</element>
<element name="termio.c_cc">
<short>control characters</short>
</element>

<element name="termios">
<short>Terminal I/O description record</short>
</element>
<element name="termios.c_iflag">
<short>input mode flags</short>
</element>
<element name="termios.c_oflag">
<short>output mode flags</short>
</element>
<element name="termios.c_cflag">
<short>control mode flags</short>
</element>
<element name="termios.c_lflag">
<short>local mode flags</short>
</element>
<element name="termios.c_line">
<short>line discipline</short>
</element>
<element name="termios.c_cc">
<short>control characters</short>
</element>

<element name="Utimbuf">
<short>Record used in <link id="Utime"/> to set file access and modificaton times.</short>
</element>
<element name="Utimbuf.actime">
<short>Access time</short>
</element>
<element name="Utimbuf.modtime">
<short>Modification time</short>
</element>

<element name="PFDSet">
<short>Pointer to <link id="FDSet"/> array.</short>
</element>
<element name="FDSet">
<short>Array containing file descriptor bitmask for the <link id="Select"/> call.</short>
</element>

<element name="TimeVal">
<short>Record specifying a time inteval.</short>
</element>
<element name="TimeVal.sec">
<short>Number of seconds</short>
</element>
<element name="TimeVal.usec">
<short>Number of milliseconds</short>
</element>
<element name="PTimeVal">
<short>Pointer to <link id="TTimeVal"/> record</short>
</element>

<element name="timespec">
<short>Time interval for the <link id="NanoSleep"/> function.</short>
</element>
<element name="timespec.tv_sec">
<short>Number of seconds</short>
</element>
<element name="timespec.tv_nsec">
<short>Number of nanoseconds</short>
</element>

<element name="utsname">
<short>Record used to return kernel information in <link id="UName"/> function.</short>
<descr>
The elements of this record are null-terminated C style strings, you cannot access them
directly.
</descr>
</element>
<element name="utsname.sysname">
<short>System name</short>
</element>
<element name="utsname.nodename">
<short>Computer name</short>
</element>
<element name="utsname.release">
<short>Release number</short>
</element>
<element name="utsname.version">
<short>Version number</short>
</element>
<element name="utsname.machine">
<short>Machine type</short>
</element>
<element name="utsname.domainname">
<short>Domain name</short>
</element>

<element name="linuxerror">
<short>Last operating system error</short>
<descr>
<var>Linuxerror</var> is the variable in which the procedures in the linux unit
report errors.
</descr>
</element>

<element name="stderr">
<short>Standard error output (deprecated)</short>
<descr>
<p>
<var>StdErr</var> Is a <var>Text</var> variable, corresponding to Standard Error or
diagnostic output. It is connected to file descriptor 2. It can be freely
used, and will be closed on exit.
</p>
<p>
This variable is deprecated. Please use the corresponding variable in
the system unit for disgnostic messages.
</p>
</descr>
</element>

<element name="Prio_Process">
<short>Get/Set process priority</short>
</element>
<element name="Prio_PGrp">
<short>Get/set process group priority</short>
</element>
<element name="Prio_user">
<short>Get/set user priority</short>
</element>

<element name="R_OK">
<short><link id="Access"/> call test: read allowed</short>
</element>
<element name="W_OK">
<short><link id="Access"/> call test: write allowed</short>
</element>
<element name="X_OK">
<short><link id="Access"/> call test: execute allowed</short>
</element>
<element name="F_OK">
<short><link id="Access"/> call test: file exists.</short>
</element>

<element name="SA_NOCLDSTOP">
<short>Sigaction options: Do not receive notification when child processes stop</short>
</element>
<element name="SA_SHIRQ">
<short>Sigaction options: ?</short>
</element>
<element name="SA_STACK">
<short>Sigaction options: Call the signal handler on an alternate signal stack.</short>
</element>
<element name="SA_RESTART">
<short>Sigaction options: Provide behaviour compatible with BSD signal semantics</short>
</element>
<element name="SA_INTERRUPT">
<short>Sigaction options: ?</short>
</element>
<element name="SA_NOMASK">
<short>Sigaction options: Do not prevent the signal from being received when it is handled.</short>
</element>
<element name="SA_ONESHOT">
<short>Sigaction options: Restore the signal action to the default state.</short>
</element>

<element name="SIG_BLOCK">
<short>Sigprocmask flags: Add signals to the set of blocked signals.</short>
</element>
<element name="SIG_UNBLOCK">
<short>Sigprocmask flags: Remove signals from the set set of blocked signals.</short>
</element>
<element name="SIG_SETMASK">
<short>Sigprocmask flags: Set of blocked signals is given.</short>
</element>
<element name="SIG_DFL">
<short>Signal handler: Default signal handler</short>
</element>
<element name="SIG_IGN">
<short>Signal handler: Ignore signal</short>
</element>
<element name="SIG_ERR">
<short>Signal handler: error</short>
</element>

<element name="SIGHUP">
<short>Signal: HUP (Hangup)</short>
</element>
<element name="SIGINT">
<short>Signal: INT (Interrupt)</short>
</element>
<element name="SIGQUIT">
<short>Signal: QUIT</short>
</element>
<element name="SIGILL">
<short>Signal: ILL (Illegal instruction)</short>
</element>
<element name="SIGTRAP">
<short>Signal: TRAP (Trace trap)</short>
</element>
<element name="SIGABRT">
<short>Signal: ABRT (Abort)</short>
</element>
<element name="SIGIOT">
<short>Signal: IOT (IOT trap)</short>
</element>
<element name="SIGBUS">
<short>Signal: BUS (bus error)</short>
</element>
<element name="SIGFPE">
<short>Signal: FPE (Floating point error)</short>
</element>
<element name="SIGKILL">
<short>Signal: KILL (unblockable)</short>
</element>
<element name="SIGUSR1">
<short>Signal: USR1 (User-defined signal 1)</short>
</element>
<element name="SIGSEGV">
<short>Signal: SEGV (Segmentation violation)</short>
</element>
<element name="SIGUSR2">
<short>Signal: USR2 (User-defined signal 2)</short>
</element>
<element name="SIGPIPE">
<short>Signal: PIPE (Broken pipe</short>
</element>
<element name="SIGALRM">
<short>Signal: ALRM (Alarm clock)</short>
</element>
<element name="SIGTERM">
<short>Signal: TERM (Terminate)</short>
</element>
<element name="SIGSTKFLT">
<short>Signal: STKFLT (Stack Fault)</short>
</element>
<element name="SIGCHLD">
<short>Signal: CHLD (child status changed)</short>
</element>
<element name="SIGCONT">
<short>Signal: CONT (Continue)</short>
</element>
<element name="SIGSTOP">
<short>Signal: STOP (Stop, unblockable)</short>
</element>
<element name="SIGTSTP">
<short>Signal: TSTP (keyboard stop)</short>
</element>
<element name="SIGTTIN">
<short>Signal: TTIN (Terminal input, background)</short>
</element>
<element name="SIGTTOU">
<short>Signal: TTOU (Terminal output, background)</short>
</element>
<element name="SIGURG">
<short>Signal: URG (Socket urgent condition)</short>
</element>
<element name="SIGXCPU">
<short>Signal: XCPU (CPU limit exceeded)</short>
</element>
<element name="SIGXFSZ">
<short>Signal: XFSZ (File size limit exceeded)</short>
</element>
<element name="SIGVTALRM">
<short>Signal: VTALRM (Virtual alarm clock)</short>
</element>
<element name="SIGPROF">
<short>Signal: PROF (Profiling alarm)</short>
</element>
<element name="SIGWINCH">
<short>Signal: WINCH (Window/Terminal size change)</short>
</element>
<element name="SIGIO">
<short>Signal: IO (I/O operation possible)</short>
</element>
<element name="SIGPOLL">
<short>Signal: POLL (Pollable event)</short>
</element>
<element name="SIGPWR">
<short>Signal: PWR (power failure restart)</short>
</element>
<element name="SIGUNUSED">
<short>Signal: Unused</short>
</element>

<element name="F_GetFd">
<short><link id="FCntl"/> command:  Get close-on-exec flag</short>
</element>
<element name="F_SetFd">
<short><link id="FCntl"/> command:  Set close-on-exec flag</short>
</element>
<element name="F_GetFl">
<short><link id="FCntl"/> command:  Get filedescriptor flags</short>
</element>
<element name="F_SetFl">
<short><link id="FCntl"/> command:  Set filedescriptor flags</short>
</element>
<element name="F_GetLk">
<short><link id="FCntl"/> command:  Get lock</short>
</element>
<element name="F_SetLk">
<short><link id="FCntl"/> command:  Set lock</short>
</element>
<element name="F_SetLkW">
<short><link id="FCntl"/> command:  Test lock</short>
</element>
<element name="F_GetOwn">
<short><link id="FCntl"/> command:  get owner of filedescriptor events</short>
</element>
<element name="F_SetOwn">
<short><link id="FCntl"/> command:  Set owner of filedescriptor events</short>
</element>

<element skip="1" name="TCGETS"/>
<element skip="1" name="TCSETS"/>
<element skip="1" name="TCSETSW"/>
<element skip="1" name="TCSETSF"/>
<element skip="1" name="TCGETA"/>
<element skip="1" name="TCSETA"/>
<element skip="1" name="TCSETAW"/>
<element skip="1" name="TCSETAF"/>
<element skip="1" name="TCSBRK"/>
<element skip="1" name="TCXONC"/>
<element skip="1" name="TCFLSH"/>
<element skip="1" name="TIOCEXCL"/>
<element skip="1" name="TIOCNXCL"/>
<element skip="1" name="TIOCSCTTY"/>
<element skip="1" name="TIOCGPGRP"/>
<element skip="1" name="TIOCSPGRP"/>
<element skip="1" name="TIOCOUTQ"/>
<element skip="1" name="TIOCSTI"/>
<element skip="1" name="TIOCGWINSZ"/>
<element skip="1" name="TIOCSWINSZ"/>
<element skip="1" name="TIOCMGET"/>
<element skip="1" name="TIOCMBIS"/>
<element skip="1" name="TIOCMBIC"/>
<element skip="1" name="TIOCMSET"/>
<element skip="1" name="TIOCGSOFTCAR"/>
<element skip="1" name="TIOCSSOFTCAR"/>
<element skip="1" name="FIONREAD"/>
<element skip="1" name="TIOCINQ"/>
<element skip="1" name="TIOCLINUX"/>
<element skip="1" name="TIOCCONS"/>
<element skip="1" name="TIOCGSERIAL"/>
<element skip="1" name="TIOCSSERIAL"/>
<element skip="1" name="TIOCPKT"/>
<element skip="1" name="FIONBIO"/>
<element skip="1" name="TIOCNOTTY"/>
<element skip="1" name="TIOCSETD"/>
<element skip="1" name="TIOCGETD"/>
<element skip="1" name="TCSBRKP"/>
<element skip="1" name="TIOCTTYGSTRUCT"/>
<element skip="1" name="FIONCLEX"/>
<element skip="1" name="FIOCLEX"/>
<element skip="1" name="FIOASYNC"/>
<element skip="1" name="TIOCSERCONFIG"/>
<element skip="1" name="TIOCSERGWILD"/>
<element skip="1" name="TIOCSERSWILD"/>
<element skip="1" name="TIOCGLCKTRMIOS"/>
<element skip="1" name="TIOCSLCKTRMIOS"/>
<element skip="1" name="TIOCSERGSTRUCT"/>
<element skip="1" name="TIOCSERGETLSR"/>
<element skip="1" name="TIOCSERGETMULTI"/>
<element skip="1" name="TIOCSERSETMULTI"/>
<element skip="1" name="TIOCMIWAIT"/>
<element skip="1" name="TIOCGICOUNT"/>
<element skip="1" name="TIOCPKT_DATA"/>
<element skip="1" name="TIOCPKT_FLUSHREAD"/>
<element skip="1" name="TIOCPKT_FLUSHWRITE"/>
<element skip="1" name="TIOCPKT_STOP"/>
<element skip="1" name="TIOCPKT_START"/>
<element skip="1" name="TIOCPKT_NOSTOP"/>
<element skip="1" name="TIOCPKT_DOSTOP"/>

<element name="STAT_IFMT">
<short>File (<link id="stat"/> record) mode: File type bit mask</short>
</element>
<element name="STAT_IFSOCK">
<short>File (<link id="stat"/> record) mode: Socket</short>
</element>
<element name="STAT_IFLNK">
<short>File (<link id="stat"/> record) mode: Link</short>
</element>
<element name="STAT_IFREG">
<short>File (<link id="stat"/> record) mode: Regular file</short>
</element>
<element name="STAT_IFBLK">
<short>File (<link id="stat"/> record) mode: Block device</short>
</element>
<element name="STAT_IFDIR">
<short>File (<link id="stat"/> record) mode: Directory</short>
</element>
<element name="STAT_IFCHR">
<short>File (<link id="stat"/> record) mode: Character device</short>
</element>
<element name="STAT_IFIFO">
<short>File (<link id="stat"/> record) mode: FIFO</short>
</element>
<element name="STAT_ISUID">
<short>File (<link id="stat"/> record) mode: UID bit set</short>
</element>
<element name="STAT_ISGID">
<short>File (<link id="stat"/> record) mode: GID bit set</short>
</element>
<element name="STAT_ISVTX">
<short>File (<link id="stat"/> record) mode: Sticky bit set</short>
</element>
<element name="STAT_IRWXO">
<short>File (<link id="stat"/> record) mode: Other permission bits mask</short>
</element>
<element name="STAT_IROTH">
<short>File (<link id="stat"/> record) mode: Other read permission</short>
</element>
<element name="STAT_IWOTH">
<short>File (<link id="stat"/> record) mode: Other write permission</short>
</element>
<element name="STAT_IXOTH">
<short>File (<link id="stat"/> record) mode: Others execute permission</short>
</element>
<element name="STAT_IRWXG">
<short>File (<link id="stat"/> record) mode: Group permission bits mask</short>
</element>
<element name="STAT_IRGRP">
<short>File (<link id="stat"/> record) mode: Group read permission</short>
</element>
<element name="STAT_IWGRP">
<short>File (<link id="stat"/> record) mode: Group write permission</short>
</element>
<element name="STAT_IXGRP">
<short>File (<link id="stat"/> record) mode: Others execute permission</short>
</element>
<element name="STAT_IRWXU">
<short>File (<link id="stat"/> record) mode: Owner permission bits mask</short>
</element>
<element name="STAT_IRUSR">
<short>File (<link id="stat"/> record) mode: Owner read permission</short>
</element>
<element name="STAT_IWUSR">
<short>File (<link id="stat"/> record) mode: Owner write permission</short>
</element>
<element name="STAT_IXUSR">
<short>File (<link id="stat"/> record) mode: Others execute permission</short>
</element>

<element name="fs_old_ext2">
<short>File system type (<link id="FSStat"/>): (ext2) Old second extended</short>
</element>
<element name="fs_ext2">
<short>File system type (<link id="FSStat"/>): (ext2) Second extended</short>
</element>
<element name="fs_ext">
<short>File system type (<link id="FSStat"/>): (ext) Extended</short>
</element>
<element name="fs_iso">
<short>File system type (<link id="FSStat"/>): ISO 9660</short>
</element>
<element name="fs_minix">
<short>File system type (<link id="FSStat"/>): Minix</short>
</element>
<element name="fs_minix_30">
<short>File system type (<link id="FSStat"/>): Minix 3.0</short>
</element>
<element name="fs_minux_V2">
<short>File system type (<link id="FSStat"/>): Minix V2</short>
</element>
<element name="fs_msdos">
<short>File system type (<link id="FSStat"/>): MSDOS (FAT)</short>
</element>
<element name="fs_nfs">
<short>File system type (<link id="FSStat"/>): NFS</short>
</element>
<element name="fs_proc">
<short>File system type (<link id="FSStat"/>): PROC fs</short>
</element>
<element name="fs_xia">
<short>File system type (<link id="FSStat"/>): XIA</short>
</element>

<element name="LOCK_SH">
<short><link id="FLock"/> Shared lock</short>
</element>
<element name="LOCK_EX">
<short><link id="FLock"/> Exclusive lock</short>
</element>
<element name="LOCK_UN">
<short><link id="FLock"/> unlock</short>
</element>
<element name="LOCK_NB">
<short><link id="FLock"/> Non-blocking operation</short>
</element>

<element name="PROT_READ">
<short><link id="MMap"/> memory access: page can be read</short>
</element>
<element name="PROT_WRITE">
<short><link id="MMap"/> memory access: page can be written</short>
</element>
<element name="PROT_EXEC">
<short><link id="MMap"/> memory access: page can be executed</short>
</element>
<element name="PROT_NONE">
<short><link id="MMap"/> memory access: page can not be accessed</short>
</element>

<element name="MAP_SHARED">
<short><link id="MMap"/> map type: Share changes</short>
</element>
<element name="MAP_PRIVATE">
<short><link id="MMap"/> map type: Changes are private</short>
</element>
<element name="MAP_TYPE">
<short><link id="MMap"/> map type: Bitmask for type of mapping</short>
</element>
<element name="MAP_FIXED">
<short><link id="MMap"/> map type: Interpret addr exactly</short>
</element>
<element name="MAP_ANONYMOUS">
<short><link id="MMap"/> map type: Don't use a file</short>
</element>

<topic name="FileIORoutines">
<short>File Input/Output routines</short>
<descr>
<p>
Functions for handling file input/output.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Dup"/></td><td>Duplicate a file handle</td></tr>
<tr><td><link id="Dup2"/></td><td>Copy one file handle to another</td></tr>
<tr><td><link id="Fcntl"/></td><td>General file control</td></tr>
<tr><td><link id="fdClose"/></td><td>Close file descriptor</td></tr>
<tr><td><link id="fdFlush"/></td><td>Flush file descriptor</td></tr>
<tr><td><link id="fdOpen"/></td><td>Open new file descriptor</td></tr>
<tr><td><link id="fdRead"/></td><td>Read from file descriptor</td></tr>
<tr><td><link id="fdSeek"/></td><td>Position in file</td></tr>
<tr><td><link id="fdTruncate"/></td><td>Truncate file</td></tr>
<tr><td><link id="fdWrite"/></td><td>Write to file descriptor</td></tr>
<tr><td><link id="GetFS"/></td><td>Get file descriptor of pascal file</td></tr>
<tr><td><link id="Select"/></td><td>Wait for input from file descriptor</td></tr>
<tr><td><link id="SelectText"/></td><td>Wait for input from pascal file</td></tr>
</table>
</descr>
</topic>

<topic name="FileHandlingRoutines">
<short>General File handling routines</short>
<descr>
<p>
Functions for handling files on disk.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Access"/></td><td>Check access rights on file</td></tr>
<tr><td><link id="BaseName"/></td><td>Return name part of file</td></tr>
<tr><td><link id="Chown"/></td><td>Change owner of file</td></tr>
<tr><td><link id="Chmod"/></td><td>Change access rights on file</td></tr>
<tr><td><link id="DirName"/></td><td>Return directory part of file</td></tr>
<tr><td><link id="FSplit"/></td><td>Split filename in parts</td></tr>
<tr><td><link id="FExpand"/></td><td>Return full-grown filename</td></tr>
<tr><td><link id="FLock"/></td><td>Set lock on a file</td></tr>
<tr><td><link id="FNMatch"/></td><td>Match filename to searchpattern</td></tr>
<tr><td><link id="FSearch"/></td><td>Search for a file in a path</td></tr>
<tr><td><link id="FSStat"/></td><td>Return filesystem information</td></tr>
<tr><td><link id="FStat"/></td><td>Return file information</td></tr>
<tr><td><link id="FRename"/></td><td>Rename file</td></tr>
<tr><td><link id="LStat"/></td><td>Return information on a link</td></tr>
<tr><td><link id="Link"/></td><td>Create a link</td></tr>
<tr><td><link id="ReadLink"/></td><td>Read contents of a symbolic link</td></tr>
<tr><td><link id="SymLink"/></td><td>Create a symbolic link</td></tr>
<tr><td><link id="Umask"/></td><td>Set the file creation mask</td></tr>
<tr><td><link id="UnLink"/></td><td>Remove a file</td></tr>
<tr><td><link id="Utime"/></td><td>Change file timestamps</td></tr>
</table>
</descr>
</topic>

<topic name="PipeFIFORoutines">
<short>Pipes, FIFOs and streams</short>
<descr>
<p>
Functions for creating and managing pipes.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="AssignPipe"/></td><td>Create a pipe</td></tr>
<tr><td><link id="AssignStream"/></td><td>Create pipes to program's input and output</td></tr>
<tr><td><link id="MkFifo"/></td><td>Make a fifo</td></tr>
<tr><td><link id="PClose"/></td><td>Close a pipe</td></tr>
<tr><td><link id="POpen"/></td><td>Open a pipe for to program's input or output</td></tr>
</table>
</descr>
</topic>

<topic name="DirectoryRoutines">
<short>Directory handling routines</short>
<descr>
<p>
Functions for reading and searching directories.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="CloseDir"/></td><td>Close directory handle</td></tr>
<tr><td><link id="Glob"/></td><td>Return files matching a search expression</td></tr>
<tr><td><link id="GlobFree"/></td><td>Free result of Glob</td></tr>
<tr><td><link id="OpenDir"/></td><td>Open directory for reading</td></tr>
<tr><td><link id="ReadDir"/></td><td>Read directory entry</td></tr>
<tr><td><link id="SeekDir"/></td><td>Seek directory</td></tr>
<tr><td><link id="TellDir"/></td><td>Seek directory</td></tr>
</table>
</descr>
</topic>

<topic name="ProcessRoutines">
<short>Process handling</short>
<descr>
<p>
Functions for managing processes and programs.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Clone"/></td><td>Create a thread</td></tr>
<tr><td><link id="Execl"/></td><td>Execute process with command-line list</td></tr>
<tr><td><link id="Execle"/></td><td>Execute process with command-line list and environment</td></tr>
<tr><td><link id="Execlp"/></td><td>Search in path and execute process with command list</td></tr>
<tr><td><link id="Execv"/></td><td>Execute process</td></tr>
<tr><td><link id="Execve"/></td><td>Execute process with environment</td></tr>
<tr><td><link id="Execvp"/></td><td>Search in path and execute process</td></tr>
<tr><td><link id="Fork"/></td><td>Spawn child process</td></tr>
<tr><td><link id="GetEGid"/></td><td>Get effective group id</td></tr>
<tr><td><link id="GetEnv"/></td><td>Get environment variable</td></tr>
<tr><td><link id="GetEUid"/></td><td>Get effective user id</td></tr>
<tr><td><link id="GetGid"/></td><td>Get group id</td></tr>
<tr><td><link id="GetPid"/></td><td>Get process id</td></tr>
<tr><td><link id="GetPPid"/></td><td>Get parent process id</td></tr>
<tr><td><link id="GetPriority"/></td><td>Get process priority</td></tr>
<tr><td><link id="GetUid"/></td><td>Get user id</td></tr>
<tr><td><link id="Nice"/></td><td>Change priority of process</td></tr>
<tr><td><link id="SetPriority"/></td><td>Change priority of process</td></tr>
<tr><td><link id="Shell"/></td><td>Execute shell command</td></tr>
<tr><td><link id="WaitPid"/></td><td>Wait for child process to terminate</td></tr>
</table>
</descr>
</topic>

<topic name="SignalRoutines">
<short>Signals</short>
<descr>
<p>
Functions for managing and responding to signals.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Alarm"/></td><td>Send alarm signal to self</td></tr>
<tr><td><link id="Kill"/></td><td>Send arbitrary signal to process</td></tr>
<tr><td><link id="pause"/></td><td>Wait for signal to arrive</td></tr>
<tr><td><link id="SigAction"/></td><td>Set signal action</td></tr>
<tr><td><link id="Signal"/></td><td>Set signal action</td></tr>
<tr><td><link id="SigPending"/></td><td>See if signals are waiting</td></tr>
<tr><td><link id="SigProcMask"/></td><td>Set signal processing mask</td></tr>
<tr><td><link id="SigRaise"/></td><td>Send signal to self</td></tr>
<tr><td><link id="SigSuspend"/></td><td>Sets signal mask and waits for signal</td></tr>
<tr><td><link id="NanoSleep"/></td><td>Waits for a specific amount of time</td></tr>
</table>
</descr>
</topic>

<topic name="SysInfoRoutines">
<short>System information</short>
<descr>
<p>
Functions for retrieving system information such as date and time.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="GetDate"/></td><td>Return system date</td></tr>
<tr><td><link id="GetDateTime"/></td><td>Return system date and time</td></tr>
<tr><td><link id="GetDomainName"/></td><td>Return system domain name</td></tr>
<tr><td><link id="GetEpochTime"/></td><td>Return epoch time</td></tr>
<tr><td><link id="GetHostName"/></td><td>Return system host name</td></tr>
<tr><td><link id="GetLocalTimezone"/></td><td>Return system timezone</td></tr>
<tr><td><link id="GetTime"/></td><td>Return system time</td></tr>
<tr><td><link id="GetTimeOfDay"/></td><td>Return system time</td></tr>
<tr><td><link id="GetTimezoneFile"/></td><td>Return name of timezone file</td></tr>
<tr><td><link id="ReadTimezoneFile"/></td><td>Read timezone file contents</td></tr>
<tr><td><link id="SysInfo"/></td><td>Return general system information</td></tr>
<tr><td><link id="Uname"/></td><td>Return system information</td></tr>
</table>
</descr>
</topic>

<topic name="TerminalRoutines">
<short>Terminal functions</short>
<descr>
<p>
Functions for controlling the terminal to which the process is connected.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="CFMakeRaw"/></td><td>Set terminal to raw mode</td></tr>
<tr><td><link id="CFSetISpeed"/></td><td>Set terminal reading speed</td></tr>
<tr><td><link id="CFSetOSpeed"/></td><td>Set terminal writing speed</td></tr>
<tr><td><link id="IOCtl"/></td><td>General IO control call</td></tr>
<tr><td><link id="IsATTY"/></td><td>See if filedescriptor is a terminal</td></tr>
<tr><td><link id="TCDrain"/></td><td>Wait till all output was written</td></tr>
<tr><td><link id="TCFlow"/></td><td>Suspend transmission or receipt of data</td></tr>
<tr><td><link id="TCFlush"/></td><td>Discard data written to terminal</td></tr>
<tr><td><link id="TCGetAttr"/></td><td>Get terminal attributes</td></tr>
<tr><td><link id="TCGetPGrp"/></td><td>Return PID of foreground process</td></tr>
<tr><td><link id="TCSendBreak"/></td><td>Send data for specific time</td></tr>
<tr><td><link id="TCSetAttr"/></td><td>Set terminal attributes</td></tr>
<tr><td><link id="TCSetPGrp"/></td><td>Set foreground process</td></tr>
<tr><td><link id="TTYName"/></td><td>Name of tty file</td></tr>
</table>
</descr>
</topic>


<topic name="AuxiliaryRoutines">
<short>Utility routines</short>
<descr>
<p>
Auxiliary functions that are useful in connection with the other functions.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="CreateShellArgV"/></td><td>Create an array of pchars from string</td></tr>
<tr><td><link id="EpochToLocal"/></td><td>Convert epoch time to local time</td></tr>
<tr><td><link id="FD_Clr"/></td><td>Clear item of select filedescriptors</td></tr>
<tr><td><link id="FD_IsSet"/></td><td>Check item of select filedescriptors</td></tr>
<tr><td><link id="FD_Set"/></td><td>Set item of select filedescriptors</td></tr>
<tr><td><link id="FD_ZERO"/></td><td>Clear all items in select filedecriptors</td></tr>
<tr><td><link id="LocalToEpoch"/></td><td>Convert local time to epoch time</td></tr>
<tr><td><link id="MMap"/></td><td>Map a file into memory</td></tr>
<tr><td><link id="MUnMap"/></td><td>Unmap previously mapped memory file</td></tr>
<tr><td><link id="Octal"/></td><td>Convert octal to digital</td></tr>
<tr><td><link id="S_ISBLK"/></td><td>Check file mode for block device</td></tr>
<tr><td><link id="S_ISCHR"/></td><td>Check file mode for character device</td></tr>
<tr><td><link id="S_ISDIR"/></td><td>Check file mode for directory</td></tr>
<tr><td><link id="S_ISFIFO"/></td><td>Check file mode for FIFO</td></tr>
<tr><td><link id="S_ISLNK"/></td><td>Check file mode for symboloc link</td></tr>
<tr><td><link id="S_ISREG"/></td><td>Check file mode for regular file</td></tr>
<tr><td><link id="S_ISSOCK"/></td><td>Check file mode for socket</td></tr>
<tr><td><link id="StringToPPchar"/></td><td>Create an array of pchars from string</td></tr>
</table>
</descr>
</topic>

<element name="Access">
<short>Check file access</short>
<descr>
<p>
<var>Access</var> tests user's access rights on the specified file. 
<var>Mode</var> is a mask existing of one or more of the following:
</p>
<dl>
<dt>R_OK</dt><dd>User has read rights.</dd>
<dt>W_OK</dt><dd>User has write rights.</dd>
<dt>X_OK</dt><dd>User has execute rights.</dd>
<dt>F_OK</dt><dd>File exists.</dd>
</dl>
<p>
The test is done with the real user ID, instead of the effective user ID.
If access is denied, or an error occurred, <var>False</var> is returned.
</p>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors:
</p>
<dl>
<dt>sys_eaccess</dt>
<dd>The requested access is denied, either to the file or one
of the directories in its path.</dd>
<dt>sys_einval</dt>
<dd><var>Mode</var> was incorrect.</dd>
<dt>sys_enoent</dt>
<dd>A directory component in <var>Path</var> doesn't exist or is a
dangling symbolic link.</dd>
<dt>sys_enotdir</dt>
<dd>A directory component in <var>Path</var> is not a directory.</dd>
<dt>sys_enomem</dt>
<dd>Insufficient kernel memory.</dd>
<dt>sys_eloop</dt>
<dd><var>Path</var> has a circular symbolic link.</dd>
</dl>
</errors>
<seealso>
<link id="Chown"/>
<link id="Chmod"/>
</seealso>
<example file="olinuxex/ex26"/>
</element>

<element name="Alarm">
<short>Schedule an alarm signal to be delivered</short>
<descr>
<p>
<var>Alarm</var> schedules an alarm signal to be delivered to your process in <var>Sec</var>
seconds. When <var>Sec</var> seconds have elapsed, Linux will send a <var>SIGALRM</var>
signal to the current process.  If <var>Sec</var> is zero, then no new alarm will
be set. Whatever the value of <var>Sec</var>, any previous alarm is cancelled.
</p>
<p>
The function returns the number of seconds till the previously scheduled
alarm was due to be delivered, or zero if there was none.
</p>
</descr>
<seealso>
<link id="SigAction"/>
</seealso>
<example file="olinuxex/ex59"/>
</element>

<element name="AssignPipe">
<short>Create a set of pipe file handlers</short>
<descr>
<p>
<var>AssignePipe</var> creates a pipe, i.e. two file objects, one for input,
one for output. What is written to <var>Pipe_out</var>, can be read from
<var>Pipe_in</var>.
</p>
<p>
This call is overloaded. The in and out pipe can take three forms:
an typed or untyped file, a text file or a file descriptor.
</p>
<p>
If a text file is passed then reading and writing from/to the pipe
can be done through the usual <var>Readln(Pipe_in,...)</var> and
<var>Writeln(Pipe_out,...)</var> procedures.
</p>
<p>
The function returns <var>True</var> if everything went succesfully,
<var>False</var> otherwise.
</p>
</descr>
<errors>
<p>
In case the function fails and returns <var>False</var>, <var>LinuxError</var>
is used to report errors:
</p>
<dl>
<dt>sys_emfile</dt>
<dd>Too many file descriptors for this process.</dd>
<dt>sys_enfile</dt>
<dd>The system file table is full.</dd>
</dl>
</errors>
<seealso>
<link id="POpen"/>
<link id="MkFifo"/>
</seealso>
<example file="olinuxex/ex36"/>
</element>

<element name="AssignStream">
<short>Assign stream for in and output to a program</short>
<descr>
<p>
<var>AssignStream</var> creates a 2 or 3 pipes, i.e. two (or three) file objects, one for 
input, one for output,(and one for standard error) the other ends of these 
pipes are connected to standard input and output (and standard error) of 
<var>Prog</var>. <var>Prog</var> is the name of a program (including path) with options,
 which will be executed.
</p>
<p>
What is written to <var>StreamOut</var>, will go to the standard input of
<var>Prog</var>. Whatever is written by <var>Prog</var> to it's standard output 
can be read from <var>StreamIn</var>. 
Whatever is written by <var>Prog</var> to it's standard error read from 
<var>StreamErr</var>, if present. 
</p>
<p>
Reading and writing happens through the usual <var>Readln(StreamIn,...)</var> and
<var>Writeln (StreamOut,...)</var> procedures.
</p>
<remark>
You should <em>not</em> use <var>Reset</var> or <var>Rewrite</var> on a 
file opened with <var>POpen</var>. This will close the file before re-opening 
it again, thereby closing the connection with the program.
</remark>
<p>
The function returns the process ID of the spawned process, or -1 in case of
error.
</p>
</descr>
<errors>
<p>
In case of error (return value -1) <var>LinuxError</var> is used to report 
errors:
</p>
<dl>
<dt>sys_emfile</dt>
<dd>Too many file descriptors for this process.</dd>
<dt>sys_enfile</dt>
<dd>The system file table is full.</dd>
</dl>
<p>
Other errors include the ones by the fork and exec programs
</p>
</errors>
<seealso>
<link id="AssignPipe"/>
<link id="POpen"/>
</seealso>
<example file="olinuxex/ex38"/>
</element>


<element name="BaseName">
<short>Return basename of a file</short>
<descr>
<p>
Returns the filename part of <var>Path</var>, stripping off <var>Suf</var> if it
exists.
The filename part is the whole name if <var>Path</var> contains no slash,
or the part of <var>Path</var> after the last slash.
The last character of the result is not a slash, unless the directory is the
root directory.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DirName"/>
<link id="FExpand"/>
</seealso>
<example file="olinuxex/ex48"/>
</element>


<element name="CFMakeRaw">
<short>Sets flags in <link id="Termios"/> record.</short>
<descr>
<p>
<var>CFMakeRaw</var>
sets the flags in the <var>Termios</var> structure <var>Tios</var> to a state so that 
 the terminal will function in Raw Mode.
</p>
<p>
For an example, see <link id="TCGetAttr"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CFSetOSpeed"/>
<link id="CFSetISpeed"/>
</seealso>
</element>

<element name="CFSetISpeed">
<short>Set input baud rate in <link id="Termios"/> record</short>
<descr>
<var>CFSetISpeed</var>
Sets the input baudrate in the <var>TermIOS</var> structure <var>Tios</var> to 
<var>Speed</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CFSetOSpeed"/>
<link id="CFMakeRaw"/>
</seealso>
</element>

<element name="CFSetOSpeed">
<short>Set output baud rate in <link id="Termios"/> record</short>
<descr>
<var>CFSetOSpeed</var>
Sets the output baudrate in the <var>Termios</var> structure <var>Tios</var> to
<var>Speed</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CFSetISpeed"/>
<link id="CFMakeRaw"/>
</seealso>
</element>

<element name="Chown">
<short>Change owner of file</short>
<descr>
<var>Chown</var> sets the User ID and Group ID of the file in <var>Path</var> to
<var>NewUid</var>, <var>NewGid</var>
The function returns <var>True</var> if the call was succesfull, <var>False</var> if the call
failed.
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_eperm</dt>
<dd>The effective UID doesn't match the ownership of the file,
and is not zero. Owner or group were not specified correctly.</dd>
<dt>sys_eaccess</dt>
<dd>One of the directories in <var>Path</var> has no
search (=execute) permission.</dd>
<dt>sys_enoent</dt>
<dd>A directory entry in <var>Path</var> does
not exist or is a symbolic link pointing to a non-existent directory.</dd>
<dt>sys_enomem</dt>
<dd>Insufficient kernel memory.</dd>
<dt>sys_erofs</dt>
<dd>The file is on a read-only filesystem.</dd>
<dt>sys_eloop</dt>
<dd><var>Path</var> has a reference to a circular
symbolic link, i.e. a symbolic link, whose expansion points to itself.</dd>
</dl>
</errors>
<seealso>
<link id="Chmod"/>
<link id="Access"/>
</seealso>
<example file="olinuxex/ex24"/>
</element>


<element name="Chmod">
<short>Change file permission bits</short>
<descr>
<p>
<var>Chmod</var>
Sets the Mode bits of the file in <var>Path</var> to <var>NewMode</var>. Newmode can be
specified by 'or'-ing the following:
</p>
<dl>
<dt>S_ISUID</dt><dd>Set user ID on execution.</dd>
<dt>S_ISGID</dt><dd>Set Group ID on execution.</dd>
<dt>S_ISVTX</dt><dd>Set sticky bit.</dd>
<dt>S_IRUSR</dt><dd>Read by owner.</dd>
<dt>S_IWUSR</dt><dd>Write by owner.</dd>
<dt>S_IXUSR</dt><dd>Execute by owner.</dd>
<dt>S_IRGRP</dt><dd>Read by group.</dd>
<dt>S_IWGRP</dt><dd>Write by group.</dd>
<dt>S_IXGRP</dt><dd>Execute by group.</dd>
<dt>S_IROTH</dt><dd>Read by others.</dd>
<dt>S_IWOTH</dt><dd>Write by others.</dd>
<dt>S_IXOTH</dt><dd>Execute by others.</dd>
<dt>S_IRWXO</dt><dd>Read, write, execute by others.</dd>
<dt>S_IRWXG</dt><dd>Read, write, execute by groups.</dd>
<dt>S_IRWXU</dt><dd>Read, write, execute by user.</dd>
</dl>
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_eperm</dt>
<dd>The effective UID doesn't match the ownership of the file,
and is not zero. Owner or group were not specified correctly.</dd>
<dt>sys_eaccess</dt>
<dd>One of the directories in <var>Path</var> has no
search (=execute) permission.</dd>
<dt>sys_enoent</dt>
<dd>A directory entry in <var>Path</var> does
not exist or is a symbolic link pointing to a non-existent directory.</dd>
<dt>sys_enomem</dt>
<dd>Insufficient kernel memory.</dd>
<dt>sys_erofs</dt>
<dd>The file is on a read-only filesystem.</dd>
<dt>sys_eloop</dt>
<dd><var>Path</var> has a reference to a circular
symbolic link, i.e. a symbolic link, whose expansion points to itself.</dd>
</dl>
</errors>
<seealso>
<link id="Chown"/>
<link id="Access"/>
<link id="Octal"/>
</seealso>
<example file="olinuxex/ex23"/>
</element>

<element name="Clone">
<short>Clone current process (create new thread)</short>
<descr>
<p>
<var>Clone</var>
creates a child process which is a copy of the parent process, just
like <link id="Fork"/> does. In difference with <var>Fork</var>, however, the child
process shares some parts of it's execution context with its parent, so it
is suitable for the implementation of threads: many instances of a program
that share the same memory.
</p>
<p>
When the child process is created, it starts executing the function
<var>Func</var>, and passes it <var>Args</var>. The return value of <var>Func</var> is 
either the explicit return value of the function, or the exit code of
the child process.
</p>
<p>
The <var>sp</var> pointer points to the memory reserved as stack space for the
child process. This address should be the top of the memory block to be used
as stack.
</p>
<p>
The <var>Flags</var> determine the behaviour of the <var>Clone</var> call. The low
byte of the Flags contains the number of the signal that will be  sent to 
the parent when  the child dies. 
This may be bitwise OR'ed with the following constants:
</p>
<dl>
<dt>CLONE_VM</dt>
<dd>Parent and child share the same memory space, including
memory (un)mapped with subsequent <var>mmap</var> calls.</dd>
<dt>CLONE_FS</dt>
<dd>Parent and child have the same view of the filesystem;
the <var>chroot</var>, <var>chdir</var> and <var>umask</var> calls affect both processes.</dd>
<dt>CLONE_FILES</dt>
<dd>the file descriptor table of parent and child is shared.</dd>
<dt>CLONE_SIGHAND</dt>
<dd>the parent and child share the same table of signal
handlers. The signal masks are different, though.</dd>
<dt>CLONE_PID</dt>
<dd>PArent and child have the same process ID.</dd>
</dl>
<p>
Clone returns the process ID in the parent process, and -1 if an error
occurred.
</p>
</descr>
<errors>
<p>
On error, -1 is returned to the parent, and no child is created.
</p>
<dl>
<dt>sys_eagain</dt><dd>Too many processes are running.</dd>
<dt>sys_enomem</dt><dd>Not enough memory to create child process.</dd>
</dl>
</errors>
<seealso>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex71"/>
</element>


<element name="CloseDir">
<short>Close directory file descriptor</short>
<descr>
<p>
<var>CloseDir</var> closes the directory pointed to by <var>p</var>.
It returns zero if the directory was closed succesfully, -1 otherwise.
</p>
<p>
For an example, see <link id="OpenDir"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="OpenDir"/>
<link id="ReadDir"/>
<link id="SeekDir"/>
<link id="TellDir"/>
</seealso>
</element>

<element name="CreateShellArgV">
<short>Create an array of null-terminated strings</short>
<descr>
<p>
<var>CreateShellArgV</var> creates an array of 3 <var>PChar</var> pointers that can
be used as arguments to <var>ExecVE</var> the first elements in the array 
will contain  <var>/bin/sh</var>, the second will contain <var>-c</var>, and the third
will contain <var>prog</var>.
</p>
<p>
The function returns a pointer to this array, of type <var>PPChar</var>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Shell"/>
</seealso>
<example file="olinuxex/ex61"/>
</element>


<element name="DirName">
<short>Extract directory part from filename</short>
<descr>
<p>
Returns the directory part of <var>Path</var>.
The directory is the part of <var>Path</var> before the last slash,
or empty if there is no slash.
The last character of the result is not a slash, unless the directory is the
root directory.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="BaseName"/>
<link id="FExpand"/>
</seealso>
<example file="olinuxex/ex47"/>
</element>



<element name="Dup">
<short>Duplicate a file handle</short>
<descr>
<p>
Makes <var>NewFile</var> an exact copy of <var>OldFile</var>, after having flushed the
buffer of <var>OldFile</var> in case it is a Text file or untyped file. 
Due to the buffering mechanism of Pascal, this has not the same functionality
as the dup call in C. The internal Pascal buffers are not the same 
after this call, but when the buffers are flushed (e.g. after output), 
the output is sent to the same file.
Doing an lseek will, however, work as in C, i.e. doing a lseek will change 
the fileposition in both files.
</p>
<p>
The function returns <var>False</var> in case of an error, <var>True</var> if
successful.
</p>
</descr>
<errors>
<p>
In case of errors, <var>Linuxerror</var> is used to report errors.
</p>
<dl>
<dt>sys_ebadf</dt><dd><var>OldFile</var> hasn't been assigned.</dd>
<dt>sys_emfile</dt><dd>Maximum number of open files for the process is reached.</dd>
</dl>
</errors>
<seealso>
<link id="Dup2"/>
</seealso>
<example file="olinuxex/ex31"/>
</element>




<element name="Dup2">
<short>Duplicate one filehandle to another</short>
<descr>
<p>
Makes <var>NewFile</var> an exact copy of <var>OldFile</var>, after having flushed the
buffer of <var>OldFile</var> in the case of text or untyped files. 
</p>
<p>
<var>NewFile</var> can be an assigned file. If <var>newfile</var> was open, it is 
closed first. Due to the buffering mechanism of Pascal, this has not
the same functionality as the <var>dup2</var> call in C. The internal Pascal
buffers are not the same after this call, but when the buffers are flushed
(e.g. after output), the output is sent to the same file.
Doing an lseek will, however, work as in C, i.e. doing a lseek will change the
fileposition in both files.
</p>
<p>
The function returns <var>True</var> if succesful, false otherwise.
</p>
</descr>
<errors>
<p>
In case of error, <var>Linuxerror</var> is used to report errors.
</p>
<dl>
<dt>sys_ebadf</dt><dd><var>OldFile</var> hasn't been assigned.</dd>
<dt>sys_emfile</dt><dd>Maximum number of open files for the process is reached.</dd>
</dl>
</errors>
<seealso>
<link id="Dup"/>
</seealso>
<example file="olinuxex/ex32"/>
</element>


<element name="EpochToLocal">
<short>Convert epoch time to local time</short>
<descr>
<p>
Converts the epoch time (=Number of seconds since 00:00:00 , January 1,
1970, corrected for your time zone ) to local date and time.
</p>
<p>
This function takes into account the timzeone settings of your system.
</p>
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="LocalToEpoch"/>
<link id="GetTime"/>
<link id="GetDate"/> 
</seealso>
<example file="olinuxex/ex3"/>
</element>


<element name="Execl">
<short>Execute process (using argument list)</short>
<descr>
Replaces the currently running program with the program, specified in
<var>path</var>. Path is split into a command and it's options.
The executable in <var>path</var> is NOT searched in the path.
The current environment is passed to the program.
On success, <var>execl</var> does not return.
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt>
<dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt>
<dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execlp"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex10"/>
</element>


<element name="Execle">
<short>Execute process (using argument list, environment)</short>
<descr>
<p>
Replaces the currently running program with the program, specified in
<var>path</var>. Path is split into a command and it's options.
The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
The environment in <var>ep</var> is passed to the program.
On success, <var>execle</var> does not return.
</p>
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex11"/>
</element>

<element name="Execlp">
<short>Execute process (using argument list, environment; search path)</short>
<descr>
Replaces the currently running program with the program, specified in
<var>path</var>. Path is split into a command and it's options.
The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
The current environment is passed to the program.
On success, <var>execlp</var> does not return.
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex12"/>
</element>


<element name="Execv">
<short>Execute process</short>
<descr>
Replaces the currently running program with the program, specified in
<var>path</var>.
It gives the program the options in <var>args</var>.
This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>execv</var> does not return.
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex8"/>
</element>

<element name="Execve">
<short>Execute process using environment</short>
<descr>
Replaces the currently running program with the program, specified in
<var>path</var>.
It gives the program the options in <var>args</var>, and the environment in
<var>ep</var>. They are pointers to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
On success, <var>execve</var> does not return.
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex7"/>
</element>


<element name="Execvp">
<short>Execute process, search path</short>
<descr>
Replaces the currently running program with the program, specified in
<var>path</var>. The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
It gives the program the options in <var>args</var>. This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>execvp</var> does not return.
</descr>
<errors>
<p>
Errors are reported in <var>LinuxError</var>:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Execv"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="Fork"/>
</seealso>
<example file="olinuxex/ex9"/>
</element>



<element name="FD_ZERO">
<short>Clear all file descriptors in set</short>
<descr>
<p>
<var>FD_ZERO</var> clears all the filedescriptors in the file descriptor 
set <var>fds</var>.
</p>
<p>
For an example, see <link id="Select"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Select"/>
<link id="SelectText"/>
<link id="GetFS"/>
<link id="FD_Clr"/>
<link id="FD_Set"/>
<link id="FD_IsSet"/>
</seealso>
</element>

<element name="FD_Clr">
<short>Clears a filedescriptor in a set</short>
<descr>
<p>
<var>FD_Clr</var> clears file descriptor <var>fd</var> in filedescriptor set <var>fds</var>.
</p>
<p>
For an example, see <link id="Select"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Select"/>,
<link id="SelectText"/>
<link id="GetFS"/>
<link id="FD_ZERO"/>
<link id="FD_Set"/>
<link id="FD_IsSet"/>
</seealso>
</element>


<element name="FD_IsSet">
<short>Check whether a filedescriptor is set</short>
<descr>
<p>
<var>FD_Set</var> Checks whether file descriptor <var>fd</var> in filedescriptor set <var>fds</var>
is set.
</p>
<p>
For an example, see <link id="Select"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Select"/>
<link id="SelectText"/>
<link id="GetFS"/>
<link id="FD_ZERO"/>
<link id="FD_Clr"/>
<link id="FD_Set"/>
</seealso>
</element>


<element name="FD_Set">
<short>Set a filedescriptor in a set</short>
<descr>
<p>
<var>FD_Set</var> sets file descriptor <var>fd</var> in filedescriptor set <var>fds</var>.
</p>
<p>
For an example, see <link id="Select"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Select"/>
<link id="SelectText"/>
<link id="GetFS"/>
<link id="FD_ZERO"/> 
<link id="FD_Clr"/>
<link id="FD_IsSet"/>
</seealso>
</element>


<element name="fdClose">
<short>Close file descriptor</short>
<descr>
<p>
<var>fdClose</var> closes a file with file descriptor <var>Fd</var>. The function
returns <var>True</var> if the file was closed successfully, <var>False</var>
otherwise. 
</p>
<p>
For an example, see <link id="fdOpen"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdRead"/>
<link id="fdWrite"/>
<link id="fdTruncate"/>
<link id="fdFlush"/>
<link id="fdSeek"/>
</seealso>
</element>

<element name="fdFlush">
<short>Flush kernel file buffer</short>
<descr>
<p>
<var>fdflush</var> flushes the Linux kernel file buffer, so the file is actually
written to disk. This is NOT the same as the internal buffer, maintained by
Free Pascal. 
The function returns <var>True</var> if the call was successful, <var>false</var> if
an error occurred.
</p>
<p>
For an example, see <link id="fdRead"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdClose"/>
<link id="fdRead"/>
<link id="fdWrite"/>
<link id="fdTruncate"/>
<link id="fdSeek"/>
</seealso>
</element>

<element name="fdOpen">
<short>Open file and return file descriptor</short>
<descr>
<p>
<var>fdOpen</var> opens a file in <var>PathName</var> with flags <var>flags</var>
One of the following:
</p>
<dl>
<dt>Open_RdOnly</dt><dd>File is opened Read-only</dd>
<dt>Open_WrOnly</dt><dd>File is opened Write-only</dd>
<dt>Open_RdWr</dt><dd>File is opened Read-Write</dd>
</dl>
<p>
The flags may be<var>OR</var>-ed with one of the following constants:
</p>
<dl>
<dt>Open_Creat</dt><dd>File is created if it doesn't exist.</dd>
<dt>Open_Excl</dt><dd>If the file is opened with <var>Open_Creat</var> and it
already exists, the call wil fail.</dd>
<dt>Open_NoCtty</dt><dd>If the file is a terminal device, it will NOT become
the process' controlling terminal.</dd>
<dt>Open_Trunc</dt><dd>If the file exists, it will be truncated.</dd>
<dt>Open_Append</dt><dd>the file is opened in append mode. <em>Before each
write</em>, the file pointer is positioned at the end of the file.</dd>
<dt>Open_NonBlock</dt><dd>The file is opened in non-blocking mode. No operation
on the file descriptor will cause the calling process to wait till.</dd>
<dt>Open_NDelay</dt><dd>Idem as <var>Open_NonBlock</var></dd>
<dt>Open_Sync</dt><dd>The file is opened for synchronous IO. Any write
operation on the file will not return untill the data is physically written
to disk.</dd>
<dt>Open_NoFollow</dt><dd>if the file is a symbolic link, the open fails.
(Linux 2.1.126 and higher only)</dd>
<dt>Open_Directory</dt><dd>if the file is not a directory, the open fails.
(Linux 2.1.126 and higher only)</dd>
</dl>
<p>
<var>PathName</var> can be of type <var>PChar</var> or <var>String</var>.
The optional <var>mode</var> argument specifies the permissions to set when opening
the file. This is modified by the umask setting. The real permissions are
<var>Mode and not umask</var>.
The return value of the function is the filedescriptor, or a negative
value if there was an error.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdClose"/>
<link id="fdRead"/>
<link id="fdWrite"/>
<link id="fdTruncate"/>
<link id="fdFlush"/>
<link id="fdSeek"/>
</seealso>
<example file="olinuxex/ex19"/>
</element>


<element name="fdRead">
<short>Read data from file descriptor</short>
<descr>
<p>
<var>fdRead</var> reads at most <var>size</var> bytes from the file descriptor
<var>fd</var>, and stores them in <var>buf</var>. 
The function returns the number of bytes actually read, or -1 if
an error occurred.
No checking on the length of <var>buf</var> is done.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdClose"/>
<link id="fdWrite"/>
<link id="fdTruncate"/>
<link id="fdFlush"/>
<link id="fdSeek"/>
</seealso>
<example file="olinuxex/ex20"/>
</element>


<element name="fdSeek">
<short>Set file pointer position.</short>
<descr>
<p>
<var>fdSeek</var> sets the current fileposition of file <var>fd</var> to
<var>Pos</var>, starting from <var>SeekType</var>, which can be one of the following:
</p>
<dl>
<dt>Seek_Set</dt><dd><var>Pos</var> is the absolute position in the file.</dd>
<dt>Seek_Cur</dt><dd><var>Pos</var> is relative to the current position.</dd>
<dt>Seek_end</dt><dd><var>Pos</var> is relative to the end of the file.</dd>
</dl>
<p>
The function returns the new fileposition, or -1 of an error occurred.
</p>
<p>
For an example, see <link id="fdOpen"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdWrite"/>
<link id="fdClose"/>
<link id="fdRead"/>
<link id="fdTruncate"/>
<link id="fdFlush"/>
</seealso>
</element>

<element name="fdTruncate">
<short>Truncate file on certain size.</short>
<descr>
<var>fdTruncate</var> sets the length of a file in <var>fd</var> on <var>size</var>
bytes, where <var>size</var> must be less than or equal to the current length of
the file in <var>fd</var>.
The function returns <var>True</var> if the call was successful, <var>false</var> if
an error occurred.
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdClose"/>
<link id="fdRead"/>
<link id="fdWrite"/>
<link id="fdFlush"/>
<link id="fdSeek"/>
</seealso>
</element>

<element name="fdWrite">
<short>Write data to file descriptor</short>
<descr>
<p>
<var>fdWrite</var> writes at most <var>size</var> bytes from <var>buf</var> to
file descriptor <var>fd</var>.
The function returns the number of bytes actually written, or -1 if an error
occurred.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="fdOpen"/>
<link id="fdClose"/>
<link id="fdRead"/>
<link id="fdTruncate"/>
<link id="fdSeek"/>
<link id="fdFlush"/>
</seealso>
</element>

<element name="FExpand">
<short>Expand filename to fully qualified path</short>
<descr>
<var>FExpand</var> expands <var>Path</var> to a full path, starting from root,
eliminating directory references such as . and .. from the result.
</descr>
<errors>
None
</errors>
<seealso>
<link id="BaseName"/>
<link id="DirName"/> 
</seealso>
<example file="olinuxex/ex45"/>
</element>


<element name="FLock">
<short>Lock a file (advisory lock)</short>
<descr>
<p>
<var>FLock</var> implements file locking. it sets or removes a lock on the file
<var>F</var>. F can be of type <var>Text</var> or <var>File</var>, or it can be a Linux
filedescriptor (a longint)
<var>Mode</var> can be one of the following constants :
</p>
<dl>
<dt>LOCK_SH</dt><dd>sets a shared lock.</dd>
<dt>LOCK_EX</dt><dd>sets an exclusive lock.</dd>
<dt>LOCK_UN</dt><dd>unlocks the file.</dd>
<dt>LOCK_NB</dt><dd>This can be OR-ed together with the other.
If this is done the application doesn't block when locking.
</dd>
</dl>
<p>
The function returns <var>True</var> if successful, <var>False</var> otherwise.
</p>
</descr>
<errors>
If an error occurs, it is reported in <var>LinuxError</var>.
</errors>
<seealso>
<link id="Fcntl"/>
</seealso>
</element>

<element name="FNMatch">
<short>Check whether filename matches wildcard specification</short>
<descr>
<p>
<var>FNMatch</var> returns <var>True</var> if the filename in <var>Name</var>
matches the wildcard pattern in <var>Pattern</var>, <var>False</var> otherwise.
</p>
<p>
<var>Pattern</var> can contain the wildcards <var>*</var> (match zero or more 
arbitrary characters) or <var>?</var> (match a single character).
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="FSearch"/>
<link id="FExpand"/>
</seealso>
<example file="olinuxex/ex69"/>
</element>


<element name="FSearch">
<short>Search for file in search path.</short>
<descr>
<var>FSearch</var> searches in <var>DirList</var>, a colon separated list of directories,
for a file named <var>Path</var>. It then returns a path to the found file.
</descr>
<errors>
An empty string if no such file was found.
</errors>
<seealso>
<link id="BaseName"/>
<link id="DirName"/>
<link id="FExpand"/>
<link id="FNMatch"/>
</seealso>
<example file="olinuxex/ex46"/>
</element>


<element name="FSplit">
<short>Split filename into path, name and extension</short>
<descr>
<var>FSplit</var> splits a full file name into 3 parts : A <var>Path</var>, a
<var>Name</var> and an extension  (in <var>ext</var>).
The extension is taken to be all letters after the last dot (.).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="FSearch"/>
</seealso>
<example file="olinuxex/ex67"/>
</element>

<element name="FSStat">
<short>Retrieve filesystem information.</short>
<descr>
<var>FSStat</var> returns in <var>Info</var> information about the filesystem on which the file
<var>Path</var> resides, or on which the file with file descriptor <var>fd</var>
resides.
Info is of type <var>statfs</var>. The function returns <var>True</var> if the call
was succesfull, <var>False</var> if the call failed.
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_enotdir</dt><dd>A component of <var>Path</var> is not a directory.</dd>
<dt>sys_einval</dt><dd>Invalid character in <var>Path</var>.</dd>
<dt>sys_enoent</dt><dd><var>Path</var> does not exist.</dd>
<dt>sys_eaccess</dt><dd>Search permission is denied for  component in<var>Path</var>.</dd>
<dt>sys_eloop</dt><dd>A circular symbolic link was encountered in <var>Path</var>.</dd>
<dt>sys_eio</dt><dd>An error occurred while reading from the filesystem.</dd>
</dl>
</errors>
<seealso>
<link id="FStat"/>
<link id="LStat"/>
</seealso>
<example file="olinuxex/ex30"/>
</element>


<element name="FStat">
<short>Retrieve information about a file</short>
<descr>
<p>
<var>FStat</var> gets information about the file specified in one of the
following:
</p>
<dl>
<dt>Path</dt><dd>a file on the filesystem.</dd>
<dt>Fd</dt><dd>a valid file descriptor.</dd>
<dt>F</dt><dd>an opened text file or untyped file.</dd>
</dl>
<p>
and stores it in  <var>Info</var>, which is of type <var>stat</var>.
The function returns <var>True</var> if the call was succesfull,
<var>False</var> if the call failed.
</p>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_enoent</dt><dd><var>Path</var> does not exist.</dd>
</dl>
</errors>
<seealso>
<link id="FSStat"/>
<link id="LStat"/>
</seealso>
<example file="olinuxex/ex28"/>
</element>


<element name="Fcntl">
<short>File control operations.</short>
<descr>
<p>
Read a file's attributes. <var>Fd</var> is an assigned file, or a valid file
descriptor.
<var>Cmd</var> speciefies what to do, and is one of the following:
</p>
<dl>
<dt>F_GetFd</dt>
<dd>Read the close_on_exec flag. If the low-order bit is 0, then
the file will remain open across execve calls.</dd>
<dt>F_GetFl</dt><dd>Read the descriptor's flags.</dd>
<dt>F_GetOwn</dt><dd>Get the Process ID of the owner of a socket.</dd>
<dt>F_SetFd</dt>
<dd>Set the close_on_exec flag of <var>Fd</var>. (only the least
siginificant bit is used).
</dd>
<dt>F_GetLk</dt>
<dd>Return the <var>flock</var> record that prevents this process from
obtaining the lock, or set the <var>l_type</var> field of the lock of there is no
obstruction. Arg is a pointer to a flock record.
</dd>
<dt>F_SetLk</dt>
<dd>Set the lock or clear it (depending on <var>l_type</var> in the
<var>flock</var> structure). if the lock is held by another process, an error
occurs.
</dd>
<dt>F_GetLkw</dt>
<dd>Same as for <b>F_Setlk</b>, but wait until the lock is
released.
</dd>
<dt>F_SetOwn</dt>
<dd>Set the Process or process group that owns a socket.
</dd>
</dl>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_ebadf</dt><dd><var>Fd</var> has a bad file descriptor.</dd>
<dt>sys_eagain or sys_eaccess</dt><dd>For <b>F_SetLk</b>, if the lock is
held by another process.</dd>
</dl>
</errors>
</element>

<element name="Fork">
<short>Create child process</short>
<descr>
<var>Fork</var> creates a child process which is a copy of the parent process.
<var>Fork</var> returns the process ID in the parent process, and zero in the child's
process. (you can get the parent's PID with <link id="GetPPid"/>).
</descr>
<errors>
<p>
On error, -1 is returned to the parent, and no child is created.
</p>
<dl>
<dt>sys_eagain</dt><dd>Not enough memory to create child process.
</dd>
</dl>
</errors>
<seealso>
<link id="Execve"/>
<link id="Clone"/>
</seealso>
</element>

<element name="FRename">
<short>Rename file</short>
<descr>
<p>
<var>FRename</var> renames the file <var>OldName</var> to <var>NewName</var>. <var>NewName</var>
can be in a different directory than <var>OldName</var>, but it cannot be on
another partition (device). Any existing file on the new location will be replaced.
</p>
<p>
If the operation fails, then the <var>OldName</var> file will be preserved. 
</p>
<p>
The function returns <var>True</var> on succes, <var>False</var> on failure.
</p>
</descr>
<errors>
<p>
On error, errors are reported in <var>LinuxError</var>. Possible errors include:
</p>
<dl>
<dt>sys_eisdir</dt>
<dd><var>NewName</var> exists and is a directory, but <var>OldName</var> is not a directory.</dd>
<dt>sys_exdev</dt>
<dd><var>NewName</var> and <var>OldName</var> are on different devices.</dd>
<dt>sys_enotempty or sys_eexist</dt>
<dd><var>NewName</var> is an existing, non-empty directory.</dd>
<dt>sys_ebusy</dt>
<dd><var>OldName</var> or <var>NewName</var> is a directory and is in use by another process.</dd>
<dt>sys_einval</dt>
<dd><var>NewName</var> is part of <var>OldName</var>.</dd>
<dt>sys_emlink</dt>
<dd><var>OldPath</var> or <var>NewPath</var> already have tha maximum
amount of links pointing to them.</dd>
<dt>sys_enotdir</dt>
<dd>part of <var>OldName</var> or <var>NewName</var> is not directory.</dd>
<dt>sys_efault</dt>
<dd>For the <var>pchar</var> case: One of the pointers points to
an invalid address.</dd>
<dt>sys_eaccess</dt>
<dd>access is denied when attempting to move the file.</dd>
<dt>sys_enametoolong</dt>
<dd>Either <var>OldName</var> or <var>NewName</var> is too long.</dd>
<dt>sys_enoent</dt>
<dd>a directory component in <var>OldName</var> or <var>NewName</var>
didn't exist.</dd>
<dt>sys_enomem</dt>
<dd>not enough kernel memory.</dd>
<dt>sys_erofs</dt>
<dd><var>NewName</var> or <var>OldName</var> is on a read-only file system.</dd>
<dt>sys_eloop</dt>
<dd>too many symbolic links were encountered trying to expand
<var>OldName</var> or <var>NewName</var></dd>
<dt>sys_enospc</dt>
<dd>the filesystem has no room for the new directory entry.</dd>
</dl>
</errors>
<seealso>
<link id="UnLink"/>
</seealso>
</element>


<element name="GetDate">
<short>Return the system date</short>
<descr>
Returns the current date.
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="GetTime"/>
<link id="GetDateTime"/>
<link id="EpochToLocal"/> 
</seealso>
<example file="olinuxex/ex6"/>
</element>


<element name="GetDateTime">
<short>Return system date and time</short>
<descr>
Returns the current date and time. The time is corrected for the local time
zone. This procedure is equivalent to the <link id="GetDate"/> and <var>GetTime</var>
calls.
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="GetTime"/>
<link id="EpochToLocal"/>
<link id="GetDate"/> 
</seealso>
<example file="olinuxex/ex60"/>
</element>


<element name="GetDomainName">
<short>Return current domain name</short>
<descr>
Get the domain name of the machine on which the process is running.
An empty string is returned if the domain is not set.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetHostName"/>
</seealso>
<example file="olinuxex/ex39"/>
</element>


<element name="GetEGid">
<short>Return effective group ID</short>
<descr>
Get the effective group ID of the currently running process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetGid"/>
</seealso>
<example file="olinuxex/ex18"/>
</element>

<element name="GetEUid">
<short>Return effective user ID</short>
<descr>
Get the effective user ID of the currently running process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetUid"/>
</seealso>
<example file="olinuxex/ex17"/>
</element>


<element name="GetEnv">
<short>Return value of environment variable.</short>
<descr>
<p>
<var>GetEnv</var> returns the value of the environment variable in <var>P</var>. 
If the variable is not defined, nil is returned. The value of the environment 
variable may be the empty string.
A PChar is returned to accomodate for strings longer than 255 bytes,
<var>TERMCAP</var> and <var>LS_COLORS</var>, for instance.
</p>
</descr>
<errors>
None.
</errors>
<example file="olinuxex/ex41"/>
</element>


<element name="GetEpochTime">
<short>Return the current unix time</short>
<descr>
<p>
returns the number of seconds since 00:00:00 gmt, january 1, 1970.
it is adjusted to the local time zone, but not to DST.
</p>
</descr>
<errors>
no errors
</errors>
<seealso>
<link id="EpochToLocal"/>
<link id="GetTime"/>
</seealso>
<example file="olinuxex/ex1"/>
</element>

<element name="GetFS">
<short>Return file selector</short>
<descr>
<var>GetFS</var> returns the file selector that the kernel provided for your
file. In principle you don' need this file selector. Only for some calls
it is needed, such as the <link id="Select"/> call or so.
</descr>
<errors>
In case the file was not opened, then -1 is returned.
</errors>
<seealso>
<link id="Select"/>
</seealso>
<example file="olinuxex/ex34"/>
</element>


<element name="GetGid">
<short>Return real group ID</short>
<descr>
Get the real group ID of the currently running process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetEGid"/>
</seealso>
<example file="olinuxex/ex18"/>
</element>


<element name="GetHostName">
<short>Return host name</short>
<descr>
Get the hostname of the machine on which the process is running.
An empty string is returned if hostname is not set.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetDomainName"/>
</seealso>
<example file="olinuxex/ex40"/>
</element>


<element name="GetLocalTimezone">
<short>Return local timzeone information</short>
<descr>
<p>
<var>GetLocalTimeZone</var> returns the local timezone information. It also
initializes the <var>TZSeconds</var> variable, which is used to correct the epoch time
to local time.
</p>
<p>
There should never be any need to call this function directly. It is called by the
initialization routines of the Linux unit.
</p>
</descr>
<seealso>
<link id="GetTimezoneFile"/>
<link id="ReadTimezoneFile"/>
</seealso>
</element>

<element name="GetPid">
<short>Return current process ID</short>
<descr>
Get the Process ID of the currently running process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetPPid"/>
</seealso>
<example file="olinuxex/ex16"/>
</element>


<element name="GetPPid">
<short>Return parent process ID</short>
<descr>
Get the Process ID of the parent process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetPid"/>
</seealso>
<example file="olinuxex/ex16"/>
</element>


<element name="GetPriority">
<short>Return process priority</short>
<descr>
<p>
GetPriority returns the priority with which a process is running.
Which process(es) is determined by the <var>Which</var> and <var>Who</var> variables.
<var>Which</var> can be one of the pre-defined <var>Prio_Process</var>,
<var>Prio_PGrp</var>, <var>Prio_User</var>, in which case <var>Who</var> is the process ID, Process group ID or
User ID, respectively.
</p>
<p>
For an example, see <link id="Nice"/>.
</p>
</descr>
<errors>
<p>
Error checking must be done on LinuxError, since a priority can be negative.
</p>
<dl>
<dt>sys_esrch</dt>
<dd>No process found using <var>which</var> and <var>who</var>.</dd>
<dt>sys_einval</dt>
<dd><var>Which</var> was not one of <var>Prio_Process</var>,
<var>Prio_Grp</var> or <var>Prio_User</var>.</dd>
</dl>
</errors>
<seealso>
<link id="SetPriority"/>
<link id="Nice"/>
</seealso>
</element>

<element name="GetTime">
<short>Return current system time</short>
<descr>
<p>
Returns the current time of the day, adjusted to local time.
Upon return, the parameters are filled with
</p>
<dl>
<dt>hour</dt><dd>Hours since 00:00 today.</dd>
<dt>min</dt><dd>minutes in current hour.</dd>
<dt>sec</dt><dd>seconds in current minute.</dd>
<dt>sec100</dt><dd>hundreds of seconds in current second.</dd>
<dt>msec</dt><dd>milliseconds in current second.</dd>
<dt>usec</dt><dd>microseconds in current second.</dd>
</dl>
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="GetDate"/>
<link id="GetDateTime"/>
<link id="EpochToLocal"/>
</seealso>
<example file="olinuxex/ex5"/>
</element>


<element name="GetTimeOfDay">
<short>Return kernel time of day in GMT</short>
<descr>
<p>
<var>GetTimeOfDay</var> returns the number of seconds since 00:00, January 1 
1970, GMT in a <var>timeval</var> record. This time NOT corrected any way,
not taking into account timezones, daylight savings time and so on.
</p>
<p>
It is simply a wrapper to the kernel system call. To get the local time,
<link id="GetTime"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetTime"/>
<link id="GetTimeOfDay"/>
</seealso>
</element>

<element name="GetTimezoneFile">
<short>Return name of timezone information file</short>
<descr>
<p>
<var>GetTimezoneFile</var> returns the location of the current timezone file.
The location of file is determined as follows:
</p>
<ol>
<li>If <file>/etc/timezone</file> exists, it is read, and the contents of this
file is returned. This should work on Debian systems.</li>
<li>If <file>/usr/lib/zoneinfo/localtime</file> exists, then it is returned.
(this file is a symlink to the timezone file on SuSE systems)</li>
<li>If <file>/etc/localtime</file> exists, then it is returned. 
(this file is a symlink to the timezone file on RedHat systems)</li>
</ol>
</descr>
<errors>
If no file was found, an empty string is returned.
</errors>
<seealso>
<link id="ReadTimezoneFile"/>
</seealso>
</element>

<element name="GetUid">
<short>Return current user ID</short>
<descr>
Get the real user ID of the currently running process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetEUid"/>
</seealso>
<example file="olinuxex/ex17"/>
</element>


<element name="Glob">
<short>Find filenames matching a wildcard pattern</short>
<descr>
<p
>Glob returns a pointer to a glob structure which contains all filenames which
exist and match the pattern in <var>Path</var>.
The pattern can contain wildcard characters, which have their
usual meaning.
</p>
</descr>
<errors>
<p>
Returns nil on error, and <var>LinuxError</var> is set.
</p>
<dl>
<dt>sys_enomem</dt><dd>No memory on heap for glob structure.</dd>
<dt>others</dt><dd>As returned by the opendir call, and sys_readdir.</dd>
</dl>
</errors>
<seealso>
<link id="GlobFree"/>
</seealso>
<example file="olinuxex/ex49"/>
</element>


<element name="GlobFree">
<short>Free result of <link id="Glob"/> call</short>
<descr>
<p>
Releases the memory, occupied by a pglob structure. <var>P</var> is set to nil.
</p>
<p>
For an example, see <link id="Glob"/>.
</p>
</descr>
<errors>
None
</errors>
<seealso>
<link id="Glob"/> 
</seealso>
</element>

<element name="IOCtl">
<short>General kernel IOCTL call.</short>
<descr>
This is a general interface to the Unix/ Linux ioctl call.
It performs various operations on the filedescriptor <var>Handle</var>.
<var>Ndx</var> describes the operation to perform.
<var>Data</var> points to data needed for the <var>Ndx</var> function. 
The structure of this data is function-dependent, so we don't elaborate on
this here. 
For more information on this, see various manual pages under Linux.
</descr>
<errors>
Errors are reported in LinuxError. They are very dependent on the used
function, that's why we don't list them here
</errors>
<example file="olinuxex/ex54"/>
</element>


<element name="IOperm">
<short>Set permission on IO ports</short>
<descr>
<p>
<var>IOperm</var>
sets permissions on <var>Num</var> ports starting with port <var>From</var> to 
<var>Value</var>. The function returns <var>True</var> if the call was successfull,
<var>False</var> otherwise.
</p>
<p>
Note:
</p>
<ul>
<li>This works ONLY as root.</li>
<li>Only the first <var>0x03ff</var> ports can be set.</li>
<li>When doing a <link id="Fork"/>, the permissions are reset. When doing a
<link id="Execve"/> they are kept.</li>
</ul>
</descr>
<errors>
Errors are returned in <var>LinuxError</var>
</errors>
</element>

<element name="IsATTY">
<short>Check if filehandle is a TTY (terminal)</short>
<descr>
<p>
Check if the filehandle described by <var>f</var> is a terminal.
<var>f</var> can be of type
</p>
<ol>
<li><var>longint</var> for file handles;</li>
<li><var>Text</var> for <var>text</var> variables such as <var>input</var> etc.</li>
</ol>
<p>
Returns <var>True</var> if <var>f</var> is a terminal, <var>False</var> otherwise.
</p>
</descr>
<errors>
No errors are reported
</errors>
<seealso>
<link id="IOCtl"/>
<link id="TTYName"/>
</seealso>
</element>

<element name="S_ISBLK">
<short>Is file a block device</short>
<descr>
<var>S_ISBLK</var> checks the file mode <var>m</var> to see whether the file is a
block device file. If so it returns <var>True</var>.
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISLNK"/> 
<link id="S_ISREG"/>
<link id="S_ISDIR"/>
<link id="S_ISCHR"/>
<link id="S_ISFIFO"/>
<link id="S_ISSOCK"/>
</seealso>
</element>

<element name="S_ISCHR">
<short>Is file a character device</short>
<descr>
<var>S_ISCHR</var> checks the file mode <var>m</var> to see whether the file is a
character device file. If so it returns <var>True</var>.
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISLNK"/> 
<link id="S_ISREG"/>
<link id="S_ISDIR"/>
<link id="S_ISBLK"/>
<link id="S_ISFIFO"/>
<link id="S_ISSOCK"/>
</seealso>
</element>

<element name="S_ISDIR">
<short>Is file a directory</short>
<descr>
<var>S_ISDIR</var> checks the file mode <var>m</var> to see whether the file is a
directory. If so it returns <var>True</var>
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISLNK"/> 
<link id="S_ISREG"/>
<link id="S_ISCHR"/>
<link id="S_ISBLK"/>
<link id="S_ISFIFO"/>
<link id="S_ISSOCK"/>
</seealso>
</element>

<element name="S_ISFIFO">
<short>Is file a FIFO</short>
<descr>
<var>S_ISFIFO</var> checks the file mode <var>m</var> to see whether the file is a
fifo (a named pipe). If so it returns <var>True</var>.
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISLNK"/>
<link id="S_ISREG"/>
<link id="S_ISCHR"/>
<link id="S_ISBLK"/>
<link id="S_ISDIR"/>
<link id="S_ISSOCK"/>
</seealso>
</element>

<element name="S_ISLNK">
<short>Is file a symbolic link</short>
<descr>
<var>S_ISLNK</var> checks the file mode <var>m</var> to see whether the file is a
symbolic link. If so it returns <var>True</var>
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISFIFO"/> 
<link id="S_ISREG"/>
<link id="S_ISCHR"/>
<link id="S_ISBLK"/>
<link id="S_ISDIR"/>
<link id="S_ISSOCK"/>
</seealso>
<example file="olinuxex/ex53"/>
</element>



<element name="S_ISREG">
<short>Is file a regular file</short>
<descr>
<var>S_ISREG</var> checks the file mode <var>m</var> to see whether the file is a
regular file. If so it returns <var>True</var>
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISFIFO"/> 
<link id="S_ISLNK"/>
<link id="S_ISCHR"/>
<link id="S_ISBLK"/>
<link id="S_ISDIR"/>
<link id="S_ISSOCK"/>
</seealso>
</element>

<element name="S_ISSOCK">
<short>Is file a unix socket</short>
<descr>
<var>S_ISSOCK</var> checks the file mode <var>m</var> to see whether the file is a
socket. If so it returns <var>True</var>.
</descr>
<seealso>
<link id="FStat"/>
<link id="S_ISFIFO"/> 
<link id="S_ISLNK"/>
<link id="S_ISCHR"/>
<link id="S_ISBLK"/>
<link id="S_ISDIR"/>
<link id="S_ISREG"/>
</seealso>
</element>

<element name="Kill">
<short>Send a signal to a process</short>
<descr>
Send a signal <var>Sig</var> to a process or process group. If <var>Pid</var>&gt;0 then
the signal is sent to <var>Pid</var>, if it equals -1, then the signal is sent to
all processes except process 1. If <var>Pid</var>&lt;-1 then the signal is sent to
process group -Pid.
The return value is zero, except in case three, where the return value is the
number of processes to which the signal was sent.
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors:
</p>
<dl>
<dt>sys_einval</dt><dd>An invalid signal is sent.</dd>
<dt>sys_esrch</dt><dd>The <var>Pid</var> or process group don't exist.</dd>
<dt>sys_eperm</dt><dd>The effective userid of the current process doesn't math
the one of process <var>Pid</var>.</dd>
</dl>
</errors>
<seealso>
<link id="SigAction"/>
<link id="Signal"/>
</seealso>
</element>

<element name="LStat">
<short>Return information about symbolic link. Do not follow the link</short>
<descr>
<var>LStat</var> gets information about the link specified in <var>Path</var>, and stores it in 
<var>Info</var>, which is of type <var>stat</var>. Contrary to <var>FStat</var>, it stores
information about the link, not about the file the link points to.
The function returns <var>True</var> if the call was succesfull, <var>False</var> if the call
failed.
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_enoent</dt><dd><var>Path</var> does not exist.</dd>
</dl>
</errors>
<seealso>
<link id="FStat"/>
<link id="FSStat"/>
</seealso>
<example file="olinuxex/ex29"/>
</element>


<element name="Link">
<short>Create a hard link to a file</short>
<descr>
<var>Link</var> makes <var>NewPath</var> point to the same file als <var>OldPath</var>. The two files
then have the same inode number. This is known as a 'hard' link.
The function returns <var>True</var> if the call was succesfull, <var>False</var> if the call
failed.
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_exdev</dt>
<dd><var>OldPath</var> and <var>NewPath</var> are not on the same filesystem.</dd>
<dt>sys_eperm</dt><dd>The filesystem containing oldpath and newpath doesn't
support linking files.</dd>
<dt>sys_eaccess</dt>
<dd>Write access for the directory containing <var>Newpath</var>
is disallowed, or one of the directories in <var>OldPath</var> or {NewPath} has no
search (=execute) permission.</dd>
<dt>sys_enoent</dt>
<dd>A directory entry in <var>OldPath</var> or <var>NewPath</var> does
not exist or is a symbolic link pointing to a non-existent directory.</dd>
<dt>sys_enotdir</dt>
<dd>A directory entry in <var>OldPath</var> or <var>NewPath</var> is
nor a directory.</dd>
<dt>sys_enomem</dt><dd>Insufficient kernel memory.</dd>
<dt>sys_erofs</dt><dd>The files are on a read-only filesystem.</dd>
<dt>sys_eexist</dt><dd><var>NewPath</var> already exists.</dd>
<dt>sys_emlink</dt><dd><var>OldPath</var> has reached maximal link count.</dd>
<dt>sys_eloop</dt>
<dd><var>OldPath</var> or <var>NewPath</var> has a reference to a circular
symbolic link, i.e. a symbolic link, whose expansion points to itself.</dd>
<dt>sys_enospc</dt>
<dd>The device containing <var>NewPath</var> has no room for another
entry.</dd>
<dt>sys_eperm</dt>
<dd><var>OldPath</var> points to . or .. of a directory.</dd>
</dl>
</errors>
<seealso>
<link id="SymLink"/>
<link id="UnLink"/>
</seealso>
<example file="olinuxex/ex21"/>
</element>


<element name="LocalToEpoch">
<short>Convert local time to epoch (unix) time</short>
<descr>
Converts the Local time to epoch time (=Number of seconds since 00:00:00 , January 1,
1970 ).
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="EpochToLocal"/>
<link id="GetTime"/>
<link id="GetDate"/> 
</seealso>
<example file="olinuxex/ex4"/>
</element>


<element name="MkFifo">
<short>Create FIFO (named pipe) in file system</short>
<descr>
<var>MkFifo</var> creates named a named pipe in the filesystem, with name
<var>PathName</var> and mode <var>Mode</var>.
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors:
</p>
<dl>
<dt>sys_emfile</dt><dd>Too many file descriptors for this process.</dd>
<dt>sys_enfile</dt><dd>The system file table is full.</dd>
</dl>
</errors>
<seealso>
<link id="POpen"/>
<link id="MkFifo"/>
</seealso>
</element>

<element name="MMap">
<short>Create memory map of a file</short>
<descr>
<p>
<var>MMap</var> maps or unmaps files or devices into memory. The different fields
of the argument <var>m</var> determine what and how the <var>mmap</var> maps this:
</p>
<dl>
<dt>address</dt>
<dd>Address where to mmap the device. This address is a hint,
and may not be followed.</dd>
<dt>size</dt><dd>Size (in bytes) of area to be mapped.</dd>
<dt>prot</dt>
<dd>
<p> Protection of mapped memory. This is a OR-ed combination of the
following constants:</p>
<dl>
<dt>PROT_EXEC</dt><dd>The memory can be executed.</dd>
<dt>PROT_READ</dt><dd>The memory can be read.</dd>
<dt>PROT_WRITE</dt><dd>The memory can be written.</dd>
<dt>PROT_NONE</dt><dd>The memory can not be accessed.</dd>
</dl>
</dd>
<dt>flags</dt><dd><p>Contains some options for the mmap call. It is an OR-ed
combination of the following constants:</p>
<dl>
<dt>MAP_FIXED</dt>
<dd>Do not map at another address than the given address. If the
address cannot be used, <var>MMap</var> will fail.</dd>
<dt>MAP_SHARED</dt>
<dd>Share this map with other processes that map this object.</dd>
<dt>MAP_PRIVATE</dt>
<dd>Create a private map with copy-on-write semantics.</dd>
<dt>MAP_ANONYMOUS</dt>
<dd><var>fd</var> does not have to be a file descriptor.</dd>
</dl>
<p>
One of the options <var>MAP_SHARED</var> and <var>MAP_PRIVATE</var> must be present,
but not both at the same time.
</p>
</dd>
<dt>fd</dt><dd>File descriptor from which to map.</dd>
<dt>offset</dt><dd>Offset to be used in file descriptor fd.</dd>
</dl>
<p>
The function returns a pointer to the mapped memory, or a -1 in case of en
error.
</p>
</descr>
<errors>
<p>
On error, -1 is returned and LinuxError is set to the error code:
</p>
<dl>
<dt>Sys_EBADF</dt>
<dd><var>fd</var> is not a valid file descriptor and
<var>MAP_ANONYMOUS</var> was not specified.</dd>
<dt>Sys_EACCES</dt>
<dd><var>MAP_PRIVATE</var> was specified, but fd is not open for
reading. Or <var>MAP_SHARED</var> was asked and <var>PROT_WRITE</var> is  set, fd
is not open for writing</dd>
<dt>Sys_EINVAL</dt>
<dd>One of the record fields <var>Start</var>, <var>length</var> or
<var>offset</var> is invalid.</dd>
<dt>Sys_ETXTBUSY</dt>
<dd><var>MAP_DENYWRITE</var> was set but the object specified
by fd is open for writing.</dd>
<dt>Sys_EAGAIN</dt>
<dd><var>fd</var> is locked, or too much memory is locked.</dd>
<dt>Sys_ENOMEM</dt>
<dd>Not enough memory for this operation.</dd>
</dl>
</errors>
<seealso>
<link id="MUnMap"/>
</seealso>
<example file="olinuxex/ex66"/>
</element>

<element name="MUnMap">
<short>Unmap previously mapped memory block</short>
<descr>
<p>
<var>MUnMap</var> unmaps the memory block of size <var>Size</var>, pointed to by 
<var>P</var>, which was previously allocated with <link id="MMap"/>.
</p>
<p>
The function returns <var>True</var> if successful, <var>False</var> otherwise.
</p>
<p>
For an example, see <link id="MMap"/>.
</p>
</descr>
<errors>
In case of error the function returns <var>False</var> and <var>LinuxError</var>
is set to an error value. See <link id="MMap"/> for possible error values.
</errors>
<seealso>
<link id="MMap"/>
</seealso>
</element>


<element name="NanoSleep">
<short>Suspend process for a short time</short>
<descr>
<p>
<var>NanoSleep</var> suspends the process till a time period as specified
in <var>req</var> has passed. Then the function returns. If the
call was interrupted (e.g. by some signal) then the function may
return earlier, and <var>rem</var> will contain the remaining time till the
end of the intended period. In this case the return value will be 
-1, and <var>LinuxError</var> will be set to <var>EINTR</var>
</p>
<p>
If the function returns without error, the return value is zero.
</p>
</descr>
<errors>
If the call was interrupted, -1 is returned, and <var>LinuxError</var> is set
to <var>EINTR</var>. If invalid time values were specified, then -1 is returned
and <var>LinuxError</var> is set to <var>EINVAL</var>.
</errors>
<seealso>
<link id="Pause"/>
<link id="Alarm"/>
</seealso>
<example file="olinuxex/ex72"/>
</element>



<element name="Nice">
<short>Set process priority</short>
<descr>
<p>
<var>Nice</var> adds <var>-N</var> to the priority of the running process. The lower the
priority numerically, the less the process is favored.
Only the superuser can specify a negative <var>N</var>, i.e. increase the rate at
which the process is run.
</p>
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>
</p>
<dl>
<dt>sys_eperm</dt><dd>A non-superuser tried to specify a negative <var>N</var>, i.e.
do a priority increase.</dd>
</dl>
</errors>
<seealso>
<link id="GetPriority"/>
<link id="SetPriority"/>
</seealso>
<example file="olinuxex/ex15"/>
</element>



<element name="Octal">
<short>Convert octal to decimal value</short>
<descr>
<p>
<var>Octal</var> will convert a number specified as an octal number to it's
decimal value.
</p>
<p>
This is useful for the <link id="Chmod"/> call, where permissions are specified
as octal numbers.
</p>
</descr>
<errors>
No checking is performed whether the given number is a correct Octal number.
e.g. specifying <var>998</var> is possible; the result will be wrong in that
case.
</errors>
<seealso>
<link id="Chmod"/>
</seealso>
<example file="olinuxex/ex68"/>
</element>



<element name="OpenDir">
<short>Open directory for reading</short>
<descr>
<var>OpenDir</var> opens the directory  <var>f</var>, and returns a <var>pdir</var>
pointer to a <var>Dir</var> record, which can be used to read the directory 
structure. If the directory cannot be opened, <var>nil</var> is returned.
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="CloseDir"/>
<link id="ReadDir"/>
<link id="SeekDir"/>
<link id="TellDir"/>
</seealso>
<example file="olinuxex/ex35"/>
</element>


<element name="pause">
<short>Wait for a signal</short>
<descr>
<p>
<var>Pause</var> puts the process to sleep and waits until the application 
receives  a signal. If a signal handler is installed for the received
sigal, the handler will be called and after that pause will return
control to the process.
</p>
<p>
For an example, see <link id="Alarm"/>.
</p>
</descr>
<link id="Alarm"/>
<link id="SigAction"/>
</element>



<element name="PClose">
<short>Close file opened with <link id="POpen"/></short>
<descr>
<p>
<var>PClose</var> closes a file opened with <link id="POpen"/>. It waits for the
command to complete, and then returns the exit status of the command. 
</p>
<p>
For an example, see <link id="POpen"/>
</p>
</descr>
<errors>
<var>LinuxError</var> is used to report errors. If it is different from zero,
the exit status is not valid.
</errors>
<seealso>
<link id="POpen"/>
</seealso>
</element>

<element name="POpen">
<short>Pipe file to standard input/output of program</short>
<descr>
<var>POpen</var> runs the command specified in <var>Cmd</var>,
and redirects the standard in or output of the
command to the other end of the pipe <var>F</var>. The parameter <var>rw</var>
indicates the direction of the pipe. If it is set to <var>'W'</var>, then F can
be used to write data, which will then be read by the command from stdinput.
If it is set to <var>'R'</var>, then the standard output of the command can be 
read from <var>F</var>. <var>F</var> should be reset or rewritten prior to using it.
<var>F</var> can be of type <var>Text</var> or <var>File</var>.
A file opened with <var>POpen</var> can be closed with <var>Close</var>, but also
with <link id="PClose"/>. The result is the same, but <var>PClose</var> returns the
exit status of the command <var>Cmd</var>.
</descr>
<errors>
Errors are reported in <var>LinuxError</var> and are essentially those of the
Execve, Dup and AssignPipe commands.
</errors>
<seealso>
<link id="AssignPipe"/>
<link id="PClose"/>
</seealso>
<example file="olinuxex/ex37"/>
</element>



<element name="ReadDir">
<short>Read entry from directory</short>
<descr>
<p>
<var>ReadDir</var> reads the next entry in the directory pointed to by <var>p</var>.
It returns a <var>pdirent</var> pointer to a structure describing the entry.
If the next entry can't be read, <var>Nil</var> is returned.
</p>
<p>
For an example, see <link id="OpenDir"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="CloseDir"/>
<link id="OpenDir"/>
<link id="SeekDir"/>
<link id="TellDir"/>,
</seealso>
</element>


<element name="ReadLink">
<short>Read destination of symbolic link</short>
<descr>
<p>
<var>ReadLink</var> returns the file the symbolic link <var>name</var> is pointing
to. The first form of this function accepts a buffer <var>linkname</var> of
length <var>maxlen</var> where the filename will be stored. It returns the
actual number of characters stored in the buffer.
</p>
<p>
The second form of the function returns simply the name of the file.
</p>
</descr>
<errors>
<p>
On error, the first form of the function returns -1; the second one returns
an empty string. <var>LinuxError</var> is set to report errors:
</p>
<dl>
<dt>SYS_ENOTDIR</dt>
<dd>A part of the path in <var>Name</var> is not a directory.</dd>
<dt>SYS_EINVAL</dt>
<dd>maxlen is not positive, or the  file is not a symbolic link.</dd>
<dt>SYS_ENAMETOOLONG</dt>
<dd>A pathname, or a component of a pathname, was too long.</dd>
<dt>SYS_ENOENT</dt>
<dd>the link <var>name</var> does not exist.</dd>
<dt>SYS_EACCES</dt>
<dd>No permission to search a directory in the path</dd>
<dt>SYS_ELOOP</dt>
<dd>Too many symbolic links were encountered in  translating the pathname.</dd>
<dt>SYS_EIO</dt>
<dd>An I/O error occurred while reading from the file system.</dd>
<dt>SYS_EFAULT</dt>
<dd>The buffer is not part of the process's memory space.</dd>
<dt>SYS_ENOMEM</dt>
<dd>Not enough kernel memory was available.</dd>
</dl>
</errors>
<seealso>
<link id="SymLink"/>
</seealso>
<example file="olinuxex/ex62"/>
</element>





<element name="ReadTimezoneFile">
<short>Read the timezone file and initialize time routines</short>
<descr>
<p>
<var>ReadTimeZoneFile</var> reads the timezone file <var>fn</var> and initializes
the local time routines based on the information found there.
</p>
<p>
There should be no need to call this function. The initialization routines
of the <file>linux</file> unit call this routine at unit startup.
</p>
</descr>
<errors> 
None.
</errors>
<seealso>
<link id="GetTimezoneFile"/>
<link id="GetLocalTimezone"/>
</seealso>
</element>


<element name="SeekDir">
<short>Seek to position in directory</short>
<descr>
<p>
<var>SeekDir</var> sets the directory pointer to the <var>off</var>-th entry in the
directory structure pointed to by <var>p</var>.
</p>
<p>
For an example, see <link id="OpenDir"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="CloseDir"/>
<link id="ReadDir"/>
<link id="OpenDir"/>
<link id="TellDir"/>
</seealso>
</element>

<element name="Select">
<short>Wait for events on file descriptors</short>
<descr>
<p>
<var>Select</var> checks one of the file descriptors in the <var>FDSets</var> to see if its
status changed.
</p>
<p>
<var>readfds, writefds</var> and <var>exceptfds</var> are pointers to arrays of 256
bits. If you want a file descriptor to be checked, you set the
corresponding element in the array to 1. The other elements in the array
must be set to zero. Three arrays are passed : The entries in <var>readfds</var>
are checked to see if characters become available for reading. The entries
in <var>writefds</var> are checked to see if it is OK to write to them, while
entries in <var>exceptfds</var> are checked to see if an exception occorred on
them.
</p>
<p>
You can use the functions <link id="FD_ZERO"/>
<link id="FD_Clr"/>,
<link id="FD_Set"/> or
<link id="FD_IsSet"/> to manipulate the individual elements of a set.
</p>
<p>
The pointers can be <var>Nil</var>.
</p>
<p>
<var>N</var> is the largest index of a nonzero entry plus 1. (= the largest
file-descriptor + 1).
</p>
<p>
<var>TimeOut</var> can be used to set a time limit.
If <var>TimeOut</var> can be two types :
</p>
<ol>
<li><var>TimeOut</var> is of type <var>PTime</var> and contains a
zero time, the call returns immediately. If <var>TimeOut</var> is <var>Nil</var>, the
kernel will wait forever, or until a status changed. </li>
<li><var>TimeOut</var> is of type <var>Longint</var>. If it is -1, this has the same
effect as a <var>Timeout</var> of type  <var>PTime</var> which is <var>Nil</var>.
Otherwise, <var>TimeOut</var> contains a time in milliseconds.</li>
</ol>
<p>
When the TimeOut is reached, or one of the file descriptors has changed,
the <var>Select</var> call returns. On return, it will have modified the entries
in the array which have actually changed, and it returns the number of
entries that have been changed. If the timout was reached, and no decsriptor
changed, zero is returned; The arrays of indexes are undefined after that.
On error, -1 is returned.
</p>
</descr>
<errors>
<p>
On error, the function returns -1, and Errors are reported in LinuxError :
</p>
<dl>
<dt>SYS_EBADF</dt>
<dd>An invalid descriptor was specified in one of the sets.</dd>
<dt>SYS_EINTR</dt>
<dd>A non blocked signal was caught.</dd>
<dt>SYS_EINVAL</dt>
<dd><var>N</var> is negative or too big.</dd>
<dt>SYS_ENOMEM</dt>
<dd><var>Select</var> was unable to allocate memory for its internal tables.</dd>
</dl>
</errors>
<seealso>
<link id="SelectText"/>
<link id="GetFS"/> 
<link id="FD_ZERO"/>
<link id="FD_Clr"/>
<link id="FD_Set"/> 
<link id="FD_IsSet"/>
</seealso>
<example file="olinuxex/ex33"/>
</element>



<element name="SelectText">
<short>Wait for event on typed ontyped file.</short>
<descr>
<var>SelectText</var> executes the <link id="Select"/> call on a file of type
<var>Text</var>. You can specify a timeout in <var>TimeOut</var>. The SelectText call
determines itself whether it should check for read or write, depending on
how the file was opened : With <var>Reset</var> it is checked for reading, with
<var>Rewrite</var> and <var>Append</var> it is checked for writing.
</descr>
<errors>
See <link id="Select"/>. <var>SYS_EBADF</var> can also mean that the file wasn't
opened.
</errors>
<seealso>
<link id="Select"/>
<link id="GetFS"/>
</seealso>
</element>

<element name="SetPriority">
<short>Set process priority</short>
<descr>
<p>
SetPriority sets the priority with which a process is running.
Which process(es) is determined by the <var>Which</var> and <var>Who</var> variables.
<var>Which</var> can be one of the pre-defined constants:
</p>
<dl>
<dt>Prio_Process</dt><dd><var>Who</var> is interpreted as process ID</dd>
<dt>Prio_PGrp</dt><dd><var>Who</var> is interpreted as process group ID</dd>
<dt>Prio_User</dt><dd><var>Who</var> is interpreted as user ID</dd>
</dl>
<p>
<var>Prio</var> is a value in the range -20 to 20.
</p>
<p>
For an example, see <link id="Nice"/>.
</p>
</descr>
<errors>
<p>
Error checking must be done on LinuxError, since a priority can be negative.
</p>
<dl>
<dt>sys_esrch</dt>
<dd>No process found using <var>which</var> and <var>who</var>.</dd>
<dt>sys_einval</dt>
<dd><var>Which</var> was not one of <var>Prio_Process</var>,
<var>Prio_Grp</var> or <var>Prio_User</var>.</dd>
<dt>sys_eperm</dt>
<dd>A process was found, but neither its effective or real
user ID match the effective user ID of the caller.</dd>
<dt>sys_eacces</dt>
<dd>A non-superuser tried to a priority increase.</dd>
</dl>
</errors>
<seealso>
<link id="GetPriority"/>
<link id="Nice"/>
</seealso>
</element>

<element name="Shell">
<short>Execute and feed command to system shell</short>
<descr>
<var>Shell</var> invokes the bash shell (<file>/bin/sh</file>), and feeds it the
command <var>Command</var> (using the <var>-c</var> option). The function then waits
for the command to complete, and then returns the exit
status of the command, or 127 if it could not complete the <link id="Fork"/> 
or <link id="Execve"/> calls.
</descr>
<errors>
Errors are reported in LinuxError.
</errors>
<seealso>
<link id="POpen"/>
<link id="Fork"/>
<link id="Execve"/>
</seealso>
<example file="olinuxex/ex56"/>
</element>



<element name="SigAction">
<short>Install signal handler</short>
<descr>
<p>
Changes the action to take upon receipt of a signal. <var>Act</var> and
<var>Oldact</var> are pointers to a <var>SigActionRec</var> record.
<var>SigNum</var> specifies the signal, and can be any signal except
<b>SIGKILL</b> or <b>SIGSTOP</b>.
</p>
<p>
If <var>Act</var> is non-nil, then the new action for signal <var>SigNum</var> is taken
from it. If <var>OldAct</var> is non-nil, the old action is stored there.
<var>Sa_Handler</var> may be <var>SIG_DFL</var> for the default action or
<var>SIG_IGN</var> to ignore the signal.
<var>Sa_Mask</var> Specifies which signals should be ignord during the execution
of the signal handler.
<var>Sa_Flags</var> Speciefies a series of flags which modify the behaviour of
the signal handler. You can 'or' none or more of the following :
</p>
<dl>
<dt>SA_NOCLDSTOP</dt>
<dd>If signum is <b>SIGCHLD</b> do not receive notification when child processes stop.
</dd>
<dt>SA_ONESHOT or SA_RESETHAND</dt>
<dd>Restore the signal action to the default
state once the signal handler has been called.
</dd>
<dt>SA_RESTART</dt>
<dd>For compatibility with BSD signals.</dd>
<dt>SA_NOMASK or SA_NODEFER</dt>
<dd>Do not prevent the signal from being received from within its own signal handler.
</dd>
</dl>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_einval</dt>
<dd>an invalid signal was specified, or it was <b>SIGKILL</b> or <b>SIGSTOP</b>.</dd>
<dt>sys_efault</dt>
<dd><var>Act,OldAct</var> point outside this process address space</dd>
<dt>sys_eintr</dt><dd>System call was interrupted.</dd>
</dl>
</errors>
<seealso>
<link id="SigProcMask"/>
<link id="SigPending"/>
<link id="SigSuspend"/>
<link id="Kill"/>
</seealso>
<example file="olinuxex/ex57"/>
</element>



<element name="SigPending">
<short>Return set of currently pending signals</short>
<descr>
Sigpending allows the examination of pending signals (which have been raised
while blocked.) The signal mask of pending signals is returned.
</descr>
<errors>
None
</errors>
<seealso>
<link id="SigAction"/>
<link id="SigProcMask"/>
<link id="SigSuspend"/>
<link id="Signal"/>
<link id="Kill"/>
</seealso>
</element>

<element name="SigProcMask">
<short>Set list of blocked signals</short>
<descr>
<p>
Changes the list of currently blocked signals. The behaviour of the call
depends on <var>How</var> :
</p>
<dl>
<dt>SIG_BLOCK</dt>
<dd>The set of blocked signals is the union of the current set
and the <var>SSet</var> argument.</dd>
<dt>SIG_UNBLOCK</dt>
<dd>The signals in <var>SSet</var> are removed from the set of
currently blocked signals.</dd>
<dt>SIG_SETMASK</dt>
<dd>The list of blocked signals is set so <var>SSet</var>.
</dd>
</dl>
<p>
If <var>OldSSet</var> is non-nil, then the old set is stored in it.
</p>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors.
</p>
<dl>
<dt>sys_efault</dt>
<dd><var>SSet</var> or <var>OldSSet</var> point to an adress outside
the range of the process.</dd>
<dt>sys_eintr</dt>
<dd>System call was interrupted.</dd>
</dl>
</errors>
<seealso>
<link id="SigAction"/>
<link id="SigPending"/>
<link id="SigSuspend"/>
<link id="Kill"/>
</seealso>
</element>

<element name="SigRaise">
<short>Raise a signal (send to current process)</short>
<descr>
<var>SigRaise</var> sends a <var>Sig</var> signal to the current process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Kill"/>
<link id="GetPid"/>
</seealso>
<example file="olinuxex/ex65"/>
</element>

<element name="SigSuspend">
<short>Set signal mask and suspend process till signal is received</short>
<descr>
SigSuspend temporarily replaces the signal mask for the process with the one
given in <var>Mask</var>, and then suspends the process until a signal is received.
</descr>
<errors>
None
</errors>
<seealso>
<link id="SigAction"/>
<link id="SigProcMask"/>
<link id="SigPending"/>
<link id="Signal"/>
<link id="Kill"/>
</seealso>
</element>

<element name="Signal">
<short>Install signal handler (deprecated)</short>
<descr>
<p>
<var>Signal</var> installs a new signal handler for signal <var>SigNum</var>. This call has
the same functionality as the <b>SigAction</b> call.
The return value for Signal is the old signal handler, or nil on error.
</p>
</descr>
<errors>
<p>
<var>LinuxError</var> is used to report errors :
</p>
<dl>
<dt>SIG_ERR</dt>
<dd>An error occurred.</dd>
</dl>
</errors>
<seealso>
<link id="SigAction"/>
<link id="Kill"/>
</seealso>
<example file="olinuxex/ex58"/>
</element>

<element name="StringToPPchar">
<short>Split string in list of null-terminated strings</short>
<descr>
<p>
<var>StringToPPChar</var> splits the string <var>S</var> in words, replacing any
whitespace with zero characters. It returns a pointer to an array of pchars
that point to the first letters of the words in <var>S</var>. This array is terminated
by a <var>Nil</var> pointer.
</p>
<p>
The function does <em>not</em> add a zero character to the end of the string
unless it ends on whitespace.
</p>
<p>
The function reserves memory on the heap to store the array of <var>PChar</var>;
The caller is responsible for freeing this memory. 
</p>
<p>
This function can be called to create arguments for the various <var>Exec</var>
calls.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CreateShellArgV"/>
<link id="Execve"/>
<link id="Execv"/>
</seealso>
<example file="olinuxex/ex70"/>
</element>



<element name="SymLink">
<short>Create a symbolic link</short>
<descr>
<p>
<var>SymLink</var> makes <var>Newpath</var> point to the file in <var>OldPath</var>, which doesn't
necessarily exist. The two files DO NOT have the same inode number.
This is known as a 'soft' link.
</p>
<p>The permissions of the link are irrelevant, as they are not used when
following the link. Ownership of the file is only checked in case of removal
or renaming of the link.
</p>
<p>
The function returns <var>True</var> if the call was succesfull, <var>False</var> if the call
failed.
</p>
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_eperm</dt>
<dd>The filesystem containing oldpath and newpath does not
support linking files.</dd>
<dt>sys_eaccess</dt>
<dd>Write access for the directory containing <var>Newpath</var>
is disallowed, or one of the directories in <var>OldPath</var> or
<var>NewPath</var> has no search (=execute) permission.</dd>
<dt>sys_enoent</dt>
<dd>A directory entry in <var>OldPath</var> or <var>NewPath</var> does
not exist or is a symbolic link pointing to a non-existent directory.</dd>
<dt>sys_enotdir</dt>
<dd>A directory entry in <var>OldPath</var> or <var>NewPath</var> is
nor a directory.</dd>
<dt>sys_enomem</dt><dd>Insufficient kernel memory.</dd>
<dt>sys_erofs</dt><dd>The files are on a read-only filesystem.</dd>
<dt>sys_eexist</dt><dd><var>NewPath</var> already exists.</dd>
<dt>sys_eloop</dt>
<dd><var>OldPath</var> or <var>NewPath</var> has a reference to a circular
symbolic link, i.e. a symbolic link, whose expansion points to itself.
</dd>
<dt>sys_enospc</dt>
<dd>The device containing <var>NewPath</var> has no room for another entry.</dd>
</dl>
</errors>
<seealso>
<link id="Link"/>
<link id="UnLink"/>
<link id="ReadLink"/>
</seealso>
<example file="olinuxex/ex22"/>
</element>



<element name="SysInfo">
<short>Return kernel system information</short>
<descr>
<p>
<var>SysInfo</var> returns system information in <var>Info</var>. Returned information
in <var>Info</var> includes:
</p>
<dl>
<dt>uptime</dt><dd>Number of seconds since boot.</dd>
<dt>loads</dt><dd>1, 5 and 15 minute load averages.</dd>
<dt>totalram</dt><dd>total amount of main memory.</dd>
<dt>freeram</dt><dd>amount of free memory.</dd>
<dt>sharedram</dt><dd>amount of shared memory.</dd>
<dt>bufferram</dt><dd>amount of memory used by buffers.</dd>
<dt>totalswap</dt><dd>total amount of swapspace.</dd>
<dt>freeswap</dt><dd>amount of free swapspace.</dd>
<dt>procs</dt><dd>number of current processes.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Uname"/>
</seealso>
<example file="olinuxex/ex64"/>
</element>



<element name="TCDrain">
<short>Terminal control: Wait till all data was transmitted</short>
<descr>
<p>
<var>TCDrain</var> waits until all data to file descriptor <var>Fd</var> is transmitted.
</p>
<p>  
The function returns <var>True</var> if the call was succesfull, <var>False</var>
otherwise.
</p>
</descr>
<errors>
Errors are reported in LinuxError
</errors>
<seealso>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCFlow">
<short>Terminal control: Suspend transmission of data</short>
<descr>
<p>
<var>TCFlow</var> suspends/resumes transmission or reception of data to or from the file
descriptor <var>Fd</var>, depending on the action <var>Act</var>. 
</p>
<p>
This can be one of the following pre-defined values: 
</p>
<dl>
<dt>TCOOFF</dt><dd>suspend reception/transmission</dd>
<dt>TCOON</dt><dd>resume  reception/transmission</dd>
<dt>TCIOFF</dt><dd>transmit a stop character to stop input from the terminal</dd>
<dt>TCION</dt><dd>transmit start to resume input from the terminal.</dd>
</dl>
<p>
The function returns <var>True</var> if the call was succesfull, <var>False</var>
otherwise.
</p>
</descr>
<errors>
Errors are reported in LinuxError.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCFlush">
<short>Terminal control: Discard data buffer</short>
<descr>
<p>
<var>TCFlush</var> discards all data sent or received to/from file descriptor 
<var>fd</var>.  <var>QSel</var> indicates which queue should be discard. 
It can be one of the following pre-defined values :
</p>
<dl>
<dt>TCIFLUSH</dt><dd>input buffer</dd>
<dt>TCOFLUSH</dt><dd>output buffer</dd>
<dt>TCIOFLUSH</dt><dd>both input and output buffers</dd>
</dl>
<p>
The function returns <var>True</var> if the call was succesfull, <var>False</var>
otherwise.
</p>
</descr>
<errors>
Errors are reported in LinuxError.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCGetAttr">
<short>Terminal Control: Get terminal attributes</short>
<descr>
<var>TCGetAttr</var>
gets the terminal parameters from the terminal referred to by the file
descriptor <var>fd</var> and returns them in a <var>TermIOS</var> structure <var>tios</var>. 
The function returns <var>True</var> if the call was succesfull, <var>False</var>
otherwise.
</descr>
<errors>
Errors are reported in LinuxError
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
<example file="olinuxex/ex55"/>
</element>



<element name="TCGetPGrp">
<short>Terminal control: Get process group</short>
<descr>
<var>TCGetPGrp</var>
returns the process group ID of a foreground process group in <var>Id</var> 
The function returns <var>True</var> if the call was succesfull, <var>False</var>
otherwise.
</descr>
<errors>
Errors are reported in LinuxError
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCSendBreak">
<short>Terminal control: Send break</short>
<descr>
<var>TCSendBreak</var> 
Sends zero-valued bits on an asynchrone serial connection decsribed by
file-descriptor <var>Fd</var>, for duration <var>Duration</var>.
The function returns <var>True</var> if the action was performed successfully,
<var>False</var> otherwise.
</descr>
<errors>
Errors are reported in LinuxError.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCSetAttr">
<short>Terminal control: Set attributes</short>
<descr>
<p>
<var>TCSetAttr</var> sets the terminal parameters you specify in a 
<var>TermIOS</var> structure<var>Tios</var> for the terminal
referred to by the file descriptor <var>Fd</var>. 
</p>
<p>
<var>OptAct</var> specifies an  optional action when the set need to be done,
 this could be one of the following pre-defined values:
</p>
<dl>
<dt>TCSANOW</dt><dd>set immediately.</dd>
<dt>TCSADRAIN</dt><dd>wait for output.</dd>
<dt>TCSAFLUSH</dt><dd>wait for output and discard all input not yet read.</dd>
</dl>
<p>
The function Returns <var>True</var> if the call was succesfull, <var>False</var> 
otherwise.
</p>
<p>
For an example, see <link id="TCGetAttr"/>.
</p>
</descr>
<errors>
Errors are reported in LinuxError.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetPGrp"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TCSetPGrp">
<short>Terminal control: Set process group</short>
<descr>
<p>
<var>TCSetPGrp</var> Sets the Process Group Id to <var>Id</var>. 
The function returns <var>True</var> if the call was successful, <var>False</var>
otherwise.
</p>
<p>
For an example, see <link id="TCGetPGrp"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TTYName"/>
<link id="IsATTY"/>
</seealso>
</element>

<element name="TTYName">
<short>Terminal control: Get terminal name</short>
<descr>
<p>
<var>TTYName</var>Returns the name of the terminal pointed to by <var>f</var>. <var>f</var>
must be a terminal. <var>f</var> can be of type:
</p>
<ol>
<li><var>longint</var> for file handles;</li>
<li><var>Text</var> for <var>text</var> variables such as <var>input</var> etc.</li>
</ol>
</descr>
<errors>
Returns an empty string in case of an error. <var>Linuxerror</var> may be set
to indicate what error occurred, but this is uncertain.
</errors>
<seealso>
<link id="TCDrain"/>
<link id="TCFlow"/>
<link id="TCFlush"/>
<link id="TCGetAttr"/>
<link id="TCGetPGrp"/>
<link id="TCSendBreak"/>
<link id="TCSetAttr"/>
<link id="TCSetPGrp"/>
<link id="IsATTY"/>
<link id="IOCtl"/>
</seealso>
</element>

<element name="TellDir">
<short>Return current location in a directory</short>
<descr>
<p>
<var>TellDir</var> returns the current location in the directory structure
pointed to by <var>p</var>. It returns -1 on failure.
</p>
<p>
For an example, see <link id="OpenDir"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="CloseDir"/>
<link id="ReadDir"/>
<link id="SeekDir"/>
<link id="OpenDir"/>
</seealso>
</element>

<element name="Umask">
<short>Set file creation mask.</short>
<descr>
Change the file creation mask for the current user to <var>Mask</var>. The
current mask is returned.
</descr>
<seealso>
<link id="Chmod"/>
</seealso>
<example file="olinuxex/ex27"/>
</element>

<element name="Uname">
<short>Return system name.</short>
<descr>
<var>Uname</var> gets the name and configuration of the current Linux kernel,
and returns it in <var>unamerec</var>.
</descr>
<errors>
<var>LinuxError</var> is used to report errors.
</errors>
<seealso>
<link id="GetHostName"/>
<link id="GetDomainName"/>
</seealso>
</element>

<element name="UnLink">
<short>Unlink (i.e. remove) a file.</short>
<descr>
<p>
<var>UnLink</var> decreases the link count on file <var>Path</var>. <var>Path</var> can be
of type <var>PathStr</var> or <var>PChar</var>. If the link count is zero, the
file is removed from the disk.
The function returns <var>True</var> if the call was succesfull, <var>False</var> if the call
failed.
</p>
<p>
For an example, see <link id="Link"/>.
</p>
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_eaccess</dt>
<dd>You have no write access right in the directory containing <var>Path</var>, 
or you have no search permission in one of the directory components of 
<var>Path</var>.</dd>
<dt>sys_eperm</dt>
<dd>The directory containing pathname has the sticky-bit set and the process's 
effective uid is neither the uid of the file to be deleted nor that of the 
directory containing it.</dd>
<dt>sys_enoent</dt><dd>A component of the path doesn't exist.</dd>
<dt>sys_enotdir</dt><dd>A directory component of the path is not a directory.</dd>
<dt>sys_eisdir</dt><dd><var>Path</var> refers to a directory.</dd>
<dt>sys_enomem</dt><dd>Insufficient kernel memory.</dd>
<dt>sys_erofs</dt><dd><var>Path</var> is on a read-only filesystem.</dd>
</dl>
</errors>
<seealso>
<link id="Link"/>
<link id="SymLink"/>
</seealso>
</element>

<element name="Utime">
<short>Set access and modification times of a file (touch).</short>
<descr>
<var>Utime</var> sets the access and modification times of a file.
the <var>utimbuf</var> record contains 2 fields, <var>actime</var>, and <var>modtime</var>,
both of type Longint. They should be filled with an epoch-like time,
specifying, respectively, the last access time, and the last modification
time. 
For some filesystem (most notably, FAT), these times are the same. 
</descr>
<errors>
<p>
Errors are returned in <var>LinuxError</var>.
</p>
<dl>
<dt>sys_eaccess</dt>
<dd>One of the directories in <var>Path</var> has no
search (=execute) permission.</dd>
<dt>sys_enoent</dt>
<dd>A directory entry in <var>Path</var> does 
not exist or is a symbolic link pointing to a non-existent directory.
</dd>
</dl>
<p>
Other errors may occur, but aren't documented.
</p>
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="Chown"/>
<link id="Access"/>
</seealso>
<example file="olinuxex/ex25"/>
</element>



<element name="WaitPid">
<short>Wait for a process to terminate</short>
<descr>
<p>
<var>WaitPid</var> waits for a child process with process ID <var>Pid</var> to exit. The
value of <var>Pid</var> can be one of the following:
</p>
<dl>
<dt>Pid &lt; -1</dt>
<dd>Causes <var>WaitPid</var> to wait for  any  child  process  whose
process group ID equals the absolute value of <var>pid</var>.</dd>
<dt>Pid = -1</dt>
<dd>Causes <var>WaitPid</var> to wait for any child process.</dd>
<dt>Pid = 0</dt>
<dd>Causes <var>WaitPid</var> to wait for  any  child  process  whose
process  group  ID  equals the one of the calling process.</dd>
<dt>Pid &gt; 0</dt>
<dd>Causes <var>WaitPid</var> to wait for the child whose process ID
equals the value of <var>Pid</var>.</dd>
</dl>
<p>
The <var>Options</var> parameter can be used to specify further how <var>WaitPid</var>
behaves:
</p>
<dl>
<dt>WNOHANG</dt>
<dd>Causes <var>Waitpid</var> to return immediately if no child  hasexited.</dd>
<dt>WUNTRACED</dt>
<dd>Causes <var>WaitPid</var> to return also for children which are
stopped, but whose status has not yet been reported.</dd>
<dt>__WCLONE</dt>
<dd>Causes <var>WaitPid</var> also to wait for threads created by
the <link id="Clone"/> call.</dd>
</dl>
<p> 
Upon return, it returns the exit status of the process, or -1 in case of
failure. 
</p>
<p>
For an example, see <link id="Fork"/>.
</p>
</descr>
<errors>
Errors are returned in LinuxError.
</errors>
<seealso>
<link id="Fork"/>
<link id="Execve"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="Seek_set">
<short>Seek option: Set absolute position.</short>
</element>

<!-- constant Visibility: default -->
<element name="Seek_Cur">
<short>Seek option: Set position relative to current position.</short>
</element>

<!-- constant Visibility: default -->
<element name="Seek_End">
<short>Seek option: Set position relative to end of file.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Accmode">
<short>Bitmask to determine access mode in open flags.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_RdOnly">
<short>File open mode: Read only</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_WrOnly">
<short>File open mode: Write only</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_RdWr">
<short>File open mode: Read/Write</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Creat">
<short>File open mode: Create if file does not yet exist.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Excl">
<short>File open mode: Open exclusively</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NoCtty">
<short>File open mode: No TTY control.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Trunc">
<short>File open mode: Truncate file to length 0</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Append">
<short>File open mode: Append to file</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NonBlock">
<short>File open mode: Open in non-blocking mode</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NDelay">
<short>File open mode: Alias for <link id="Open_NonBlock"/></short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Sync">
<short>File open mode: Write to disc at once</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Direct">
<short>File open mode: Minimize caching effects</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_LargeFile">
<short>File open mode: Open for 64-bit I/O</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Directory">
<short>File open mode: File must be directory.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NoFollow">
<short>File open mode: Fail if file is symbolic link.</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_NoHang">
<short><link id="WaitPID"/>: Do not wait</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_UnTraced">
<short><link id="WaitPID"/>: Also report stopped but untraced processes</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_Any">
<short><link id="WaitPID"/>: Wait on any process</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_MyPGRP">
<short><link id="WaitPID"/>: Wait processes from current process group</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_Clone">
<short><link id="WaitPID"/>: Wait on clone processes only.</short>
</element>

<!-- constant Visibility: default -->
<element name="IOCtl_TCGETS">
<short>IOCTL call number: get Terminal Control settings</short>
</element>

<!-- record type Visibility: default -->
<element name="SysCallRegs">
<short>Register describing system calls.</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg1">
<short>Register 1</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg2">
<short>Register 2</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg3">
<short>Register 3</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg4">
<short>Register 4</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg5">
<short>Register 5</short>
</element>

<!-- variable Visibility: default -->
<element name="SysCallRegs.reg6">
<short>Register 6</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSysCallRegs">
<short>Pointer to <link id="SysCallRegs"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TSysCallRegs">
<short>Alias for <link id="SysCallRegs"/> record</short>
</element>

<!-- alias type Visibility: default -->
<element name="TDirEnt">
<short>Alias for <link id="DirEnt"/> record</short>
</element>

<!-- alias type Visibility: default -->
<element name="dev_t">
<short>Device descriptor type</short>
</element>

<!-- variable Visibility: default -->
<element name="Stat.blksze">
<short>Block size</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PStat">
<short>Pointer to <link id="Stat"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TStat">
<short>Alias for <link id="Stat"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PStatFS">
<short>Pointer to <link id="StatFS"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TStatFS">
<short>Alias for <link id="StatFS"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TFDSet">
<short>Alias for <link id="FDSet"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTimeVal">
<short>Alias for <link id="TimeVal"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="timezone">
<short>Record describing a timezone</short>
</element>

<!-- variable Visibility: default -->
<element name="timezone.minuteswest">
<short>Minutes west of GMT</short>
</element>

<!-- variable Visibility: default -->
<element name="timezone.dsttime">
<short>Daylight savings time</short>
</element>

<!-- pointer type Visibility: default -->
<element name="ptimezone">
<short>Pointer to <link id="TimeZone"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTimeZone">
<short>Alias for <link id="TimeZone"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUTSName">
<short>Pointer to <link id="UTSName"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TUTSName">
<short>Alias for <link id="UTSName"/> record.</short>
</element>

<!-- constant Visibility: default -->
<element skip="1" name="syscall_nr_setup"/>
<element skip="1" name="syscall_nr_exit"/>
<element skip="1" name="syscall_nr_fork"/>
<element skip="1" name="syscall_nr_read"/>
<element skip="1" name="syscall_nr_write"/>
<element skip="1" name="syscall_nr_open"/>
<element skip="1" name="syscall_nr_close"/>
<element skip="1" name="syscall_nr_waitpid"/>
<element skip="1" name="syscall_nr_creat"/>
<element skip="1" name="syscall_nr_link"/>
<element skip="1" name="syscall_nr_unlink"/>
<element skip="1" name="syscall_nr_execve"/>
<element skip="1" name="syscall_nr_chdir"/>
<element skip="1" name="syscall_nr_time"/>
<element skip="1" name="syscall_nr_mknod"/>
<element skip="1" name="syscall_nr_chmod"/>
<element skip="1" name="syscall_nr_chown"/>
<element skip="1" name="syscall_nr_break"/>
<element skip="1" name="syscall_nr_oldstat"/>
<element skip="1" name="syscall_nr_lseek"/>
<element skip="1" name="syscall_nr_getpid"/>
<element skip="1" name="syscall_nr_mount"/>
<element skip="1" name="syscall_nr_umount"/>
<element skip="1" name="syscall_nr_setuid"/>
<element skip="1" name="syscall_nr_getuid"/>
<element skip="1" name="syscall_nr_stime"/>
<element skip="1" name="syscall_nr_ptrace"/>
<element skip="1" name="syscall_nr_alarm"/>
<element skip="1" name="syscall_nr_oldfstat"/>
<element skip="1" name="syscall_nr_pause"/>
<element skip="1" name="syscall_nr_utime"/>
<element skip="1" name="syscall_nr_stty"/>
<element skip="1" name="syscall_nr_gtty"/>
<element skip="1" name="syscall_nr_access"/>
<element skip="1" name="syscall_nr_nice"/>
<element skip="1" name="syscall_nr_ftime"/>
<element skip="1" name="syscall_nr_sync"/>
<element skip="1" name="syscall_nr_kill"/>
<element skip="1" name="syscall_nr_rename"/>
<element skip="1" name="syscall_nr_mkdir"/>
<element skip="1" name="syscall_nr_rmdir"/>
<element skip="1" name="syscall_nr_dup"/>
<element skip="1" name="syscall_nr_pipe"/>
<element skip="1" name="syscall_nr_times"/>
<element skip="1" name="syscall_nr_prof"/>
<element skip="1" name="syscall_nr_brk"/>
<element skip="1" name="syscall_nr_setgid"/>
<element skip="1" name="syscall_nr_getgid"/>
<element skip="1" name="syscall_nr_signal"/>
<element skip="1" name="syscall_nr_geteuid"/>
<element skip="1" name="syscall_nr_getegid"/>
<element skip="1" name="syscall_nr_acct"/>
<element skip="1" name="syscall_nr_phys"/>
<element skip="1" name="syscall_nr_lock"/>
<element skip="1" name="syscall_nr_ioctl"/>
<element skip="1" name="syscall_nr_fcntl"/>
<element skip="1" name="syscall_nr_mpx"/>
<element skip="1" name="syscall_nr_setpgid"/>
<element skip="1" name="syscall_nr_ulimit"/>
<element skip="1" name="syscall_nr_oldolduname"/>
<element skip="1" name="syscall_nr_umask"/>
<element skip="1" name="syscall_nr_chroot"/>
<element skip="1" name="syscall_nr_ustat"/>
<element skip="1" name="syscall_nr_dup2"/>
<element skip="1" name="syscall_nr_getppid"/>
<element skip="1" name="syscall_nr_getpgrp"/>
<element skip="1" name="syscall_nr_setsid"/>
<element skip="1" name="syscall_nr_sigaction"/>
<element skip="1" name="syscall_nr_sgetmask"/>
<element skip="1" name="syscall_nr_ssetmask"/>
<element skip="1" name="syscall_nr_setreuid"/>
<element skip="1" name="syscall_nr_setregid"/>
<element skip="1" name="syscall_nr_sigsuspend"/>
<element skip="1" name="syscall_nr_sigpending"/>
<element skip="1" name="syscall_nr_sethostname"/>
<element skip="1" name="syscall_nr_setrlimit"/>
<element skip="1" name="syscall_nr_getrlimit"/>
<element skip="1" name="syscall_nr_getrusage"/>
<element skip="1" name="syscall_nr_gettimeofday"/>
<element skip="1" name="syscall_nr_settimeofday"/>
<element skip="1" name="syscall_nr_getgroups"/>
<element skip="1" name="syscall_nr_setgroups"/>
<element skip="1" name="syscall_nr_select"/>
<element skip="1" name="syscall_nr_symlink"/>
<element skip="1" name="syscall_nr_oldlstat"/>
<element skip="1" name="syscall_nr_readlink"/>
<element skip="1" name="syscall_nr_uselib"/>
<element skip="1" name="syscall_nr_swapon"/>
<element skip="1" name="syscall_nr_reboot"/>
<element skip="1" name="syscall_nr_readdir"/>
<element skip="1" name="syscall_nr_mmap"/>
<element skip="1" name="syscall_nr_munmap"/>
<element skip="1" name="syscall_nr_truncate"/>
<element skip="1" name="syscall_nr_ftruncate"/>
<element skip="1" name="syscall_nr_fchmod"/>
<element skip="1" name="syscall_nr_fchown"/>
<element skip="1" name="syscall_nr_getpriority"/>
<element skip="1" name="syscall_nr_setpriority"/>
<element skip="1" name="syscall_nr_profil"/>
<element skip="1" name="syscall_nr_statfs"/>
<element skip="1" name="syscall_nr_fstatfs"/>
<element skip="1" name="syscall_nr_ioperm"/>
<element skip="1" name="syscall_nr_socketcall"/>
<element skip="1" name="syscall_nr_syslog"/>
<element skip="1" name="syscall_nr_setitimer"/>
<element skip="1" name="syscall_nr_getitimer"/>
<element skip="1" name="syscall_nr_stat"/>
<element skip="1" name="syscall_nr_lstat"/>
<element skip="1" name="syscall_nr_fstat"/>
<element skip="1" name="syscall_nr_olduname"/>
<element skip="1" name="syscall_nr_iopl"/>
<element skip="1" name="syscall_nr_vhangup"/>
<element skip="1" name="syscall_nr_idle"/>
<element skip="1" name="syscall_nr_vm86old"/>
<element skip="1" name="syscall_nr_wait4"/>
<element skip="1" name="syscall_nr_swapoff"/>
<element skip="1" name="syscall_nr_sysinfo"/>
<element skip="1" name="syscall_nr_ipc"/>
<element skip="1" name="syscall_nr_fsync"/>
<element skip="1" name="syscall_nr_sigreturn"/>
<element skip="1" name="syscall_nr_clone"/>
<element skip="1" name="syscall_nr_setdomainname"/>
<element skip="1" name="syscall_nr_uname"/>
<element skip="1" name="syscall_nr_modify_ldt"/>
<element skip="1" name="syscall_nr_adjtimex"/>
<element skip="1" name="syscall_nr_mprotect"/>
<element skip="1" name="syscall_nr_sigprocmask"/>
<element skip="1" name="syscall_nr_create_module"/>
<element skip="1" name="syscall_nr_init_module"/>
<element skip="1" name="syscall_nr_delete_module"/>
<element skip="1" name="syscall_nr_get_kernel_syms"/>
<element skip="1" name="syscall_nr_quotactl"/>
<element skip="1" name="syscall_nr_getpgid"/>
<element skip="1" name="syscall_nr_fchdir"/>
<element skip="1" name="syscall_nr_bdflush"/>
<element skip="1" name="syscall_nr_sysfs"/>
<element skip="1" name="syscall_nr_personality"/>
<element skip="1" name="syscall_nr_afs_syscall"/>
<element skip="1" name="syscall_nr_setfsuid"/>
<element skip="1" name="syscall_nr_setfsgid"/>
<element skip="1" name="syscall_nr__llseek"/>
<element skip="1" name="syscall_nr_getdents"/>
<element skip="1" name="syscall_nr__newselect"/>
<element skip="1" name="syscall_nr_flock"/>
<element skip="1" name="syscall_nr_msync"/>
<element skip="1" name="syscall_nr_readv"/>
<element skip="1" name="syscall_nr_writev"/>
<element skip="1" name="syscall_nr_getsid"/>
<element skip="1" name="syscall_nr_fdatasync"/>
<element skip="1" name="syscall_nr__sysctl"/>
<element skip="1" name="syscall_nr_mlock"/>
<element skip="1" name="syscall_nr_munlock"/>
<element skip="1" name="syscall_nr_mlockall"/>
<element skip="1" name="syscall_nr_munlockall"/>
<element skip="1" name="syscall_nr_sched_setparam"/>
<element skip="1" name="syscall_nr_sched_getparam"/>
<element skip="1" name="syscall_nr_sched_setscheduler"/>
<element skip="1" name="syscall_nr_sched_getscheduler"/>
<element skip="1" name="syscall_nr_sched_yield"/>
<element skip="1" name="syscall_nr_sched_get_priority_max"/>
<element skip="1" name="syscall_nr_sched_get_priority_min"/>
<element skip="1" name="syscall_nr_sched_rr_get_interval"/>
<element skip="1" name="syscall_nr_nanosleep"/>
<element skip="1" name="syscall_nr_mremap"/>
<element skip="1" name="syscall_nr_setresuid"/>
<element skip="1" name="syscall_nr_getresuid"/>
<element skip="1" name="syscall_nr_vm86"/>
<element skip="1" name="syscall_nr_query_module"/>
<element skip="1" name="syscall_nr_poll"/>
<element skip="1" name="syscall_nr_sigaltstack"/>
<element skip="1" name="Sys_EPERM"/>
<element skip="1" name="Sys_ENOENT"/>
<element skip="1" name="Sys_ESRCH"/>
<element skip="1" name="Sys_EINTR"/>
<element skip="1" name="Sys_EIO"/>
<element skip="1" name="Sys_ENXIO"/>
<element skip="1" name="Sys_E2BIG"/>
<element skip="1" name="Sys_ENOEXEC"/>
<element skip="1" name="Sys_EBADF"/>
<element skip="1" name="Sys_ECHILD"/>
<element skip="1" name="Sys_EAGAIN"/>
<element skip="1" name="Sys_ENOMEM"/>
<element skip="1" name="Sys_EACCES"/>
<element skip="1" name="Sys_EFAULT"/>
<element skip="1" name="Sys_ENOTBLK"/>
<element skip="1" name="Sys_EBUSY"/>
<element skip="1" name="Sys_EEXIST"/>
<element skip="1" name="Sys_EXDEV"/>
<element skip="1" name="Sys_ENODEV"/>
<element skip="1" name="Sys_ENOTDIR"/>
<element skip="1" name="Sys_EISDIR"/>
<element skip="1" name="Sys_EINVAL"/>
<element skip="1" name="Sys_ENFILE"/>
<element skip="1" name="Sys_EMFILE"/>
<element skip="1" name="Sys_ENOTTY"/>
<element skip="1" name="Sys_ETXTBSY"/>
<element skip="1" name="Sys_EFBIG"/>
<element skip="1" name="Sys_ENOSPC"/>
<element skip="1" name="Sys_ESPIPE"/>
<element skip="1" name="Sys_EROFS"/>
<element skip="1" name="Sys_EMLINK"/>
<element skip="1" name="Sys_EPIPE"/>
<element skip="1" name="Sys_EDOM"/>
<element skip="1" name="Sys_ERANGE"/>
<element skip="1" name="Sys_EDEADLK"/>
<element skip="1" name="Sys_ENAMETOOLONG"/>
<element skip="1" name="Sys_ENOLCK"/>
<element skip="1" name="Sys_ENOSYS"/>
<element skip="1" name="Sys_ENOTEMPTY"/>
<element skip="1" name="Sys_ELOOP"/>
<element skip="1" name="Sys_EWOULDBLOCK"/>
<element skip="1" name="Sys_ENOMSG"/>
<element skip="1" name="Sys_EIDRM"/>
<element skip="1" name="Sys_ECHRNG"/>
<element skip="1" name="Sys_EL2NSYNC"/>
<element skip="1" name="Sys_EL3HLT"/>
<element skip="1" name="Sys_EL3RST"/>
<element skip="1" name="Sys_ELNRNG"/>
<element skip="1" name="Sys_EUNATCH"/>
<element skip="1" name="Sys_ENOCSI"/>
<element skip="1" name="Sys_EL2HLT"/>
<element skip="1" name="Sys_EBADE"/>
<element skip="1" name="Sys_EBADR"/>
<element skip="1" name="Sys_EXFULL"/>
<element skip="1" name="Sys_ENOANO"/>
<element skip="1" name="Sys_EBADRQC"/>
<element skip="1" name="Sys_EBADSLT"/>
<element skip="1" name="Sys_EDEADLOCK"/>
<element skip="1" name="Sys_EBFONT"/>
<element skip="1" name="Sys_ENOSTR"/>
<element skip="1" name="Sys_ENODATA"/>
<element skip="1" name="Sys_ETIME"/>
<element skip="1" name="Sys_ENOSR"/>
<element skip="1" name="Sys_ENONET"/>
<element skip="1" name="Sys_ENOPKG"/>
<element skip="1" name="Sys_EREMOTE"/>
<element skip="1" name="Sys_ENOLINK"/>
<element skip="1" name="Sys_EADV"/>
<element skip="1" name="Sys_ESRMNT"/>
<element skip="1" name="Sys_ECOMM"/>
<element skip="1" name="Sys_EPROTO"/>
<element skip="1" name="Sys_EMULTIHOP"/>
<element skip="1" name="Sys_EDOTDOT"/>
<element skip="1" name="Sys_EBADMSG"/>
<element skip="1" name="Sys_EOVERFLOW"/>
<element skip="1" name="Sys_ENOTUNIQ"/>
<element skip="1" name="Sys_EBADFD"/>
<element skip="1" name="Sys_EREMCHG"/>
<element skip="1" name="Sys_ELIBACC"/>
<element skip="1" name="Sys_ELIBBAD"/>
<element skip="1" name="Sys_ELIBSCN"/>
<element skip="1" name="Sys_ELIBMAX"/>
<element skip="1" name="Sys_ELIBEXEC"/>
<element skip="1" name="Sys_EILSEQ"/>
<element skip="1" name="Sys_ERESTART"/>
<element skip="1" name="Sys_ESTRPIPE"/>
<element skip="1" name="Sys_EUSERS"/>
<element skip="1" name="Sys_ENOTSOCK"/>
<element skip="1" name="Sys_EDESTADDRREQ"/>
<element skip="1" name="Sys_EMSGSIZE"/>
<element skip="1" name="Sys_EPROTOTYPE"/>
<element skip="1" name="Sys_ENOPROTOOPT"/>
<element skip="1" name="Sys_EPROTONOSUPPORT"/>
<element skip="1" name="Sys_ESOCKTNOSUPPORT"/>
<element skip="1" name="Sys_EOPNOTSUPP"/>
<element skip="1" name="Sys_EPFNOSUPPORT"/>
<element skip="1" name="Sys_EAFNOSUPPORT"/>
<element skip="1" name="Sys_EADDRINUSE"/>
<element skip="1" name="Sys_EADDRNOTAVAIL"/>
<element skip="1" name="Sys_ENETDOWN"/>
<element skip="1" name="Sys_ENETUNREACH"/>
<element skip="1" name="Sys_ENETRESET"/>
<element skip="1" name="Sys_ECONNABORTED"/>
<element skip="1" name="Sys_ECONNRESET"/>
<element skip="1" name="Sys_ENOBUFS"/>
<element skip="1" name="Sys_EISCONN"/>
<element skip="1" name="Sys_ENOTCONN"/>
<element skip="1" name="Sys_ESHUTDOWN"/>
<element skip="1" name="Sys_ETOOMANYREFS"/>
<element skip="1" name="Sys_ETIMEDOUT"/>
<element skip="1" name="Sys_ECONNREFUSED"/>
<element skip="1" name="Sys_EHOSTDOWN"/>
<element skip="1" name="Sys_EHOSTUNREACH"/>
<element skip="1" name="Sys_EALREADY"/>
<element skip="1" name="Sys_EINPROGRESS"/>
<element skip="1" name="Sys_ESTALE"/>
<element skip="1" name="Sys_EUCLEAN"/>
<element skip="1" name="Sys_ENOTNAM"/>
<element skip="1" name="Sys_ENAVAIL"/>
<element skip="1" name="Sys_EISNAM"/>
<element skip="1" name="Sys_EREMOTEIO"/>
<element skip="1" name="Sys_EDQUOT"/>
<element skip="1" name="Sys_ERROR_MAX"/>

<!-- alias type Visibility: default -->
<element name="SigSet">
<short>Signal set type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSigSet">
<short>Pointer to signal set.</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_ONSTACK">
<short>Socket option</short>
</element>

<!-- constant Visibility: default -->
<element name="SI_PAD_SIZE">
<short>Signal information record pad bytes size. Do not use.</short>
</element>

<!-- alias type Visibility: default -->
<element name="Size_T">
<short>Size type</short>
</element>


<!-- constant Visibility: default -->
<element name="SS_ONSTACK">
<short>Socket options</short>
</element>

<!-- constant Visibility: default -->
<element name="SS_DISABLE">
<short>Socket options</short>
</element>

<!-- constant Visibility: default -->
<element name="MINSIGSTKSZ">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="SIGSTKSZ">
<short>Signal Stack size error</short>
</element>

<!-- record type Visibility: default -->
<element name="SigAltStack">
<short>Alternate stack registers record</short>
</element>

<!-- variable Visibility: default -->
<element name="SigAltStack.ss_sp">
<short>Stack pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="SigAltStack.ss_flags">
<short>Flags</short>
</element>

<!-- variable Visibility: default -->
<element name="SigAltStack.ss_size">
<short>Stack size</short>
</element>

<!-- alias type Visibility: default -->
<element name="stack_t">
<short>Alias for <link id="SigAltStack"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSigAltStack">
<short>Pointer to <link id="SigAltStack"/> record</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pstack_t">
<short>Pointer to <link id="stack_t"/> record</short>
</element>

<!-- variable Visibility: default -->
<element name="ErrNo">
<short>Error number of last operation.</short>
</element>

<!-- constant Visibility: default -->
<element name="CSIGNAL">
<short><link id="Clone"/> option: Signal mask to be sent at exit</short>
</element>

<!-- constant Visibility: default -->
<element name="CLONE_VM">
<short><link id="Clone"/> option: VM shared between processes</short>
</element>

<!-- constant Visibility: default -->
<element name="CLONE_FS">
<short><link id="Clone"/> option: fs info shared between processes</short>
</element>

<!-- constant Visibility: default -->
<element name="CLONE_FILES">
<short><link id="Clone"/> option: open files shared between processes</short>
</element>

<!-- constant Visibility: default -->
<element name="CLONE_SIGHAND">
<short><link id="Clone"/> option: signal handlers shared between processes</short>
</element>

<!-- constant Visibility: default -->
<element name="CLONE_PID">
<short><link id="Clone"/> option: PID shared between processes</short>
</element>

<!-- function type Visibility: default -->
<element name="TCloneFunc">
<short>Clone function prototype.</short>
</element>

<!-- constant Visibility: default -->
<element name="WNOHANG">
<short><link id="Waitpid"/> option: Do not wait for processes to terminate.</short>
</element>

<!-- constant Visibility: default -->
<element name="WUNTRACED">
<short><link id="Waitpid"/> option: Also report children wich were stopped but not yet reported</short>
</element>

<!-- constant Visibility: default -->
<element name="__WCLONE">
<short>Waitpid option: Wait for clone children only</short>
</element>

<!-- constant Visibility: default -->
<element name="P_IN">
<short>Input file descriptor of pipe pair.</short>
</element>

<!-- constant Visibility: default -->
<element name="P_OUT">
<short>Output file descriptor of pipe pair.</short>
</element>

<!-- array type Visibility: default -->
<element name="Tpipe">
<short>Array describing a pipe pair of filedescriptors.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ComStr">
<short>Command-line string type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PathStr">
<short>Filename path part string type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="DirStr">
<short>Filename directory part string type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="NameStr">
<short>Filename name part string type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ExtStr">
<short>Filename extension part string type.</short>
</element>

<!-- record type Visibility: default -->
<element name="winsize">
<short>Record describing terminal window size.</short>
</element>

<!-- variable Visibility: default -->
<element name="winsize.ws_row">
<short>Number of rows</short>
</element>

<!-- variable Visibility: default -->
<element name="winsize.ws_col">
<short>Number of columns</short>
</element>

<!-- variable Visibility: default -->
<element name="winsize.ws_xpixel">
<short>Number of pixels in horizontal direction</short>
</element>

<!-- variable Visibility: default -->
<element name="winsize.ws_ypixel">
<short>Number of pixels in vertical direction</short>
</element>

<!-- alias type Visibility: default -->
<element name="TWinSize">
<short>Alias for <link id="WinSize"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTermio">
<short>Alias for <link id="TermIO"/> record</short>
</element>

<!-- variable Visibility: default -->
<element name="Termios.c_ispeed">
<short>Input speed</short>
</element>

<!-- variable Visibility: default -->
<element name="Termios.c_ospeed">
<short>Output speed</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTermios">
<short>Alias for <link id="Termios"/> record.</short>
</element>

<element name="VINTR" skip="1" />
<element name="VQUIT" skip="1" />
<element name="VERASE" skip="1" />
<element name="VKILL" skip="1" />
<element name="VEOF" skip="1" />
<element name="VTIME" skip="1" />
<element name="VMIN" skip="1" />
<element name="VSWTC" skip="1" />
<element name="VSTART" skip="1" />
<element name="VSTOP" skip="1" />
<element name="VSUSP" skip="1" />
<element name="VEOL" skip="1" />
<element name="VREPRINT" skip="1" />
<element name="VDISCARD" skip="1" />
<element name="VWERASE" skip="1" />
<element name="VLNEXT" skip="1" />
<element name="VEOL2" skip="1" />
<element name="IGNBRK" skip="1" />
<element name="BRKINT" skip="1" />
<element name="IGNPAR" skip="1" />
<element name="PARMRK" skip="1" />
<element name="INPCK" skip="1" />
<element name="ISTRIP" skip="1" />
<element name="INLCR" skip="1" />
<element name="IGNCR" skip="1" />
<element name="ICRNL" skip="1" />
<element name="IUCLC" skip="1" />
<element name="IXON" skip="1" />
<element name="IXANY" skip="1" />
<element name="IXOFF" skip="1" />
<element name="IMAXBEL" skip="1" />
<element name="OPOST" skip="1" />
<element name="OLCUC" skip="1" />
<element name="ONLCR" skip="1" />
<element name="OCRNL" skip="1" />
<element name="ONOCR" skip="1" />
<element name="ONLRET" skip="1" />
<element name="OFILL" skip="1" />
<element name="OFDEL" skip="1" />
<element name="NLDLY" skip="1" />
<element name="NL0" skip="1" />
<element name="NL1" skip="1" />
<element name="CRDLY" skip="1" />
<element name="CR0" skip="1" />
<element name="CR1" skip="1" />
<element name="CR2" skip="1" />
<element name="CR3" skip="1" />
<element name="TABDLY" skip="1" />
<element name="TAB0" skip="1" />
<element name="TAB1" skip="1" />
<element name="TAB2" skip="1" />
<element name="TAB3" skip="1" />
<element name="XTABS" skip="1" />
<element name="BSDLY" skip="1" />
<element name="BS0" skip="1" />
<element name="BS1" skip="1" />
<element name="VTDLY" skip="1" />
<element name="VT0" skip="1" />
<element name="VT1" skip="1" />
<element name="FFDLY" skip="1" />
<element name="FF0" skip="1" />
<element name="FF1" skip="1" />
<element name="CBAUD" skip="1" />
<element name="B0" skip="1" />
<element name="B50" skip="1" />
<element name="B75" skip="1" />
<element name="B110" skip="1" />
<element name="B134" skip="1" />
<element name="B150" skip="1" />
<element name="B200" skip="1" />
<element name="B300" skip="1" />
<element name="B600" skip="1" />
<element name="B1200" skip="1" />
<element name="B1800" skip="1" />
<element name="B2400" skip="1" />
<element name="B4800" skip="1" />
<element name="B9600" skip="1" />
<element name="B19200" skip="1" />
<element name="B38400" skip="1" />
<element name="EXTA" skip="1" />
<element name="EXTB" skip="1" />
<element name="CSIZE" skip="1" />
<element name="CS5" skip="1" />
<element name="CS6" skip="1" />
<element name="CS7" skip="1" />
<element name="CS8" skip="1" />
<element name="CSTOPB" skip="1" />
<element name="CREAD" skip="1" />
<element name="PARENB" skip="1" />
<element name="PARODD" skip="1" />
<element name="HUPCL" skip="1" />
<element name="CLOCAL" skip="1" />
<element name="CBAUDEX" skip="1" />
<element name="B57600" skip="1" />
<element name="B115200" skip="1" />
<element name="B230400" skip="1" />
<element name="B460800" skip="1" />
<element name="CIBAUD" skip="1" />
<element name="CMSPAR" skip="1" />
<element name="CRTSCTS" skip="1" />
<element name="ISIG" skip="1" />
<element name="ICANON" skip="1" />
<element name="XCASE" skip="1" />
<element name="ECHO" skip="1" />
<element name="ECHOE" skip="1" />
<element name="ECHOK" skip="1" />
<element name="ECHONL" skip="1" />
<element name="NOFLSH" skip="1" />
<element name="TOSTOP" skip="1" />
<element name="ECHOCTL" skip="1" />
<element name="ECHOPRT" skip="1" />
<element name="ECHOKE" skip="1" />
<element name="FLUSHO" skip="1" />
<element name="PENDIN" skip="1" />
<element name="IEXTEN" skip="1" />
<element name="TIOCM_LE" skip="1" />
<element name="TIOCM_DTR" skip="1" />
<element name="TIOCM_RTS" skip="1" />
<element name="TIOCM_ST" skip="1" />
<element name="TIOCM_SR" skip="1" />
<element name="TIOCM_CTS" skip="1" />
<element name="TIOCM_CAR" skip="1" />
<element name="TIOCM_RNG" skip="1" />
<element name="TIOCM_DSR" skip="1" />
<element name="TIOCM_CD" skip="1" />
<element name="TIOCM_RI" skip="1" />
<element name="TIOCM_OUT1" skip="1" />
<element name="TIOCM_OUT2" skip="1" />

<element name="TCSANOW" skip="1" />
<element name="TCSADRAIN" skip="1" />
<element name="TCSAFLUSH" skip="1" />
<element name="TCOOFF" skip="1" />
<element name="TCOON" skip="1" />
<element name="TCIOFF" skip="1" />
<element name="TCION" skip="1" />
<element name="TCIFLUSH" skip="1" />
<element name="TCOFLUSH" skip="1" />
<element name="TCIOFLUSH" skip="1" />

<!-- alias type Visibility: default -->
<element name="UTimeBuf">
<short>Alias for <link id="UTimBuf"/> record.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TUTimeBuf">
<short>Alias for <link id="UTimBuf"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUTimeBuf">
<short>Pointer to <link id="UTimeBuf"/> record</short>
</element>

<!-- record type Visibility: default -->
<element name="TSysinfo">
<short>Record with system information, used by the <link id="SysInfo"/> call.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.uptime">
<short>Number of seconds since boot.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.loads">
<short>1, 5 and 15 minute load averages.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.totalram">
<short>total amount of main memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.freeram">
<short>amount of free memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.sharedram">
<short>amount of shared memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.bufferram">
<short>amount of memory used by buffers.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.totalswap">
<short>total amount of swapspace.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.freeswap">
<short>amount of free swapspace.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.procs">
<short>number of current processes.</short>
</element>

<!-- variable Visibility: default -->
<element name="TSysinfo.s">
<short>?</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSysInfo">
<short>Pointer to <link id="TSysInfo"/> record.</short>
</element>

<!-- function Visibility: default -->
<element name="SysCall">
<short>Execute system call.</short>
<descr>
<var>SysCall</var> can be used to execute a direct system call.
The call parameters must be encoded in <var>regs</var> and the call number
must be specified by <var>callnr</var>. The call result is returned, and any
modified registers are in <var>regs</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SysCallregs"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tzdaylight">
<short>Indicates whether daylight savings time is active.</short>
</element>

<!-- variable Visibility: default -->
<element name="tzseconds">
<short>Seconds west of GMT</short>
</element>

<!-- variable Visibility: default -->
<element name="tzname">
<short>Timezone name.</short>
</element>

<!-- function Visibility: default -->
<element name="SetTime">
<short>Set the current system time.</short>
<descr>
<p>
<var>SetTime</var> sets the system time to <var>hour</var>, <var>min</var>,
<var>Sec</var>. This is the kernel time, so it is in GMT. The date is not
touched. The function returns <var>True</var> if the call was executed corretly, 
<var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Errors are returned in <link id="LinuxError"/>
</errors>
<seealso>
<link id="GetTime"/>
<link id="SetDate"/>
<link id="SetDateTime"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetDate">
<short>Set the current system date.</short>
<descr>
<p>
<var>SetDate</var> sets the system date to <var>year</var>, <var>month</var>,
<var>day</var>. This is the kernel date, so it is in GMT. The time is not
touched. The function returns <var>True</var> if the call was executed 
corretly, <var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Errors are returned in <link id="LinuxError"/>
</errors>
<seealso>
<link id="GetDate"/>
<link id="SetTime"/>
<link id="SetDateTime"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetDateTime">
<short>Set the current system date and time</short>
<descr>
<p>
<var>SetDate</var> sets the system date and time to <var>year</var>,
<var>month</var>, <var>day</var>, <var>hour</var>, <var>min</var>, <var>Sec</var>.
This is the kernel date/time, so it is in GMT. The time is not
touched. The function returns <var>True</var> if the call was executed
corretly, <var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Errors are returned in <link id="LinuxError"/>
</errors>
<seealso>
<link id="SetDate"/>
<link id="SetTime"/>
<link id="GetDateTime"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ExitProcess">
<short>Exit the current process</short>
<descr>
<p>
<var>ExitProcess</var> exits the currently running process, and report
<var>Val</var> as the exit status.
</p>
<remark>
If this call is executed, the normal unit finalization code will not be
executed. This may lead to unexpected errors and stray files on your system.
It is therefore recommended to use the <var>Halt</var> call instead.
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Fork"/>
<link id="ExecVE"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WaitProcess">
<short>Wait for process to terminate.</short>
<descr>
<p>
<var>WaitProcess</var> waits for process <var>PID</var> to exit.
<var>WaitProcess</var> is equivalent to the <link id="WaitPID"/> call:
</p>
<code>
WaitPid(PID,@result,0)
</code>
<p>
Handles of Signal interrupts (errno=EINTR), and returns the Exitcode of 
Process <var>PID</var> (>=0) or -Status if it was terminated
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="WaitPID"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WEXITSTATUS">
<short>Extract the exit status from the <link id="WaitPID"/> result.</short>
<descr>
<var>WEXITSTATUS</var> can be used to extract the exit status from
<var>Status</var>, the result of the <link id="WaitPID"/> call.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WTERMSIG">
<short>Return the signal that caused a process to exit.</short>
<descr>
<var>WTERMSIG</var> extracts from <var>Status</var> the signal number which
caused the process to exit.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WSTOPSIG">
<short>Return the exit code from the process.</short>
<descr>
<var>WSTOPSIG</var> is an alias for <link id="WEXITSTATUS"/>.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WIFEXITED">
<short>Check whether the process exited normally</short>
<descr>
<var>WIFEXITED</var> checks <var>Status</var> and returns <var>True</var> if
the status indicates that the process terminated normally, i.e. was not
stopped by a signal.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WIFSTOPPED">
<short>Check whether the process is currently stopped.</short>
<descr>
<var>WIFSTOPPED</var> checks <var>Status</var> and returns <var>true</var>
if the process is currently stopped. This is only possible if WUNTRACED was
specified in the options of <link id="WaitPID"/>.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WIFSIGNALED">
<short>Check whether the process was exited by a signal.</short>
<descr>
<var>WIFSIGNALED</var> returns <var>True</var> if <var>Status</var>
indicates that the process exited because it received a signal.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="W_EXITCODE">
<short>Construct an exit status based on an return code and signal.</short>
<descr>
<var>W_EXITCODE</var> combines <var>ReturnCode</var> and <var>Signal</var>
to a status code fit for <var>WaitPid</var>.
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_STOPCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="W_STOPCODE">
<short>Construct an exit status based on a signal.</short>
<descr>
<var>W_STOPCODE</var> constructs an exit status based on 
<var>Signal</var>, which will cause <link id="WIFSIGNALED"/> to return
<var>True</var>
</descr>
<seealso>
<link id="WaitPID"/>
<link id="WaitProcess"/>
<link id="WTERMSIG"/>
<link id="WSTOPSIG"/>
<link id="WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="WEXITSTATUS"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="MAP_GROWSDOWN">
<short><link id="MMap"/> option: Memory grows downward (like a stack)</short>
</element>

<!-- constant Visibility: default -->
<element name="MAP_DENYWRITE">
<short><link id="MMap"/> option: Ignored.</short>
</element>

<!-- constant Visibility: default -->
<element name="MAP_EXECUTABLE">
<short><link id="MMap"/> option: Ignored.</short>
</element>

<!-- constant Visibility: default -->
<element name="MAP_LOCKED">
<short><link id="MMap"/> option: lock the pages in memory.</short>
</element>

<!-- constant Visibility: default -->
<element name="MAP_NORESERVE">
<short><link id="MMap"/> option: Do not reserve swap pages for this memory.</short>
</element>

<!-- record type Visibility: default -->
<element name="tmmapargs">
<short>Record containing mmap args.</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.address">
<short>Address pointer</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.size">
<short>Size of region.</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.prot">
<short>Memory protection flags</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.flags">
<short>Flags</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.fd">
<short>File descriptor</short>
</element>

<!-- variable Visibility: default -->
<element name="tmmapargs.offset">
<short>Offset: Multiple of page size</short>
</element>

<!-- function Visibility: default -->
<element name="IoPL">
<short>Set I/O privilege level</short>
<descr>
<var>IoPL</var> sets the I/O privilige level. It is intended for
completeness only, one should normally not use it.
</descr>
</element>

<element name="Sh">
<short>Signal handler</short>
</element>

<!-- variable Visibility: default -->
<element name="Sa">
<short>Sigaction handler</short>
</element>

<!-- variable Visibility: default --> 
<element name="SigActionRec.Sh">
<short>Signal handler</short>
</element>

<!-- variable Visibility: default -->
<element name="SigActionRec.Sa">
<short>Sigaction handler</short>
</element>

</module>
</package>
</fpdoc-descriptions>
