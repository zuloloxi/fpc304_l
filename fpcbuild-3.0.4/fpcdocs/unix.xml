<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="rtl">

<!--
  ====================================================================
    Unix
  ====================================================================
-->

<module name="Unix">
<short>Extended Unix functionality.</short>
<descr>
</descr>

<!-- unresolved type reference Visibility: default -->
<element name="UnixUtil">
<short>Various unit utility routines.</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="BaseUnix">
<short>Basic Unix functionality.</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="UnixType">
<short>Basic Unix types.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cInt8">
<short>C type: 8 bits sized, signed integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cUInt8">
<short>C type: 8 bits sized, unsigned integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cUInt16">
<short>C type: 16 bits sized, unsigned integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cInt16">
<short>C type: 16 bits sized, signed integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cInt32">
<short>C type: 32 bits sized, signed integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cUInt32">
<short>C type: 32 bits sized, unsigned integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cInt64">
<short>C type: 64 bits sized, signed integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cUInt64">
<short>C type: 64 bits sized, unsigned integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cuchar">
<short>C type: unsigned character</short>
</element>

<!-- alias type Visibility: default -->
<element name="cInt">
<short>C type: integer (natural size)</short>
</element>

<!-- alias type Visibility: default -->
<element name="cUInt">
<short>C type: unsigned integer (natural size)</short>
</element>

<!-- alias type Visibility: default -->
<element name="cLong">
<short>C type: long signed integer (double sized)</short>
</element>

<!-- alias type Visibility: default -->
<element name="cuLong">
<short>C type: long unsigned integer (double sized)</short>
</element>

<!-- alias type Visibility: default -->
<element name="cshort">
<short>C type: short signed integer (half sized)</short>
</element>

<!-- alias type Visibility: default -->
<element name="cushort">
<short>C type: short unsigned integer (half sized)</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcInt">
<short>Pointer to <link id="cInt"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcUInt">
<short>Pointer to <link id="cUInt"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcLong">
<short>Pointer to <link id="cLong"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pculong">
<short>Pointer to <link id="cuLong"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcshort">
<short>Pointer to <link id="cShort"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcushort">
<short>Pointer to <link id="cuShort"/> type.</short>
</element>


<!-- pointer type Visibility: default -->
<element name="pcint8">
<short>Pointer to 8-bits signed integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcuint8">
<short>Pointer to 8-bits unsigned integer type</short>
</element>

<!-- alias type Visibility: default -->
<element name="cschar">
<short>Signed character type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcschar">
<short>Pointer to signed character type</short>
<descr>
Pointer to character type <link id="cschar"/>.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcint16">
<short>Pointer to 16-bit signed integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcuint16">
<short>Pointer to 16-bit unsigned integer type</short>
</element>

<!-- alias type Visibility: default -->
<element name="csshort">
<short>Short signed integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcsshort">
<short>Pointer to short signed integer type</short>
<descr>
Pointer to short signed integer type <link id="csshort"/>
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcint32">
<short>Pointer to signed 32-bit integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcuint32">
<short>Pointer to unsigned 32-bit integer type</short>
</element>

<!-- alias type Visibility: default -->
<element name="csint">
<short>Signed integer</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcsint">
<short>Pointer to signed integer</short>
<descr>
Pointer to signed integer type <link id="csint"/>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="csigned">
<short>Signed integer</short>
<descr>
<var>csigned</var> is an alias for <link id="cint"/>.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcsigned">
<short>Pointer to signed integer</short>
<descr>
Pointer to signed integer type <link id="csigned"/>.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcint64">
<short>Pointer to signed 64-bit integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcuint64">
<short>Pointer to unsigned 64-bit integer type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pclonglong">
<short>Pointer to longlong type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="cslonglong">
<short>Signed longlong type</short>
<descr>
<var>cslonglong</var> is an alias for <link id="clonglong"/>.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcslonglong">
<short>Pointer to Signed longlong type</short>
<descr>
Pointer to Signed longlong type <link id="cslonglong"/>
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pculonglong">
<short>Unsigned longlong type</short>
</element>

<!-- alias type Visibility: default -->
<element name="cbool">
<short>Boolean type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcbool">
<short>Pointer to boolean type</short>
<descr>
Pointer to boolean type <link id="cbool"/>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="cslong">
<short>Signed long</short>
<descr>
The size is CPU dependent.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pcslong">
<short>Pointer to signed long</short>
<descr>
Pointer ot the signed long <link id="cslong"/>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="clongdouble">
<short>Long double</short>
<descr>
Usually translates to an extended, but is CPU dependent.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pclongdouble">
<short>Pointer to long double</short>
<descr>
Pointer to the long double type <link id="clongdouble"/>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="dev_t">
<short>Device descriptor type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TDev">
<short>Alias for <link id="dev_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pDev">
<short>Pointer to <link id="TDev"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="gid_t">
<short>Group ID type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TGid">
<short>Alias for <link id="gid_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pGid">
<short>Pointer to <link id="TGid"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ino_t">
<short>Inode type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TIno">
<short>Alias for <link id="ino_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pIno">
<short>Pointer to <link id="TIno"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="mode_t">
<short>Inode mode type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TMode">
<short>Alias for <link id="mode_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pMode">
<short>Pointer to <link id="TMode"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="nlink_t">
<short>Number of links type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TnLink">
<short>Alias for <link id="nlink_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pnLink">
<short>Pointer to <link id="TnLink"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="off_t">
<short>Offset type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TOff">
<short>Alias for <link id="off_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pOff">
<short>Pointer to <link id="TOff"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pid_t">
<short>Process ID type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TPid">
<short>Alias for <link id="pid_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pPid">
<short>Pointer to <link id="TPid"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="size_t">
<short>Size specification type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TSize">
<short>Alias for <link id="size_t"/> type</short>
</element>

<!-- alias type Visibility: default -->
<element name="pSize">
<short>Pointer to <link id="TSize"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ssize_t">
<short>Small size type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TsSize">
<short>Alias for <link id="ssize_t"/> type</short>
</element>

<!-- alias type Visibility: default -->
<element name="psSize">
<short>Pointer to <link id="TsSize"/> type</short>
</element>

<!-- alias type Visibility: default -->
<element name="uid_t">
<short>User ID type</short>
</element>

<!-- alias type Visibility: default -->
<element name="TUid">
<short>Alias for <link id="uid_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pUid">
<short>Pointer to <link id="TUid"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="clock_t">
<short>Clock ticks type</short>
</element>

<!-- alias type Visibility: default -->
<element name="TClock">
<short>Alias for <link id="clock_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pClock">
<short>Pointer to <link id="TClock"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="time_t">
<short>Time span type</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTime">
<short>Alias for <link id="TTime"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pTime">
<short>Pointer to <link id="TTime"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ptime_t">
<short>Pointer to <link id="time_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="socklen_t">
<short>Socket address length type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TSocklen">
<short>Alias for <link id="socklen_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pSocklen">
<short>Pointer to <link id="TSockLen"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="timeval">
<short>Time specification type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ptimeval">
<short>Pointer to <link id="timeval"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TTimeVal">
<short>Alias for <link id="timeval"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="timespec">
<short>Short time specification type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="ptimespec">
<short>Pointer to <link id="timespec"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="Ttimespec">
<short>Alias for <link id="TimeSpec"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pthread_mutex_t">
<short>Thread mutex type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pthread_cond_t">
<short>Thread conditional variable type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pthread_t">
<short>Posix thread type.</short>
</element>

<!-- constant Visibility: default -->
<element name="ARG_MAX">
<short>Maximum number of arguments to a program.</short>
</element>

<!-- constant Visibility: default -->
<element name="NAME_MAX">
<short>Maximum filename length.</short>
</element>

<!-- constant Visibility: default -->
<element name="PATH_MAX">
<short>Maximum pathname length.</short>
</element>

<!-- constant Visibility: default -->
<element name="SYS_NMLN">
<short>Max system name length.</short>
</element>

<!-- constant Visibility: default -->
<element name="SIG_MAXSIG">
<short>Maximum system signal number.</short>
</element>


<!-- constant Visibility: default -->
<element name="Prio_Process">
<short><link id="#rtl.baseunix.fpGetPriority"/> option: Get process priority.</short>
</element>

<!-- constant Visibility: default -->
<element name="Prio_PGrp">
<short><link id="#rtl.baseunix.fpGetPriority"/> option: Get process group priority.</short>
</element>

<!-- constant Visibility: default -->
<element name="Prio_User">
<short><link id="#rtl.baseunix.fpGetPriority"/> option: Get user priority.</short>
</element>

<!-- constant Visibility: default -->
<element name="Seek_set">
<short>Seek option: Set absolute position.</short>
</element>

<!-- constant Visibility: default -->
<element name="Seek_Cur">
<short>Seek option: Set position relative to current position.</short>
</element>

<!-- constant Visibility: default -->
<element name="Seek_End">
<short>Seek option: Set position relative to end of file.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Accmode">
<short>Bitmask to determine access mode in open flags.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_RdOnly">
<short>File open mode: Read only</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_WrOnly">
<short>File open mode: Write only</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_RdWr">
<short>File open mode: Read/Write</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Creat">
<short>File open mode: Create if file does not yet exist.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Excl">
<short>File open mode: Open exclusively</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NoCtty">
<short>File open mode: No TTY control.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Trunc">
<short>File open mode: Truncate file to length 0</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Append">
<short>File open mode: Append to file</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NonBlock">
<short>File open mode: Open in non-blocking mode</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NDelay">
<short>File open mode: Alias for <link id="Open_NonBlock"/></short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Sync">
<short>File open mode: Write to disc at once</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Direct">
<short>File open mode: Minimize caching effects</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_LargeFile">
<short>File open mode: Open for 64-bit I/O</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_Directory">
<short>File open mode: File must be directory.</short>
</element>

<!-- constant Visibility: default -->
<element name="Open_NoFollow">
<short>File open mode: Fail if file is symbolic link.</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_NoHang">
<short><link id="#rtl.baseunix.fpWaitPID"/>: Do not wait</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_UnTraced">
<short><link id="#rtl.baseunix.fpWaitPID"/>: Also report stopped but untraced processes</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_Any">
<short><link id="#rtl.baseunix.fpWaitPID"/>: Wait on any process</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_MyPGRP">
<short><link id="#rtl.baseunix.fpWaitPID"/>: Wait processes from current process group</short>
</element>

<!-- constant Visibility: default -->
<element name="Wait_Clone">
<short><link id="#rtl.baseunix.fpWaitPID"/>: Wait on clone processes only.</short>
</element>


<element name="STAT_IFMT">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: File type bit mask</short>
</element>
<element name="STAT_IFSOCK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Socket</short>
</element>
<element name="STAT_IFLNK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Link</short>
</element>
<element name="STAT_IFREG">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Regular file</short>
</element>
<element name="STAT_IFBLK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Block device</short>
</element>
<element name="STAT_IFDIR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Directory</short>
</element>
<element name="STAT_IFCHR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Character device</short>
</element>
<element name="STAT_IFIFO">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: FIFO</short>
</element>
<element name="STAT_ISUID">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: UID bit set</short>
</element>
<element name="STAT_ISGID">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: GID bit set</short>
</element>
<element name="STAT_ISVTX">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Sticky bit set</short>
</element>
<element name="STAT_IRWXO">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Other permission bits mask</short>
</element>
<element name="STAT_IROTH">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Other read permission</short>
</element>
<element name="STAT_IWOTH">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Other write permission</short>
</element>
<element name="STAT_IXOTH">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Others execute permission</short>
</element>
<element name="STAT_IRWXG">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Group permission bits mask</short>
</element>
<element name="STAT_IRGRP">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Group read permission</short>
</element>
<element name="STAT_IWGRP">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Group write permission</short>
</element>
<element name="STAT_IXGRP">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Others execute permission</short>
</element>
<element name="STAT_IRWXU">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Owner permission bits mask</short>
</element>
<element name="STAT_IRUSR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Owner read permission</short>
</element>
<element name="STAT_IWUSR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Owner write permission</short>
</element>
<element name="STAT_IXUSR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Others execute permission</short>
</element>

<element name="fs_old_ext2">
<short>File system type (<link id="TStatFS"/>): (ext2) Old second extended</short>
</element>
<element name="fs_ext2">
<short>File system type (<link id="TStatFS"/>): (ext2) Second extended</short>
</element>
<element name="fs_ext">
<short>File system type (<link id="TStatFS"/>): (ext) Extended</short>
</element>
<element name="fs_iso">
<short>File system type (<link id="TStatFS"/>): ISO 9660</short>
</element>
<element name="fs_minix">
<short>File system type (<link id="TStatFS"/>): Minix</short>
</element>
<element name="fs_minix_30">
<short>File system type (<link id="TStatFS"/>): Minix 3.0</short>
</element>
<element name="fs_minux_V2">
<short>File system type (<link id="TStatFS"/>): Minix V2</short>
</element>
<element name="fs_msdos">
<short>File system type (<link id="TStatFS"/>): MSDOS (FAT)</short>
</element>
<element name="fs_nfs">
<short>File system type (<link id="TStatFS"/>): NFS</short>
</element>
<element name="fs_proc">
<short>File system type (<link id="TStatFS"/>): PROC fs</short>
</element>
<element name="fs_xia">
<short>File system type (<link id="TStatFS"/>): XIA</short>
</element>

<!-- constant Visibility: default -->
<element name="IOCtl_TCGETS">
<short>IOCTL call number: get Terminal Control settings</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_NOCLDSTOP">
<short>Sigaction options: Do not receive notification when child processes stop</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_NOCLDWAIT">
<short>Sigaction options: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_SIGINFO">
<short>Sigaction options: The signal handler takes 3 arguments, not one.</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_SHIRQ">
<short>Sigaction options: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_STACK">
<short>Sigaction options: Call the signal handler on an alternate signal stack.</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_RESTART">
<short>Sigaction options: Provide behaviour compatible with BSD signal semantics</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_INTERRUPT">
<short>Sigaction options: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_NOMASK">
<short>Sigaction options: Do not prevent the signal from being received when it is handled.</short>
</element>

<!-- constant Visibility: default -->
<element name="SA_ONESHOT">
<short>Sigaction options: Restore the signal action to the default state.</short>
</element>

<element name="SIG_BLOCK">
<short>Sigprocmask flags: Add signals to the set of blocked signals.</short>
</element>
<element name="SIG_UNBLOCK">
<short>Sigprocmask flags: Remove signals from the set set of blocked signals.</short>
</element>
<element name="SIG_SETMASK">
<short>Sigprocmask flags: Set of blocked signals is given.</short>
</element>
<element name="SIG_DFL">
<short>Signal handler: Default signal handler</short>
</element>
<element name="SIG_IGN">
<short>Signal handler: Ignore signal</short>
</element>
<element name="SIG_ERR">
<short>Signal handler: error</short>
</element>

<element name="SIGHUP">
<short>Signal: HUP (Hangup)</short>
</element>
<element name="SIGINT">
<short>Signal: INT (Interrupt)</short>
</element>
<element name="SIGQUIT">
<short>Signal: QUIT</short>
</element>
<element name="SIGILL">
<short>Signal: ILL (Illegal instruction)</short>
</element>
<element name="SIGTRAP">
<short>Signal: TRAP (Trace trap)</short>
</element>
<element name="SIGABRT">
<short>Signal: ABRT (Abort)</short>
</element>
<element name="SIGIOT">
<short>Signal: IOT (IOT trap)</short>
</element>
<element name="SIGBUS">
<short>Signal: BUS (bus error)</short>
</element>
<element name="SIGFPE">
<short>Signal: FPE (Floating point error)</short>
</element>
<element name="SIGKILL">
<short>Signal: KILL (unblockable)</short>
</element>
<element name="SIGUSR1">
<short>Signal: USR1 (User-defined signal 1)</short>
</element>
<element name="SIGSEGV">
<short>Signal: SEGV (Segmentation violation)</short>
</element>
<element name="SIGUSR2">
<short>Signal: USR2 (User-defined signal 2)</short>
</element>
<element name="SIGPIPE">
<short>Signal: PIPE (Broken pipe</short>
</element>
<element name="SIGALRM">
<short>Signal: ALRM (Alarm clock)</short>
</element>
<element name="SIGTERM">
<short>Signal: TERM (Terminate)</short>
</element>
<element name="SIGSTKFLT">
<short>Signal: STKFLT (Stack Fault)</short>
</element>
<element name="SIGCHLD">
<short>Signal: CHLD (child status changed)</short>
</element>
<element name="SIGCONT">
<short>Signal: CONT (Continue)</short>
</element>
<element name="SIGSTOP">
<short>Signal: STOP (Stop, unblockable)</short>
</element>
<element name="SIGTSTP">
<short>Signal: TSTP (keyboard stop)</short>
</element>

<element name="SIGTTIN">
<short>Signal: TTIN (Terminal input, background)</short>
</element>
<element name="SIGTTOU">
<short>Signal: TTOU (Terminal output, background)</short>
</element>
<element name="SIGURG">
<short>Signal: URG (Socket urgent condition)</short>
</element>
<element name="SIGXCPU">
<short>Signal: XCPU (CPU limit exceeded)</short>
</element>
<element name="SIGXFSZ">
<short>Signal: XFSZ (File size limit exceeded)</short>
</element>
<element name="SIGVTALRM">
<short>Signal: VTALRM (Virtual alarm clock)</short>
</element>
<element name="SIGPROF">
<short>Signal: PROF (Profiling alarm)</short>
</element>
<element name="SIGWINCH">
<short>Signal: WINCH (Window/Terminal size change)</short>
</element>
<element name="SIGIO">
<short>Signal: IO (I/O operation possible)</short>
</element>
<element name="SIGPOLL">
<short>Signal: POLL (Pollable event)</short>
</element>
<element name="SIGPWR">
<short>Signal: PWR (power failure restart)</short>
</element>
<element name="SIGUNUSED">
<short>Signal: Unused</short>
</element>

<!-- constant Visibility: default -->
<element name="SI_PAD_SIZE">
<short>Signal information pad size.</short>
</element>

<element name="tfpreg">
<short>Record describing floating point register in signal handler.</short>
</element>
<element name="tfpreg.significand">
<short>Decimal part of floating point value</short>
</element>
<element name="tfpreg.exponent">
<short>Exponent of floating point value</short>
</element>

<element name="pfpstate">
<short>Pointer to <link id="tfpstate"/> record.</short>
</element>
<element name="tfpstate">
<short>Record describing floating point unit in signal handler.</short>
</element>
<element name="tfpstate.cw">
<short></short>
</element>
<element name="tfpstate.sw">
<short></short>
</element>
<element name="tfpstate.tag">
<short></short>
</element>
<element name="tfpstate.ipoff">
<short></short>
</element>
<element name="tfpstate.cssel">
<short></short>
</element>
<element name="tfpstate.dataoff">
<short></short>
</element>
<element name="tfpstate.datasel">
<short></short>
</element>
<element name="tfpstate.st">
<short></short>
</element>
<element name="tfpstate.status">
<short></short>
</element>


<element name="SigSet">
<short>Signal set type</short>
</element>

<!-- alias type Visibility: default -->
<element name="sigset_t">
<short>Signal set type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSigSet">
<short>Pointer to <link id="SigSet"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="psigset_t">
<short>Pointer to <link id="sigset_t"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TSigSet">
<short>Alias for <link id="SigSet"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSigInfoRec">
<short>Pointer to <link id="SigInfoRec"/> record type.</short>
</element>

<!-- record type Visibility: default -->
<element name="SigInfoRec">
<short>Record containing signal information.</short>
</element>

<!-- variable Visibility: default -->
<element name="SigInfoRec.si_signo">
<short>Signal number.</short>
</element>

<!-- variable Visibility: default -->
<element name="SigInfoRec.si_errno">
<short>?</short>
</element>

<!-- variable Visibility: default -->
<element name="SigInfoRec.si_code">
<short>?</short>
</element>

<!-- procedure type Visibility: default -->
<element name="SignalHandler">
<short>Simple signal handler prototype</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSignalHandler">
<short>Pointer to <link id="SignalHandler"/> type.</short>
</element>

<element name="SignalRestorer">
<short>Signal restorer function prototype</short>
</element>
<element name="PSignalrestorer">
<short>Pointer to <link id="SignalRestorer"/> type</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TSigAction">
<short>Extended signal handler prototype.</short>
</element>

<!-- record type Visibility: default -->
<element name="SigActionRec">
<short>Record used in <link id="#rtl.baseunix.fpSigAction"/> call.</short>
</element>
<element name="SigActionRec.sa_handler">
<short>Funcion called when signal is triggered.</short>
</element>
<element name="SigActionRec.Sa_Mask">
<short>Signal mask.</short>
</element>
<element name="SigActionRec.SA_FLAGS">
<short>Flags for SigAction</short>
</element>
<element name="SigActionRec.SA_RESTORER">
<short>Obsolete, don't use</short>
</element>

<!-- alias type Visibility: default -->
<element name="TSigActionRec">
<short>Alias for <link id="SigActionRec"/> record type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSigActionRec">
<short>Pointer to <link id="SigActionRec"/> record type.</short>
</element>

<element name="S_IFMT">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: File type bit mask</short>
</element>
<element name="S_IFSOCK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Socket</short>
</element>
<element name="S_IFLNK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Link</short>
</element>
<element name="S_IFREG">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Regular file</short>
</element>
<element name="S_IFBLK">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Block device</short>
</element>
<element name="S_IFDIR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Directory</short>
</element>
<element name="S_IFCHR">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: Character device</short>
</element>
<element name="S_IFIFO">
<short>File (<link id="#rtl.baseunix.stat"/> record) mode: FIFO</short>
</element>

<!-- constant Visibility: default -->
<element name="P_IN">
<short>Input file descriptor of pipe pair.</short>
</element>

<!-- constant Visibility: default -->
<element name="P_OUT">
<short>Output file descriptor of pipe pair.</short>
</element>


<element name="LOCK_SH">
<short><link id="FpFLock"/> Shared lock</short>
</element>
<element name="LOCK_EX">
<short><link id="FpFLock"/> Exclusive lock</short>
</element>
<element name="LOCK_UN">
<short><link id="FpFLock"/> unlock</short>
</element>
<element name="LOCK_NB">
<short><link id="FpFLock"/> Non-blocking operation</short>
</element>

<element name="PGlob">
<short>Pointer to <link id="TGlob"/> record.</short>
</element>
<element name="TGlob">
<short>Record containing one entry in the result of <link id="Glob"/></short>
</element>
<element name="TGlob.Name">
<short>Filename matching the search criteria</short>
</element>
<element name="TGlob.Next">
<short>Next element in result of <var>Glob</var> call.</short>
</element>

<element name="Tpipe">
<short>Array describing a pipe pair of filedescriptors.</short>
</element>

<!-- variable Visibility: default -->
<element name="tzdaylight">
<short>Indicates whether daylight savings time is active.</short>
</element>

<!-- variable Visibility: default -->
<element name="tzname">
<short>Timezone name.</short>
</element>



<!-- enumeration type Visibility: default -->
<element name="TFSearchOption">
<short>Describes the search strategy used by <link id="FSearch"/></short>
<seealso>
<link id="FSearch"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFSearchOption.NoCurrentDirectory">
<short>Do not search the current directory unless it is specified in the search path.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFSearchOption.CurrentDirectoryFirst">
<short>Search the current directory first, before all directories in the search path.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFSearchOption.CurrentDirectoryLast">
<short>Search the current directory last, after all directories in the search path</short>
</element>

<!-- procedure Visibility: default -->
<element name="GetLocalTimezone">
<short>Return local timzeone information</short>
<descr>
<p>
<var>GetLocalTimeZone</var> returns the local timezone information. It also
initializes the <var>TZSeconds</var> variable, which is used to correct the epoch time
to local time.
</p>
<p>
There should never be any need to call this function directly. It is called by the
initialization routines of the Linux unit.
</p>
</descr>
<seealso>
<link id="GetTimezoneFile"/>
<link id="ReadTimezoneFile"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReadTimezoneFile">
<short>Read the timezone file and initialize time routines</short>
<descr>
<p>
<var>ReadTimeZoneFile</var> reads the timezone file <var>fn</var> and initializes
the local time routines based on the information found there.
</p>
<p>
There should be no need to call this function. The initialization routines
of the <file>linux</file> unit call this routine at unit startup.
</p>
</descr>
<errors> 
None.
</errors>
<seealso>
<link id="GetTimezoneFile"/>
<link id="GetLocalTimezone"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetTimezoneFile">
<short>Return name of timezone information file</short>
<descr>
<p>
<var>GetTimezoneFile</var> returns the location of the current timezone file.
The location of file is determined as follows:
</p>
<ol>
<li>If <file>/etc/timezone</file> exists, it is read, and the contents of this
file is returned. This should work on Debian systems.</li>
<li>If <file>/usr/lib/zoneinfo/localtime</file> exists, then it is returned.
(this file is a symlink to the timezone file on SuSE systems)</li>
<li>If <file>/etc/localtime</file> exists, then it is returned. 
(this file is a symlink to the timezone file on RedHat systems)</li>
</ol>
</descr>
<errors>
If no file was found, an empty string is returned.
</errors>
<seealso>
<link id="ReadTimezoneFile"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetEpochTime">
<short>Return the current Unix time</short>
<descr>
<p>
returns the number of seconds since 00:00:00 gmt, january 1, 1970.
it is adjusted to the local time zone, but not to DST.
</p>
</descr>
<errors>
no errors
</errors>
<example file="unixex/ex1"/>
</element>

<!-- procedure Visibility: default -->
<element name="GetTime">
<short>Return current system time</short>
<descr>
<p>
Returns the current time of the day, adjusted to local time.
Upon return, the parameters are filled with
</p>
<dl>
<dt>hour</dt><dd>Hours since 00:00 today.</dd>
<dt>min</dt><dd>minutes in current hour.</dd>
<dt>sec</dt><dd>seconds in current minute.</dd>
<dt>sec100</dt><dd>hundreds of seconds in current second.</dd>
<dt>msec</dt><dd>milliseconds in current second.</dd>
<dt>usec</dt><dd>microseconds in current second.</dd>
</dl>
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="GetDate"/>
</seealso>
<example file="unixex/ex5"/>
</element>

<!-- procedure Visibility: default -->
<element name="GetDate">
<short>Return the system date</short>
<descr>
<p>
Returns the current date. On return, the parameters are filled with
</p>
<dl>
<dt>year</dt><dd>Year (4 digits).</dd>
<dt>month</dt><dd>Month of the year.</dd>
<dt>day</dt><dd>Day of the month.</dd>
</dl>
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="SetTime"/>
</seealso>
<example file="unixex/ex6"/>
</element>

<!-- procedure Visibility: default -->
<element name="GetDateTime">
<short>Return system date and time</short>
<descr>
Returns the current date and time. The time is corrected for the local time
zone. This procedure is equivalent to the <link id="GetDate"/> and <var>GetTime</var>
calls.
</descr>
<errors>
None
</errors>
<seealso>
<link id="GetEpochTime"/>
<link id="GetDate"/> 
<link id="SetDate"/>
<link id="SetTime"/>
</seealso>
<example file="unixex/ex60"/>
</element>

<!-- function Visibility: default -->
<element name="SetTime">
<short>Set the current system time.</short>
<descr>
<p>
<var>SetTime</var> sets the system time to <var>hour</var>, <var>min</var>,
<var>Sec</var>. This is the kernel time, so it is in GMT. The date is not
touched. The function returns <var>True</var> if the call was executed corretly, 
<var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Extended error information can be retrieved with <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link>
</errors>
<seealso>
<link id="SetDate"/>
<link id="GetDate"/>
<link id="SetDateTime"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetDate">
<short>Set the current system date.</short>
<descr>
<p>
<var>SetDate</var> sets the system date to <var>year</var>, <var>month</var>,
<var>day</var>. This is the kernel date, so it is in GMT. The time is not
touched. The function returns <var>True</var> if the call was executed 
corretly, <var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Extended error information can be retrieved with <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link>
</errors>
<seealso>
<link id="GetDate"/>
<link id="SetTime"/>
<link id="SetDateTime"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetDateTime">
<short>Set the current system date and time</short>
<descr>
<p>
<var>SetDate</var> sets the system date and time to <var>year</var>,
<var>month</var>, <var>day</var>, <var>hour</var>, <var>min</var>, <var>Sec</var>.
This is the kernel date/time, so it is in GMT. The time is not
touched. The function returns <var>True</var> if the call was executed
corretly, <var>False</var> otherwise.
</p>
<remark>
You must be root to execute this call.
</remark>
</descr>
<errors>
Extended error information can be retrieved with <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link>
</errors>
<seealso>
<link id="SetDate"/>
<link id="SetTime"/>
<link id="GetDate"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CreateShellArgV">
<short>Create an array of null-terminated strings</short>
<descr>
<p>
<var>CreateShellArgV</var> creates an array of 3 <var>PChar</var> pointers that can
be used as arguments to <var>ExecVE</var> the first elements in the array 
will contain  <var>/bin/sh</var>, the second will contain <var>-c</var>, and the third
will contain <var>prog</var>.
</p>
<p>
The function returns a pointer to this array, of type <var>PPChar</var>.
</p>
<p>
The memory allocated for the array can be disposed of with the <link id="FreeShellArgV"/> function.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="FreeShellArgV"/>
</seealso>
<example file="unixex/ex61"/>
</element>

<!-- procedure Visibility: default -->
<element name="FreeShellArgV">
<short>Frees the memory allocated by the <link id="CreateShellArgV"/> call.</short>
<descr>
<p>
<var>FreeShellArgV</var> frees the memory which was allocated by the
<link id="CreateShellArgV"/> call.
</p>
<p>
Do not attempt to free memory with this call which was allocated by some C
or other library, this will lead to memory corruption.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CreateShellArgV"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Execv">
<short>Execute process</short>
<descr>
<var>Execv</var> replaces the currently running program with the program, specified in
<var>path</var>.
It gives the program the options in <var>args</var>.
This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>execv</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex8"/>
</element>

<!-- function Visibility: default -->
<element name="Execvp">
<short>Execute process, search path</short>
<descr>
<p>
<var>Execvp</var> replaces the currently running program with the program, specified in
<var>path</var>. The executable in <var>path</var> is searched in the
contents of the <var>PATH</var> environment variable, if it isn't 
an absolute filename. 
</p>
<p>
It gives the program the options in <var>args</var>. 
This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>execvp</var> does not return.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="Execv"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex9"/>
</element>

<element name="Execl">
<short>Execute process (using argument list)</short>
<descr>
<var>Execl</var> replaces the currently running program with the program, specified in
<var>Todo</var>. <var>Todo</var> is split into a command and it's options.
The executable in <var>Todo</var> is NOT searched in the path.
The current environment is passed to the program.
On success, <var>execl</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt>
<dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt>
<dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execlp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex10"/>
</element>

<!-- function Visibility: default -->
<element name="Execle">
<short>Execute process (using argument list, environment)</short>
<descr>
<p>
<var>Execle</var> replaces the currently running program with the program, specified in
<var>Todo</var>. <var>Todo</var> is split into a command and it's options.
The executable in <var>Todo</var> is searched in the path, if it isn't
an absolute filename.
The environment in <var>ep</var> is passed to the program.
On success, <var>execle</var> does not return.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execl"/>
<link id="Execlp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex11"/>
</element>

<!-- function Visibility: default -->
<element name="Execlp">
<short>Execute process (using argument list, environment; search path)</short>
<descr>
<var>Execlp</var> replaces the currently running program with the program, specified in
<var>path</var>. Path is split into a command and it's options.
The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
The current environment is passed to the program.
On success, <var>execlp</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="Execv"/>
<link id="Execvp"/>
<link id="Execle"/>
<link id="Execl"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex12"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecLE">
<short>Execute process (using argument list, environment)</short>
<descr>
<p>
<var>FpExecLE</var> replaces the currently running program with the program, specified in
<var>PathName</var>. <var>S</var> is an array of command options.
The executable in <var>PathName</var> must be an absolute pathname.
The environment in <var>MyEnv</var> is passed to the program.
On success, <var>FpExecLE</var> does not return.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecv"/>
<link id="FpExecvp"/>
<link id="FpExecl"/>
<link id="FpExeclp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex11"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecL">
<short>Execute process (using argument list, environment)</short>
<descr>
<p>
<var>FpExecL</var> replaces the currently running program with the program, specified in
<var>PathName</var>. <var>S</var> is an array of command options.
The executable in <var>PathName</var> must be an absolute pathname.
The current process'  environment is passed to the program.
On success, <var>FpExecL</var> does not return.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt>
<dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt>
<dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecv"/>
<link id="FpExecvp"/>
<link id="FpExecle"/>
<link id="FpExeclp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex77"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecLP">
<short>Execute process (using argument list, environment; search path)</short>
<descr>
<var>FpExecLP</var> replaces the currently running program with the program, specified in
<var>PathName</var>. <var>S</var> is an array of command options.
The executable in <var>PathName</var> is searched in the path, if it isn't
an absolute filename.
The current environment is passed to the program.
On success, <var>FpExecLP</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel, or to split command line.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecv"/>
<link id="FpExecvp"/>
<link id="FpExecle"/>
<link id="FpExecl"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex76"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecV">
<short>Execute process</short>
<descr>
<var>FpExecV</var> replaces the currently running program with the program, specified in
<var>PathName</var>.
It gives the program the options in <var>args</var>.
This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>FpExecV</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecvp"/>
<link id="FpExecle"/>
<link id="FpExecl"/>
<link id="FpExeclp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex8"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecVP">
<short>Execute process, search path</short>
<descr>
<var>FpExecVP</var> replaces the currently running program with the program, specified in
<var>PathName</var>. The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
It gives the program the options in <var>args</var>. This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The current environment is passed to the program.
On success, <var>execvp</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecv"/>
<link id="FpExecle"/>
<link id="FpExecl"/>
<link id="FpExeclp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex79"/>
</element>

<!-- function Visibility: default -->
<element name="FpExecVPE">
<short>Execute process, search path using environment</short>
<descr>
<var>FpExecVP</var> replaces the currently running program with the program, specified in
<var>PathName</var>. The executable in <var>path</var> is searched in the path, if it isn't
an absolute filename.
It gives the program the options in <var>args</var>. This is a pointer to an array of pointers to null-terminated
strings. The last pointer in this array should be nil.
The environment in <var>Env</var> is passed to the program.
On success, <var>execvp</var> does not return.
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_eacces</dt>
<dd>File is not a regular file, or has no execute permission.
A compononent of the path has no search permission.</dd>
<dt>sys_eperm</dt><dd>The file system is mounted <i>noexec</i>.</dd>
<dt>sys_e2big</dt><dd>Argument list too big.</dd>
<dt>sys_enoexec</dt><dd>The magic number in the file is incorrect.</dd>
<dt>sys_enoent</dt><dd>The file does not exist.</dd>
<dt>sys_enomem</dt><dd>Not enough memory for kernel.</dd>
<dt>sys_enotdir</dt><dd>A component of the path is not a directory.</dd>
<dt>sys_eloop</dt><dd>The path contains a circular reference (via symlinks).</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
<link id="FpExecv"/>
<link id="FpExecle"/>
<link id="FpExecl"/>
<link id="FpExeclp"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
</seealso>
<example file="unixex/ex79"/>
</element>

<!-- function Visibility: default -->
<element name="Shell">
<short>Execute and feed command to system shell</short>
<descr>
<var>Shell</var> invokes the bash shell (<file>/bin/sh</file>), and feeds it the
command <var>Command</var> (using the <var>-c</var> option). The function then waits
for the command to complete, and then returns the exit
status of the command, or 127 if it could not complete the <link id="#rtl.baseunix.FpFork">FpFork</link>
or <link id="#rtl.baseunix.fpexecve">FpExecve</link> calls.
</descr>
<errors>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</errors>
<seealso>
<link id="POpen"/>
<link id="FpSystem"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
</seealso>
<example file="unixex/ex56"/>
</element>

<!-- function Visibility: default -->
<element name="fpSystem">
<short>Execute and feed command to system shell</short>
<descr>
<var>FpSystem</var> invokes the bash shell (<file>/bin/sh</file>), and feeds it the
command <var>Command</var> (using the <var>-c</var> option). The function then waits
for the command to complete, and then returns the exit
status of the command in wait(3) format, or 127 if it could not complete the <link id="#rtl.baseunix.FpFork">FpFork</link>
or <link id="#rtl.baseunix.fpexecve">FpExecve</link> calls.

To convert the return value of fpsystem to the real return value use
<link id="#rtl.baseunix.WEXITSTATUS">WEXITSTATUS()</link>.
</descr>
<errors>
Errors are reported in <link id="#rtl.baseunix.fpgetErrNo">(fpget)ErrNo</link>
</errors>
<seealso>
<link id="POpen"/>
<link id="#rtl.baseunix.FpFork">FpFork</link>
<link id="#rtl.baseunix.fpexecve">FpExecve</link>
</seealso>
<example file="unixex/ex80"/>
</element>

<!-- function Visibility: default -->
<element name="WaitProcess">
<short>Wait for process to terminate.</short>
<descr>
<p>
<var>WaitProcess</var> waits for process <var>PID</var> to exit.
<var>WaitProcess</var> is equivalent to the <link id="#rtl.baseunix.FpWaitPID"/> call:
</p>
<code>
FpWaitPid(PID,@result,0)
</code>
<p>
Handles of Signal interrupts (errno=EINTR), and returns the Exitcode of 
Process <var>PID</var> (>=0) or -Status if it was terminated
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="#rtl.baseunix.FpWaitPID"/>
<link id="#rtl.baseunix.WTERMSIG"/>
<link id="#rtl.baseunix.WSTOPSIG"/>
<link id="#rtl.baseunix.WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="#rtl.baseunix.WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="#rtl.baseunix.WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WIFSTOPPED">
<short>Check whether the process is currently stopped.</short>
<descr>
<var>WIFSTOPPED</var> checks <var>Status</var> and returns <var>true</var>
if the process is currently stopped. This is only possible if WUNTRACED was
specified in the options of <link id="#rtl.baseunix.FpWaitPID">FpWaitPID</link>.
</descr>
<seealso>
<link id="#rtl.baseunix.FpWaitPID"/>
<link id="WaitProcess"/>
<link id="#rtl.baseunix.WTERMSIG"/>
<link id="#rtl.baseunix.WSTOPSIG"/>
<link id="#rtl.baseunix.WIFEXITED"/>
<link id="#rtl.baseunix.WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="#rtl.baseunix.WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="W_EXITCODE">
<short>Construct an exit status based on an return code and signal.</short>
<descr>
<var>W_EXITCODE</var> combines <var>ReturnCode</var> and <var>Signal</var>
to a status code fit for <var>WaitPid</var>.
</descr>
<seealso>
<link id="#rtl.baseunix.FpWaitPID"/>
<link id="WaitProcess"/>
<link id="#rtl.baseunix.WTERMSIG"/>
<link id="#rtl.baseunix.WSTOPSIG"/>
<link id="#rtl.baseunix.WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="#rtl.baseunix.WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="W_STOPCODE"/>
<link id="#rtl.baseunix.WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="W_STOPCODE">
<short>Construct an exit status based on a signal.</short>
<descr>
<var>W_STOPCODE</var> constructs an exit status based on 
<var>Signal</var>, which will cause <link id="#rtl.baseunix.WIFSIGNALED">WIFSIGNALED</link> to return
<var>True</var>
</descr>
<seealso>
<link id="#rtl.baseunix.FpWaitPID"/>
<link id="WaitProcess"/>
<link id="#rtl.baseunix.WTERMSIG"/>
<link id="#rtl.baseunix.WSTOPSIG"/>
<link id="#rtl.baseunix.WIFEXITED"/>
<link id="WIFSTOPPED"/>
<link id="#rtl.baseunix.WIFSIGNALED"/>
<link id="W_EXITCODE"/>
<link id="#rtl.baseunix.WEXITSTATUS"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fsync">
<short>Synchronize file's kernel data with disk.</short>
<descr>
<p>
<var>Fsync</var> synchronizes the kernel data for file <var>fd</var> (the
cache) with the disk. The call will not return till all file data was
written to disk.
</p>
<p>
If the call was succesfull, 0 is returned. On failure, a nonzero value is
returned.
</p>
</descr>
<errors>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</errors>
<seealso>
<link id="FpFLock"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fpFlock">
<short>Lock a file (advisory lock)</short>
<descr>
<p>
<var>FpFLock</var> implements file locking. it sets or removes a lock on the file
<var>F</var>. F can be of type <var>Text</var> or <var>File</var>, or it can be a Linux
filedescriptor (a longint)
<var>Mode</var> can be one of the following constants :
</p>
<dl>
<dt>LOCK_SH</dt><dd>sets a shared lock.</dd>
<dt>LOCK_EX</dt><dd>sets an exclusive lock.</dd>
<dt>LOCK_UN</dt><dd>unlocks the file.</dd>
<dt>LOCK_NB</dt><dd>This can be OR-ed together with the other.
If this is done the application doesn't block when locking.
</dd>
</dl>
<p>
The function returns zero if successful, a nonzero return value indicates an
error.
</p>
</descr>
<errors>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</errors>
<seealso>
<link id="#rtl.baseunix.FpFcntl"/>
<link id="FSync"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fStatFS">
<short>Retrieve filesystem information from a file descriptor.</short>
<descr>
<p>
<var>fStatFS</var> returns in <var>Info</var> information about the filesystem
on which the file with file descriptor <var>fd</var> resides. 
<var>Info</var> is of type <link id="#rtl.unixtype.TStatfs">TStatFS</link>. 
</p>
<p>
The function returns zero if the call was succesful, a nonzero value is 
returned if the call failed.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_enotdir</dt><dd>A component of <var>Path</var> is not a directory.</dd>
<dt>sys_einval</dt><dd>Invalid character in <var>Path</var>.</dd>
<dt>sys_enoent</dt><dd><var>Path</var> does not exist.</dd>
<dt>sys_eaccess</dt><dd>Search permission is denied for  component in<var>Path</var>.</dd>
<dt>sys_eloop</dt><dd>A circular symbolic link was encountered in <var>Path</var>.</dd>
<dt>sys_eio</dt><dd>An error occurred while reading from the filesystem.</dd>
</dl>
</errors>
<seealso>
<link id="TStatFS"/>
<link id="#rtl.baseunix.FpLStat"/>
</seealso>
<example file="unixex/ex91"/>
</element>

<!-- function Visibility: default -->
<element name="TStatFS">
<short>Retrieve filesystem information from a path.</short>
<descr>
<p>
<var>StatFS</var> returns in <var>Info</var> information about the filesystem on which the file
<var>Path</var> resides. 
<var>Info</var> is of type <link id="#rtl.unixtype.TStatfs">TStatFS</link>. 
</p>
<p>
The function returns zero if the call was succesful, a nonzero value is 
returned if the call failed.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_enotdir</dt><dd>A component of <var>Path</var> is not a directory.</dd>
<dt>sys_einval</dt><dd>Invalid character in <var>Path</var>.</dd>
<dt>sys_enoent</dt><dd><var>Path</var> does not exist.</dd>
<dt>sys_eaccess</dt><dd>Search permission is denied for  component in<var>Path</var>.</dd>
<dt>sys_eloop</dt><dd>A circular symbolic link was encountered in <var>Path</var>.</dd>
<dt>sys_eio</dt><dd>An error occurred while reading from the filesystem.</dd>
</dl>
</errors>
<seealso>
<link id="#rtl.baseunix.FpStat"/>
<link id="#rtl.baseunix.FpLStat"/>
</seealso>
<example file="unixex/ex91"/>
</element>

<!-- function Visibility: default -->
<element name="SelectText">
<short>Wait for event on text file.</short>
<descr>
<var>SelectText</var> executes the <link id="#rtl.baseunix.FpSelect">FpSelect</link> 
call on a file of type
<var>Text</var>. You can specify a timeout in <var>TimeOut</var>. The SelectText call
determines itself whether it should check for read or write, depending on
how the file was opened : With <var>Reset</var> it is checked for reading, with
<var>Rewrite</var> and <var>Append</var> it is checked for writing.
</descr>
<errors>
See <link id="#rtl.baseunix.FpSelect"/>. <var>SYS_EBADF</var> can also mean that the file wasn't
opened.
</errors>
<seealso>
<link id="#rtl.baseunix.FpSelect"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SeekDir">
<short>Seek to position in directory</short>
<descr>
<p>
<var>SeekDir</var> sets the directory pointer to the <var>loc</var>-th entry in the
directory structure pointed to by <var>p</var>.
</p>
<p>
For an example, see <link id="#rtl.baseunix.fpOpenDir"/>.
</p>
</descr>
<errors>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</errors>
<seealso>
<link id="#rtl.baseunix.fpCloseDir"/>
<link id="#rtl.baseunix.fpReadDir"/>
<link id="#rtl.baseunix.fpOpenDir"/>
<link id="TellDir"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="TellDir">
<short>Return current location in a directory</short>
<descr>
<p>
<var>TellDir</var> returns the current location in the directory structure
pointed to by <var>p</var>. It returns -1 on failure.
</p>
<p>
For an example, see <link id="#rtl.baseunix.fpOpenDir"/>.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="#rtl.baseunix.fpCloseDir"/>
<link id="#rtl.baseunix.fpReadDir"/>
<link id="#rtl.baseunix.fpOpenDir"/>
<link id="SeekDir"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AssignPipe">
<short>Create a set of pipe file handlers</short>
<descr>
<p>
<var>AssignePipe</var> creates a pipe, i.e. two file objects, one for input,
one for output. What is written to <var>Pipe_out</var>, can be read from
<var>Pipe_in</var>.
</p>
<p>
This call is overloaded. The in and out pipe can take three forms:
an typed or untyped file, a text file or a file descriptor.
</p>
<p>
If a text file is passed then reading and writing from/to the pipe
can be done through the usual <var>Readln(Pipe_in,...)</var> and
<var>Writeln(Pipe_out,...)</var> procedures.
</p>
<p>
The function returns <var>True</var> if everything went succesfully,
<var>False</var> otherwise.
</p>
</descr>
<errors>
<p>
In case the function fails and returns <var>False</var>, 
extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function:
</p>
<dl>
<dt>sys_emfile</dt>
<dd>Too many file descriptors for this process.</dd>
<dt>sys_enfile</dt>
<dd>The system file table is full.</dd>
</dl>
</errors>
<seealso>
<link id="POpen"/>
<link id="#rtl.baseunix.FpMkFifo"/>
</seealso>
<example file="unixex/ex36"/>
</element>

<!-- function Visibility: default -->
<element name="POpen">
<short>Pipe file to standard input/output of program</short>
<descr>
<var>POpen</var> runs the command specified in <var>Prog</var>,
and redirects the standard in or output of the
command to the other end of the pipe <var>F</var>. The parameter <var>rw</var>
indicates the direction of the pipe. If it is set to <var>'W'</var>, then F can
be used to write data, which will then be read by the command from stdinput.
If it is set to <var>'R'</var>, then the standard output of the command can be 
read from <var>F</var>. <var>F</var> should be reset or rewritten prior to using it.
<var>F</var> can be of type <var>Text</var> or <var>File</var>.
A file opened with <var>POpen</var> can be closed with <var>Close</var>, but also
with <link id="PClose"/>. The result is the same, but <var>PClose</var> returns the
exit status of the command <var>Prog</var>.
</descr>
<errors>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function. 
Errors  are essentially those of the Execve, Dup and AssignPipe commands.
</errors>
<seealso>
<link id="AssignPipe"/>
<link id="PClose"/>
</seealso>
<example file="unixex/ex37"/>
</element>

<!-- function Visibility: default -->
<element name="AssignStream">
<short>Assign stream for in and output to a program</short>
<descr>
<p>
<var>AssignStream</var> creates a 2 or 3 pipes, i.e. two (or three) file objects, one for 
input, one for output,(and one for standard error) the other ends of these 
pipes are connected to standard input and output (and standard error) of 
<var>Prog</var>. <var>Prog</var> is the path of a program (including path).
The options for the program can be specified in <var>Args</var>.
</p>
<p>
What is written to <var>StreamOut</var>, will go to the standard input of
<var>Prog</var>. Whatever is written by <var>Prog</var> to it's standard output 
can be read from <var>StreamIn</var>. 
Whatever is written by <var>Prog</var> to it's standard error read from 
<var>StreamErr</var>, if present. 
</p>
<p>
Reading and writing happens through the usual <var>Readln(StreamIn,...)</var> and
<var>Writeln (StreamOut,...)</var> procedures.
</p>
<remark>
You should <em>not</em> use <var>Reset</var> or <var>Rewrite</var> on a 
file opened with <var>POpen</var>. This will close the file before re-opening 
it again, thereby closing the connection with the program.
</remark>
<p>
The function returns the process ID of the spawned process, or -1 in case of
error.
</p>
</descr>
<errors>
<p>
Extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function. 
</p>
<dl>
<dt>sys_emfile</dt>
<dd>Too many file descriptors for this process.</dd>
<dt>sys_enfile</dt>
<dd>The system file table is full.</dd>
</dl>
<p>
Other errors include the ones by the fork and exec programs
</p>
</errors>
<seealso>
<link id="AssignPipe"/>
<link id="POpen"/>
</seealso>
<example file="unixex/ex38"/>
</element>

<!-- function Visibility: default -->
<element name="GetDomainName">
<short>Return current domain name</short>
<descr>
Get the domain name of the machine on which the process is running.
An empty string is returned if the domain is not set.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetHostName"/>
</seealso>
<example file="unixex/ex39"/>
</element>

<!-- function Visibility: default -->
<element name="GetHostName">
<short>Return host name</short>
<descr>
Get the hostname of the machine on which the process is running.
An empty string is returned if hostname is not set.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetDomainName"/>
</seealso>
<example file="unixex/ex40"/>
</element>


<!-- function Visibility: default -->
<element name="FExpand">
<short>Expand filename to fully qualified path</short>
<descr>
<var>FExpand</var> expands <var>Path</var> to a full path, starting from root,
eliminating directory references such as . and .. from the result.
</descr>
<errors>
None
</errors>
<example file="unixex/ex45"/>
</element>

<!-- function Visibility: default -->
<element name="FSearch">
<short>Search for file in search path.</short>
<descr>
<p>
<var>FSearch</var> searches in <var>DirList</var>, a colon separated list of directories,
for a file named <var>Path</var>. It then returns a path to the found file.
</p>
<p>
The <var>CurrentDirStrategy</var> determines how the current directory is treated
when searching:
</p>
<dl>
<dt>NoCurrentDirectory</dt><dd><printshort id="TFSearchOption.NoCurrentDirectory"/></dd>
<dt>CurrentDirectoryFirst</dt><dd><printshort id="TFSearchOption.CurrentDirectoryFirst"/></dd>
<dt>CurrentDirectoryLast</dt><dd><printshort id="TFSearchOption.CurrentDirectoryLast"/></dd>
</dl>
<p>
It is mainly provided to mimic DOS search path behaviour. Default behaviour
is to search the current directory first.
</p>
</descr>
<errors>
An empty string if no such file was found.
</errors>
<seealso>
<link id="#rtl.unixutil.FNMatch"/>
</seealso>
<example file="unixex/ex46"/>
</element>

<!-- function Visibility: default -->
<element name="Glob">
<short>Find filenames matching a wildcard pattern</short>
<descr>
<p
>Glob returns a pointer to a glob structure which contains all filenames which
exist and match the pattern in <var>Path</var>.
The pattern can contain wildcard characters, which have their
usual meaning.
</p>
</descr>
<errors>
<p>
Returns nil on error, and extended error information is returned by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link> function. 

</p>
<dl>
<dt>sys_enomem</dt><dd>No memory on heap for glob structure.</dd>
<dt>others</dt><dd>As returned by the opendir call, and sys_readdir.</dd>
</dl>
</errors>
<seealso>
<link id="GlobFree"/>
</seealso>
<example file="unixex/ex49"/>
</element>

<!-- procedure Visibility: default -->
<element name="Globfree">
<short>Free result of <link id="Glob"/> call</short>
<descr>
<p>
Releases the memory, occupied by a pglob structure. <var>P</var> is set to nil.
</p>
<p>
For an example, see <link id="Glob"/>.
</p>
</descr>
<errors>
None
</errors>
<seealso>
<link id="Glob"/> 
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SigRaise">
<short>Raise a signal (send to current process)</short>
<descr>
<var>SigRaise</var> sends a <var>Sig</var> signal to the current process.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="#rtl.baseunix.FpKill"/>
<link id="#rtl.baseunix.FpGetPid"/>
</seealso>
<example file="unixex/ex65"/>
</element>


<!-- function Visibility: default -->
<element name="fpgettimeofday">
<short>Return kernel time of day in GMT</short>
<descr>
<p>
<var>FpGetTimeOfDay</var> returns the number of seconds since 00:00, January 1 
1970, GMT in a <var>timeval</var> record. This time NOT corrected any way,
not taking into account timezones, daylight savings time and so on.
</p>
<p>
It is simply a wrapper to the kernel system call. 
</p>
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="PClose">
<short>Close file opened with <link id="POpen"/></short>
<descr>
<p>
<var>PClose</var> closes a file opened with <link id="POpen"/>. 
It waits for the command to complete, and then returns the exit status of the command. 
</p>
<p>
For an example, see <link id="POpen"/>
</p>
</descr>
<errors>
Extended error information is returned  by the <link id="#rtl.baseunix.fpGetErrno">FpGetErrno</link>
function.
</errors>
<seealso>
<link id="POpen"/>
</seealso>
</element>

<element name="MAP_PRIVATE">
<short><link id="#rtl.baseunix.FpMMap"/> map type: Changes are private</short>
</element>
<element name="MAP_ANONYMOUS">
<short><link id="#rtl.baseunix.FpMMap"/> map type: Don't use a file</short>
</element>
<element name="MAP_GROWSDOWN">
<short><link id="#rtl.baseunix.FpMMap"/> option: Memory grows downward (like a stack)</short>
</element>
<element name="MAP_DENYWRITE">
<short><link id="#rtl.baseunix.FpMMap"/> option: Ignored.</short>
</element>
<element name="MAP_EXECUTABLE">
<short><link id="#rtl.baseunix.FpMMap"/> option: Ignored.</short>
</element>
<element name="MAP_LOCKED">
<short><link id="#rtl.baseunix.FpMMap"/> option: lock the pages in memory.</short>
</element>
<element name="MAP_NORESERVE">
<short><link id="#rtl.baseunix.FpMMap"/> option: Do not reserve swap pages for this memory.</short>
</element>
<element name="MAP_SHARED">
<short><link id="#rtl.baseunix.FpMMap"/> map type: Share changes</short>
</element>
<element name="MAP_TYPE">
<short><link id="#rtl.baseunix.FpMMap"/> map type: Bitmask for type of mapping</short>
</element>
<element name="MAP_FIXED">
<short><link id="#rtl.baseunix.FpMMap"/> map type: Interpret addr exactly</short>
</element>

<element name="PROT_READ">
<short><link id="#rtl.baseunix.FpMMap"/> memory access: page can be read</short>
</element>
<element name="PROT_WRITE">
<short><link id="#rtl.baseunix.FpMMap"/> memory access: page can be written</short>
</element>
<element name="PROT_EXEC">
<short><link id="#rtl.baseunix.FpMMap"/> memory access: page can be executed</short>
</element>
<element name="PROT_NONE">
<short><link id="#rtl.baseunix.FpMMap"/> memory access: page can not be accessed</short>
</element>

<element name="cchar">
<short>Alias for <link id="#rtl.UnixType.cchar"/></short>
</element>

<element name="cuchar">
<short>Alias for <link id="#rtl.UnixType.cuchar"/></short>
</element>

<element name="cunsigned">
<short>Alias for <link id="#rtl.unixtype.cunsigned"/></short>
</element>

<element name="pcchar">
<short>Alias for <link id="#rtl.UnixType.pcchar"/></short>
</element>

<element name="pcuchar">
<short>Alias for <link id="#rtl.UnixType.pcuchar"/></short>
</element>

<element name="pcunsigned">
<short>Alias for <link id="#rtl.unixtype.pcunsigned"/></short>
</element>

<element name="TStatFS">
<short>Record describing a file system in the <link id="fpstatfs"/> call.</short>
</element>
<element name="TStatFS.fstype">
<short>File system type</short>
</element>
<element name="TStatFS.bsize">
<short>Block size</short>
</element>
<element name="TStatFS.blocks">
<short>Total number of blocks</short>
</element>
<element name="TStatFS.bfree">
<short>Number of free blocks</short>
</element>
<element name="TStatFS.bavail">
<short>Number of available blocks</short>
</element>
<element name="TStatFS.files">
<short>Number of files</short>
</element>
<element name="TStatFS.ffree">
<short>?</short>
</element>
<element name="TStatFS.fsid">
<short>?</short>
</element>
<element name="TStatFS.namelen">
<short>Max name length for files.</short>
</element>
<element name="TStatFS.spare">
<short>Pad bytes. Do not use.</short>
</element>

<element name="cDouble">
<short>Double precision real format.</short>
</element>


<element name="cFloat">
<short>Floating-point real format</short>
</element>


<element name="clDouble">
<short>Long double precision real format (Extended)</short>
</element>


<element name="pcDouble">
<short>Pointer to <link id="#rtl.baseunix.cdouble">cdouble</link> type.</short>
</element>


<element name="pcFloat">
<short>Pointer to <link id="#rtl.baseunix.cfloat">cfloat</link> type.</short>
</element>


<element name="pclDouble">
<short>Pointer to <link id="#rtl.baseunix.cldouble">cldouble</link> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="clonglong">
<short>C type: 64-bit (double long) signed integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="culonglong">
<short>C type: 64-bit (double long) unsigned integer.</short>
</element>

<element name="tzseconds">
<short>Timezone offset in seconds</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="BaseUnix">
<short>Basic Unix calls</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="UnixType">
<short>Unix type definitions</short>
</element>

<!-- constant Visibility: default -->
<element name="MAP_FAILED">
<short>Error return value for mmap: mmap operation failed.</short>
</element>

<!-- constant Visibility: default -->
<element name="MS_ASYNC">
<short>Asynchronous operation flag for msync call</short>
</element>

<!-- constant Visibility: default -->
<element name="MS_SYNC">
<short>Synchronous operation flag for msync call</short>
</element>

<!-- constant Visibility: default -->
<element name="MS_INVALIDATE">
<short>Invalidate other mappings of file flag for msync call</short>
</element>

<!-- alias type Visibility: default -->
<element name="TIOCtlRequest">
<short>Alias for the <link id="#rtl.unixtype.TIOCtlRequest">TIOCtlRequest</link> type in unixtypes</short>
</element>

<!-- function Visibility: default -->
<element name="FpExecLPE">
<short>Execute a program in the path, and pass it an environment</short>
<descr>
<var>FpExecLPE</var> does the same as <link id="FpExecLP"/>, but additionally
it specifies the environment for the new process in <var>env</var>, a
pointer to a null-terminated array of null-terminated strings.
</descr>
<errors>
On success, this function does not return.
</errors>
<seealso>
<link id="FpExecLP"/>
<link id="FpExecLE"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fpfStatFS">
<short></short>
<short>Retrieve filesystem information.</short>
<descr>
<var>fpStatFS</var> returns in <var>Info</var> information about the
filesystem on which the open file descriptor <var>fd</var> resides.
Info is of type <var>tstatfs</var>. The function returns <var>0</var> if
the call was succesfull, or an error code if the call failed.
</descr>
<errors>
On error, a non-zero error code is returned
</errors>
<seealso>
<link id="fpStatFS"/>
<link id="#rtl.baseunix.fpfStat"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fpStatFS">
<short>Retrieve filesystem information.</short>
<descr>
<var>fpStatFS</var> returns in <var>Info</var> information about the
filesystem on which the file or path <var>Path</var> resides.
Info is of type <var>tstatfs</var>. The function returns <var>0</var> if
the call was succesfull, or an error code if the call failed.
</descr>
<errors>
On error, a non-zero error code is returned
</errors>
<seealso>
<link id="fpFStatFS"/>
<link id="#rtl.baseunix.fpStat"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="fpfsync">
<short>Flush cached data to disk</short>
<descr>
<var>fpfsync</var> forces the system to write all paged (in-memory) changes
to file descriptor <var>fd</var> to disk. If the call was succesful, 0 is
returned.
</descr>
<errors>
On error, a nonzero error-code is returned.
</errors>
</element>

<!-- alias type Visibility: default -->
<element name="csize_t">
<short>Character size type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pcsize_t">
<short>Pointer to character size type <var>pcsize_t</var>.</short>
</element>

<!-- alias type Visibility: default -->
<element name="coff_t">
<short>character offset type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pSize_t">
<short>Pointer to type <var>Size_t</var>.</short>
</element>

<!-- alias type Visibility: default -->
<element name="pstatfs">
<short>Pointer to <var>statfs</var> type</short>
<seealso>
<link id="TStatFS"/>
</seealso>
</element>

<element name="ReReadLocalTime">
<short>Re-Read the local time files.</short>
<descr>
<p>
<var>ReReadLocalTime</var> can be used to re-initialize the local timezone
information. 
</p>
<p>
To speed up conversion of epoch (UTC) time to local time, the
timezone information is loaded only once, at program startup.  Calling this
routine re-reads the timezone information using current timezone settings.
</p>
<p>
The <link id="#rtl.unixutil.EpochToLocal">EpochToLocal</link> function uses timezone information to transform epoch time
to local time. This timezone information does not change while the
application is running: in particular, on DST transitions or when the
timezone files change, the time returned by local time routines will be wrong. 
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="#rtl.sysutils.Date">Date</link>
<link id="#rtl.sysutils.Time">Time</link>
<link id="#rtl.sysutils.Now">Now</link>
<link id="#rtl.unixutil.EpochToLocal">EpochToLocal</link>
</seealso>
</element>

</module> <!-- Unix -->
</package>
</fpdoc-descriptions>
