<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="rtl">
<module name="classes">
<short>Basic classes for RTL</short>
<descr>
<p>This documentation describes the FPC <file>classes</file> unit. 
The <file>Classes</file> unit contains basic classes for the Free Component
Library (FCL):
</p>
<ul>
<li>a <link id="TList"/> class for maintaining lists of pointers,</li>
<li><link id='TStringList'/> for lists of strings,</li>
<li><link id='TCollection'/> to manage collections of objects</li>
<li><link id="TStream"/> classes to support streaming.</li>
</ul>
<p>
Furthermore it introduces methods for object persistence, and classes
that understand an owner-owned relationship, with automatic memory 
management.
</p>
</descr>

<element name="TRTLCriticalSection">
<short>A class for managing multiple threads</short>
<descr>This class is not yet implemented.</descr>
</element>

<element name="HRSRC">
<short>Type to manage resources</short>
<descr>This type is provided for Delphi compatibilty, it is used for resource
streams.
</descr>
</element>

<element name="PStringItem">
<short>
Pointer to a <link id="TStringItem"/> record.
</short>
</element>

<element name="TStringItem">
<short>
The <var>TStringItem</var> is used to store the string and object items in a 
<link id="TStringList"/> string list instance. It should never be used
directly.
</short>
<seealso>
<link id="TStringList"/>
</seealso>
</element>

<element name="TStringItem.FString">
<short>
Contains the string.
</short>
</element>


<element name="TStringItem.FObject">
<short>
Contains the object, if any.
</short>
</element>

<element name="THandle">
<short>Type to manage streams.</short>
<descr>This type is used as the handle for <link
id='THandleStream'>THandleStream</link> stream descendants</descr>
</element>

<element name="TComponentName">
<short>Special type for component names.</short>
<descr>Names of components are of type <var>TComponentName</var>. By
specifying a different type, the Object inspector can handle this property
differently than a standard string property. 
</descr>
</element>

<element name="IUnknown">
<short><var>IUnknown</var> Interface</short>
<descr>IUknown is not yet implemented since interfaces are not yet supported
by FPC.
</descr>
</element>

<element name="TGUID">
<short>Special type for GUID's.</short>
<descr>FPC doesn't support GUID yet.
</descr>
</element>

<element name="HMODULE">
<short>Special type for handling modules.</short>
<descr>
FPC doesn't support modules yet, so this is a dummy type.
</descr>
</element>

<element name="TPoint">
<short>Special type to handle a fake <link id='TComponent'/>
position</short>
<descr>
<p>This record describes a coordinate. It is used to handle the <link
id='TComponent.Top'>Top</link> and <link id='TComponent.Left'>Left</link>
properties of <link id='TComponent'/>.
</p>
<p>
<var>X</var> represents the X-Coordinate of the point described by the record.
<var>Y</var> represents the Y-Coordinate of the point described by the record.
</p>
</descr>
</element>

<element name="TSmallPoint">
<short>Type to describe point in a small plane.</short>
<descr>Same as <link id='TPoint'/>, only the X and Y ranges are limited to 
2-byte integers instead of 4-byte integers.
</descr>
</element>

<element name="TRect">
<short>Descibes a rectangle</short>
<descr>
<var>TRect</var> describes a rectangle in space with its upper-left (in
(<var>Top</var>,<var>Left></var>)) and lower-right (in (<var>Bottom</var>
,<var>Right</var>)) corners.
</descr>
</element>

<element name="MaxListSize">
<short>
Maximum number of elemens in list.
</short>
<descr>
This constant sets the maximum number of elements in a <link id='TList'/>.
</descr>
</element>

<element name="scShift">
<short>
Indicates Shift key in a keyboard shortcut.
</short>
</element>

<element name="scCtrl">
<short>
indicates CTRL key in a keyboard shortcut.
</short>

</element>
<element name="scAlt">
<short>
Indicates ALT key in a keyboard shortcut.
</short>
</element>

<element name="scNone">
<short>
Indicates no special key is presed in a keyboard shortcut.
</short>
</element>

<element name="soFromBeginning">
<short>
<link id='TStream.Seek'>Seek</link> starts relative to the stream origin.
</short>
</element>

<element name="soFromCurrent">
<short>
<link id='TStream.Seek'>Seek</link> starts relative to the current position in
the stream.
</short>
</element>

<element name="soFromEnd">
<short>
<link id='TStream.Seek'>Seek</link> starts relative to the stream end.
</short>
</element>

<element name="fmCreate">
<short>
<link id='TFileStream.Create'/> creates a new file if needed.
</short>
</element>

<element name="fmOpenRead">
<short>
<link id='TFileStream.Create'/> opens a file with read-only access.
</short>
</element>

<element name="fmOpenWrite">
<short>
<link id='TFileStream.Create'/> opens a file with write-only access.
</short>
</element>

<element name="fmOpenReadWrite">
<short>
<link id='TFileStream.Create'/> opens a file with read-write access.
</short>
</element>

<element name="toEof">
<short>
Value returned by <link id='TParser.Token'/> when the end of the input stream was reached.
</short>
<seealso>
<link id="TParser.Token"/>
</seealso>
</element>

<element name="toSymbol">
<short>
Value returned by <link id='TParser.Token'/> when a symbol was found in the input stream.
</short>
<seealso>
<link id="TParser.CheckTokenSymbol"/>
<link id="TParser.Token"/>
<link id="TParser.TokenComponentIdent"/>
<link id="TParser.TokenSymbolIs"/>
</seealso>
</element>

<element name="toString">
<short>
Value  returned by <link id='TParser.Token'/> when a string was found in the
input stream.
</short>
<seealso>
<link id="TParser.Token"/>
<link id="TParser.TokenString"/>
</seealso>
</element>

<element name="toInteger">
<short>
Value returned by <link id='TParser.Token'/> when an integer was found in the 
input stream.
</short>
<seealso>
<link id="TParser.Token"/>
<link id="TParser.TokenInt"/>
</seealso>
</element>

<element name="toFloat">
<short>
Value returned by <link id='TParser.Token'/> when a floating point value was found in the 
input stream.
</short>
<seealso>
<link id="TParser.FloatType"/>
<link id="TParser.Token"/>
<link id="TParser.TokenFloat"/>
</seealso>
</element>

<element name="toWString">
<short>
Value  returned by <link id='TParser.Token'/> when a widestring was found in the
input stream.
</short>
<seealso>
<link id="TParser.Token"/>
<link id="TParser.TokenWideString"/>
</seealso>
</element>

<element name="FilerSignature">
<short>
Constant that is found at the start of a binary stream containing a 
streamed component.
</short>
</element>

<element name="TAlignment">
<short>Type to specify text alignment in controls that display text.</short>
<descr>
<p>
The <var>TAlignment</var> type is used to specify the alignment of
the text in controls that display a text. 
</p>
</descr>
</element>

<element name="TAlignment.taLeftJustify">
<short>Text is displayed aligned to the left
</short>
</element>

<element name="TAlignment.taCenter">
<short>Text is displayed centered.
</short>
</element>

<element name="TAlignment.taRightJustify">
<short>Text is displayed aligned to the right.
</short>
</element>

<element name="TShiftState">
<short>
Indicates what special keys were pressed in combination with a normal key
</short>
<descr>
<p>
This type is used when describing a shortcut key or when describing what
special keys are pressed on a keyboard when a key event is generated.
</p>
<p>
The set contains the special keys that can be used in combination with a
'normal' key.
</p>
</descr>
</element>

<element name="TShiftState.ssShift">
<short>Either left or right shift key</short>
</element>

<element name="TShiftState.ssAlt">
<short>Either left or right ALT key</short>
</element>

<element name="TShiftState.ssCTRL">
<short>Either left or right CTRL key</short>
</element>

<element name="TShiftState.ssLeft">
<short>Either left or right shift key</short>
</element>

<element name="TShiftState.ssRight">
<short></short>
</element>

<element name="TShiftState.ssMiddle">
<short></short>
</element>

<element name="TShiftState.ssDouble">
<short></short>
</element>

<element name="TShiftState.ssMeta">
<short>The META key</short>
</element>

<element name="TShiftState.ssSuper">
<short></short>
</element>

<element name="TShiftState.ssHyper">
<short></short>
</element>

<element name="TShiftState.ssAltGr">
<short>The AltGr (right Alt) key</short>
</element>

<element name="TShiftState.ssCaps">
<short>The CapsLock key</short>
</element>

<element name="TShiftState.ssNum">
<short>The NumLock key</short>
</element>

<element name="TShiftState.ssScroll">
<short>The ScrollLock key</short>
</element>


<element name="TNotifyEvent">
<short>
Standard event handler type.
</short>
<descr>
Most event handlers are implemented as a property of type
<var>TNotifyEvent</var>. When this is set to a certain method of a class, 
when the event occurs, the method will be called, and the class that generated 
the event will pass itself along as the <var>Sender</var> argument.
</descr>
<seealso>
<link id="THelpEvent"/>
<link id="TGetStrProc"/>
</seealso>
</element>

<element name="THelpEvent">
<short>
Special event for display of online help.
</short>
<descr>
This event is used for display of online help. 
</descr>
<seealso>
<link id="TNotifyEvent"/>
<link id="TGetStrProc"/>
</seealso>
</element>

<element name="TGetStrProc">
<short>
Event for retrieving string values.
</short>
<descr> 
This event is used as a callback to retrieve string values. It is used,
among other things, to pass along string properties in property editors.
</descr> 
<seealso>
<link id="THelpEvent"/>
<link id="TNotifyEvent"/>
</seealso>
</element>

<element name="EStreamError">
<short>
Exception raised when an error occurs during read or write operations on a
stream.
</short>
<descr>
<p>
An <var>EStreamError</var> is raised when an error occurs during reading
from or writng to a stream: Possible causes are 
</p>
<ol>
<li>Not enough data is available in the stream.</li>
<li>Trying to seek beyond the beginning or end of the stream.</li>
<li>Trying to set the capacity of a memory stream and no memory is
available.</li>
<li>Trying to write to a read-only stream, such as a resource stream.</li>
<li>Trying to read from a write-only stream.</li>
</ol>
</descr>
<seealso>
<link id="EFCreateError"/>
</seealso>
</element>


<element name="EFCreateError">
<short>
Exception raised when an error occurred during creation of a <link id="TFileStream"/>
stream.
</short>
<descr>
When the operating system reports an error during creation of a new file in 
the <link id="TFileStream.Create">Filestream Constructor</link>, a
<var>EFCreateError</var> is raised.
</descr>
<seealso>
<link id="EStreamError"/>
<link id="EFOpenError"/>
</seealso>
</element>

<element name="EFOpenError">
<short>
Exception raised when an error occurred during creation of a <link id="TFileStream"/>
</short>
<descr>
When the operating system reports an error during the opening of a file in 
the <link id="TFileStream.Create">Filestream Constructor</link>, a
<var>EFOpenError</var> is raised.
</descr>
<seealso>
<link id="EStreamError"/>
<link id="EFCreateError"/>
</seealso>
</element>


<element name="EFilerError">
<short>
Exception raised by the component streaming system if an error occurs.
</short>
<descr>
This class serves as an ancestor class for exceptions that are raised 
when an error occurs during component streaming.

A <var>EFilerError</var> exception is raised when a class is registered
twice.
</descr>
<seealso>
<link id="EStreamError"/>
<link id="EReadError"/>
</seealso>
</element>


<element name="EReadError">
<short>
Exception raised if an error occurs while reading from a stream.
</short>
<descr>
<p>If an error occurs when reading from a stream, a <var>EReadError</var>
exception is raised. Possible causes for this are:</p>
<ol>
<li>Not enough data is available when reading from a stream</li>
<li>The stream containing a component's data contains invalid data.
this will occurr only when reading a component from a stream.</li>
</ol>
</descr>
<seealso>
<link id="EFilerError"/>
<link id="EWriteError"/>
</seealso>
</element>

<element name="EWriteError">
<short>
Exception raised when an error occurs during writing to a stream.
</short>
<descr>
<p>If an error occurs when writing to a stream, a <var>EWriteError</var>
exception is raised. Possible causes for this are:
</p>
<ol>
<li>The stream doesn't allow writing.</li>
<li>An error occurred when writing a property to a stream.</li>
</ol>
</descr>
<seealso>
<link id="EFilerError"/>
<link id="EReadError"/>
</seealso>
</element>

<element name="EClassNotFound">
<short>
Exception raised when an unknown class is referenced in a streamed
component.
</short>
<descr>
When the streaming system needs to create a component, it looks for the
class pointer (VMT) in the list of registered classes by its name. If this
name is not found, then an <var>EClassNotFound</var> is raised.
</descr>
<seealso>
<link id="EFilerError"/>
</seealso>
</element>


<element name="EMethodNotFound">
<short>
This exception is no longer used.
</short>
<descr>
This exception is no longer used in the streaming system. This error is
replaced by a <link id="EReadError"/>.
</descr>
<seealso>
<link id="EFilerError"/>
<link id="EReadError"/>
</seealso>
</element>


<element name="EInvalidImage">
<short>
Exception raised when the resource header needed for streaming of a
component is invalid.
</short>
<descr>
This exception is not used by Free Pascal but is provided for Delphi
compatibility.
</descr>
</element>


<element name="EResNotFound">
<short>
Exception raised when a resource, needed to initialize a component, is not found.
</short>
<descr>
This exception is not used by Free Pascal but is provided for Delphi
compatibility.
</descr>
</element>


<element name="EListError">
<short>
Exception raised when an error occurs in lists handling.
</short>
<descr>
<p>
If an error occurs in one of the <link id='TList'/> or <link id='TStrings'/> 
methods, then a <var>EListError</var> exception is raised. This can occur in
one of the following cases:
</p>
<ol>
<li>There is not enough memory to expand the list.</li>
<li>The list tried to grow beyond its maximal capacity.</li>
<li>An attempt was made to reduce the capacity of the list below the
current element count.</li>
<li>An attempt was made to set the list count to a negative value.</li>
<li>A non-existent element of the list was referenced. (i.e. the list index
was out of bounds)</li>
<li>An attempt was made to move an item to a position outside the list's
bounds.</li>
</ol>
</descr>
<seealso>
<link id="TList"/>,
<link id="TStrings"/>
</seealso>
</element>


<element name="EBitsError">
<short>
Exception raised when an error occurs in a method of <link id="TBits"/>.
</short>
<descr>
When an index of a bit in a <link id="TBits"/> is out of the valid range 
(<var>0</var> to <var>Count-1</var>) then a <var>EBitsError</var> exception 
is raised.
</descr>
</element>


<element name="EStringListError">
<short>
Exception raised when an error occurs in a method of <link id="TStrings"/>.
</short>
<descr>
<p>
When an error occurs in one of the methods of <link id="TStrings"/> then
an <var>EStringListError</var> is raised. This can have one of the following
causes:
</p>
<ol>
<li>There is not enough memory to expand the list.</li>
<li>The list tried to grow beyond its maximal capacity.</li>
<li>A non-existent element of the list was referenced. (i.e. the list index
was out of bounds)</li>
<li>An attempt was made to add a duplicate entry to a <link
id="TStringList"/> when <link id="TStringList.Duplicates"/> is
<var>False</var>.</li>
</ol>
</descr>
<seealso>
<link id="TStrings"/>
<link id="TStringList"/>
</seealso>
</element>


<element name="EComponentError">
<short>
Exception raised when an error occurs in the component registration
routines.
</short>
<descr>
<p>
When an error occurs during the registration of a component, or when naming
a component, then a <var>EComponentError</var> is raised. Possible causes
are:
</p>
<ol>
<li>An name with an illegal character was assigned to a component.</li>
<li>A component with the same name and owner already exists.</li>
<li>The component registration system isn't set up properly.</li>
</ol>
</descr>
<seealso>
<link id="TComponent"/>
<link id="TComponent.Name"/>
</seealso>
</element>


<element name="EParserError">
<short>
Exception raised when an error occurs during the parsing of streams.
</short>
<descr>
When an error occurs during the parsing of a stream, an <var>EParserError</var>
is raised. Usually this indicates that an invalid token was found on the
input stream, or the token read from the stream wasn't the expected token.
</descr>
<seealso>
<link id="TParser"/>
</seealso>
</element>


<element name="EOutOfResources">
<short>
Exception raised when the system is out of resources.
</short>
<descr>
This exception is not used in Free Pascal, it is defined for Delphi
compatibiliy purposes only.
</descr>
</element>


<element name="EInvalidOperation">
<short>
Exception raised when an invalid operation is performed. Obsolete.
</short>
<descr>
This exception is not used in Free Pascal, it is defined for Delphi
compatibiliy purposes only.
</descr>
</element>

<!--
 **********************************************************************
 TList
 **********************************************************************
-->

<element name="TList">
<short>Class to manage collections of pointers.</short>
<descr>
<p>
<var>TList</var> is a class that can be used to manage collections of
pointers. It introduces methods and properties to store the pointers, search
in the list of pointers, sort them. It manages its memory by itself, no
intervention for that is needed. It has an event notification mechanism
which allows to notify of list changes. This slows down some of
<var>TList</var> mechanisms, and if no notification is used,
<link id="TFPList"/> may be used instead.
</p>
<p>
To manage collections of strings, it is better to use a <link
id="TStrings"/> descendant such as <link id="TStringList"/>. To manage
general objects, a <link id="TCollection"/> class exists, from which a
descendant can be made to manage collections of various kinds.
</p>
</descr>
<seealso>
<link id="TStrings"/>
<link id="TCollection"/>
</seealso>
</element>

<element name="TList.Create">
<short>Class to manage collections of pointers.</short>
<descr>
<p>
<var>TList.Create</var> creates a new instance of <var>TList</var>. 
It clears the list and prepares it for use.
</p>
</descr>
<seealso>
<link id="TList"/>
<link id="TList.Destroy"/>
</seealso>
</element>

<!-- To be documented later on maybe ?

    function Get(Index: Integer): Pointer;
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure Grow; virtual;


    procedure Put(Index: Integer; Item: Pointer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure SetCapacity(NewCapacity: Integer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure SetCount(NewCount: Integer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>

-->

<element name="TList.Destroy">
<short>
Destroys the list and releases the memory used to store the list elements.
</short>
<descr>
<var>Destroy</var> destroys the list and releases the memory used to store 
the list elements. The elements themselves are in no way touched, i.e. any
meomory they point to must be explicitly released before calling the
destructor.
</descr>
</element>


<element name="TList.Add">
<short>
Adds a new pointer to the list.
</short>
<descr>
<p>
<var>Add</var> adds a new pointer to the list after the last pointer (i.e.
at position <var>Count</var>, thus increasing the item count with 1. 
If the list is at full capacity, the capacity of the list is expanded, 
using the <link id="TList.Grow">Grow</link> method.
</p>
<p>
To insert a pointer at a certain position in the list, use the <link
id="TList.Insert">Insert</link> method instead.
</p>
</descr>
<seealso>
<link id="TList.Delete">Delete</link>
<link id="TList.Grow">Grow</link>
<link id="TList.Insert">Insert</link>
</seealso>
</element>



<element name="TList.Clear">
<short>
Clears the pointer list.
</short>
<descr>
<var>Clear</var> removes all pointers from the list, and sets the capacity to
0, thus freeing any memory allocated to maintain the list.
</descr>
<seealso>
<link id="TList.Destroy">Destroy</link>
</seealso>
</element>


<!--    procedure Delete(Index: Integer); -->
<element name="TList.Delete">
<short>
Removes a pointer from the list.
</short>
<descr>
<p><var>Delete</var> removes the pointer at position <var>Index</var> from the
list, shifting all following pointers one position up (or to the left).
</p>
<p>
The memory the pointer is pointing to is <i>not</i> deallocated. 
</p>
</descr>
</element>


<element name="TList.Error">
<short>
Raises an <link id="EListError"/> exception.
</short>
<descr>
<var>Error</var> raises an <link id="EListError"/> exception, with a message
formatted with <var>Msg</var> and <var>Data</var>.
</descr>
</element>


<!--    procedure Exchange(Index1, Index2: Integer); -->
<element name="TList.Exchange">
<short>
Exchanges two pointers in the list.
</short>
<descr>
<var>Exchange</var> exchanges the pointers at positions <var>Index1</var>
and <var>Index2</var>. Both pointers must be withing the current range of
the list, or an <link id="EListError"/> exception will be raised.
</descr>
</element>


<element name="TList.Expand">
<short>
Increases the capacity of the list if needed.
</short>
<descr>
<p>
<var>Expand</var> increases the capacity of the list if the current element
count matches the current list capacity.
</p>
<p>
The capacity is increased according to the following algorithm:
</p>
<ol>
<li>If the capacity is less than 3, the capacity is increased with 4.</li>
<li>If the capacity is larger than 3 and less than 8, the capacity is increased with 8.</li>
<li>If the capacity is larger than 8, the capacity is increased with 16.</li>
</ol>
<p>
The return value is <var>Self</var>.
</p>
</descr>
<seealso>
<link id="TList.Capacity">Capacity</link>
<!-- <link id="Tlist.SetCapacity"> -->
</seealso>
</element>


<element name="TList.First">
<short>
Returns the first non-nil pointer in the list.
</short>
<descr>
<p>
<var>First</var> returns the value of the first non-nil pointer in the
list.
</p>
<p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
</descr>
<seealso>
<link id="TList.Last">Last</link>
</seealso>
</element>


<!--    function IndexOf(Item: Pointer): Integer; -->
<element name="TList.IndexOf">
<short>
Returns the index of a given pointer.
</short>
<descr>
<p>
<var>IndexOf</var> searches for the pointer <var>Item</var> in the list
of pointers, and returns the index of the pointer, if found. 
</p>
<p>
If no pointer with the value <var>Item</var> was found, -1 is returned.
</p>
</descr>
</element>


<element name="TList.Insert">
<short>
Inserts a new pointer in the list at a given position.
</short>
<descr>
<p>
<var>Insert</var> inserts pointer <var>Item</var> at position
<var>Index</var> in the list. All pointers starting from <var>Index</var>
are shifted to the right.
</p>
<p>
If <var>Index</var> is not a valid position, then a <link id="EListError"/>
exception is raised.
</p>
</descr>
<seealso>
<link id="TList.Add">Add</link>
<link id="Tlist.Delete">Delete</link>
</seealso>
</element>

<element name="TList.Insert.Item">
<short>Pointer to be inserted.</short>
</element>

<element name="TList.Insert.Index">
<short>Position where to insert</short>
</element>

<!--    function Last: Pointer; -->
<element name="TList.Last">
<short>
Returns the last non-nil pointer in the list.
</short>
<descr>
<p>
<var>Last</var> returns the value of the last non-nil pointer in the
list.
</p>
<p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
</descr>
<seealso>
<link id="TList.First">First</link>
</seealso>
</element>

<!--    procedure Move(CurIndex, NewIndex: Integer); -->
<element name="TList.Move">
<short>
Moves a pointer from one position in the list to another.
</short>
<descr>
<p>
<var>Move</var> moves the pointer at position <var>CurIndex</var>
to position <var>NewIndex</var>. This is done by storing the value 
at position <var>CurIndex</var>, deleting the pointer at position
<var>CurIndex</var>, and reinserting the value at position
<var>NewIndex</var>
</p>
<p>
If <var>CurIndex</var> or <var>Newindex</var> are not inside the valid
range of indices, an <link id="EListError"/> exception is raised.
</p>
</descr>
<seealso>
<link id="TList.Exchange">Exchange</link>
</seealso>
</element>

<!--    function Remove(Item: Pointer): Integer; -->
<element name="TList.Remove">
<short>
Removes a value from the list.
</short>
<descr>
<var>Remove</var> searches <var>Item</var> in the list, and, if it finds it,
deletes the item from the list. Only the first occurrence of <var>Item</var>
is removed.
</descr>
<seealso>
<link id="TList.Delete">Delete</link>
<link id="TList.IndexOf">IndexOf</link>
<link id="Tlist.Insert">Insert</link>
</seealso>
</element>

<!--    procedure Pack; -->
<element name="TList.Pack">
<short>
Removes <var>Nil</var> pointers from the list and frees unused memory.
</short>
<descr>
<var>Pack</var> removes all <var>nil</var> pointers from the list. 
The capacity of the list is then set to the number of pointers in the list.

This method can be used to free unused memory if the list has grown to
very large sizes and has a lot of unneeded nil pointers in it.
</descr>
<seealso>
<link id="TList.Clear"/>
</seealso>
</element>


<!--    procedure Sort(Compare: TListSortCompare); -->
<element name="TList.Sort">
<short>
Sorts the pointers in the list.
</short>
<descr>
<p>
<var>Sort></var> sorts the pointers in the list. Two pointers are compared
by passing them to the <var>Compare</var> function. The result of this
function determines how the pointers will be sorted:
</p>
<ul>
<li>If the result of this function is negative, the first pointer is 
assumed to be 'less' than the second and will be moved before the second 
in the list.</li>
<li>If the function result is positive, the first pointer is assumed to
be 'greater than' the second and will be moved after the second in the
list.</li>
<li>if the function result is zero, the pointers are assumed to be 'equal'
and no moving will take place.</li>
</ul>
<p>
The sort is done using a quicksort algorithm.
</p>
</descr>
</element>

<!--    property Capacity: Integer read FCapacity write SetCapacity; -->
<element name="TList.Capacity">
<short>
Current capacity (i.e. number of pointers that can be stored) of the list.
</short>
<descr>
<p><var>Capacity</var> contains the number of pointers the list can store
before it starts to grow. 
</p>
<p>
If a new pointer is added to the list using <link id="TList.Add">add</link>
or <link id="TList.Insert">insert</link>, and there is not enough memory to
store the new pointer, then the list will try to allocate more memory to
store the new pointer. Since this is a time consuming operation, it is
important that this operation be performed as little as possible. If
it is known how many pointers there will be before filling the list, it is
a good idea to set the capacity first before filling. This ensures that the
list doesn't need to grow, and will speed up filling the list.
</p>
</descr>
<seealso>
<link id="TList.SetCapacity">SetCapacity</link>
<link id="TList.Count">Count</link>
</seealso>
</element>

<!--    property Count: Integer read FCount write SetCount; -->
<element name="Tlist.Count">
<short>
Current number of pointers in the list.
</short>
<descr>
<var>Count</var> is the current number of (possibly <var>Nil</var>) pointers
in the list. Since the list is zero-based, the index of the largest pointer
is <var>Count-1</var>.
</descr>
<link id="TList.Capacity">Capacity</link>
</element>

<!--  property Items[Index: Integer]: Pointer read Get write Put; default; -->
<element name="TList.Items">
<short>
Provides access to the pointers in the list. 
</short>
<descr>
<p><var>Items</var> is used to access the pointers in the list. It is the
default property of the <var>TList</var> class, so it can be omitted. 
</p>
<p>
The list is zero-based, so Index must be in the range <var>0</var> to 
<var>Count-1</var>.
</p>
</descr>
</element>

<!--  property List: PPointerList read FList; -->

<element name="TList.List">
<short>
Memory array where pointers are stored.
</short>
<descr>
<var>List</var> points to the memory space where the pointers are stored.
This can be used to quickly copy the list of pinters to another location.
</descr>
</element>

<!--
 **********************************************************************
 TFPList
 **********************************************************************
-->

<element name="TFPList">
<short>Class to manage collections of pointers.</short>
<descr>
<p>
<var>TFPList</var> is a class that can be used to manage collections of
pointers. It introduces methods and properties to store the pointers, search
in the list of pointers, sort them. It manages its memory by itself, no
intervention for that is needed. Contrary to <link id="TList"/>,
<var>TFPList</var> has no notification mechanism. If no notification
mechanism is used, it is better to use <var>TFPList</var> instead of
<var>TList</var>, as the performance of <var>TFPList</var> is much higher.
</p>
<p>
To manage collections of strings, it is better to use a <link
id="TStrings"/> descendant such as <link id="TStringList"/>. To manage
general objects, a <link id="TCollection"/> class exists, from which a
descendant can be made to manage collections of various kinds.
</p>
</descr>
<seealso>
<link id="TStrings"/>
<link id="TCollection"/>
</seealso>
</element>

<element name="TFPList.Assign">
<short>Assign performs the given operation on the list.</short>
<descr>
<var>Assign</var> can be used to merge or assign lists It is an extended
version of the usual <var>TPersistent.Assign</var> mechanism. The arguments
<var>ListA</var> and <var>ListB</var> are used as sources of pointers to 
add or remove elements from the current list, depending on the operation 
<var>AOperation</var>. The available operations are documented in the 
<link id="TListAssignOp"/> type.
</descr>
<seealso>
<link id="TFPList.Add"/>
<link id="TFPList.Clear"/>
</seealso>
</element>

<element name="TFPList.Extract">
<short>Remove the first occurrence of a pointer from the list.</short>
<descr>
<var>Extract</var> searches for the first occurrence of <var>Item</var> in
the list and deletes it from the list. If <var>Item</var> was found, it's 
value is returned. If <var>Item</var> was not found, <var>Nil</var> is returned.
</descr>
<seealso>
<link id="TFPList.Delete"/>
</seealso>
</element>

<!-- To be documented later on maybe ?

    function Get(Index: Integer): Pointer;
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure Grow; virtual;
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure Put(Index: Integer; Item: Pointer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure SetCapacity(NewCapacity: Integer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>


    procedure SetCount(NewCount: Integer);
<element name="">
<short>
</short>
<descr>
</descr>
</element>

-->

<element name="TFPList.Destroy">
<short>
Destroys the list and releases the memory used to store the list elements.
</short>
<descr>
<var>Destroy</var> destroys the list and releases the memory used to store 
the list elements. The elements themselves are in no way touched, i.e. any
meomory they point to must be explicitly released before calling the
destructor.
</descr>
</element>


<element name="TFPList.Add">
<short>
Adds a new pointer to the list.
</short>
<descr>
<p>
<var>Add</var> adds a new pointer to the list after the last pointer (i.e.
at position <var>Count</var>, thus increasing the item count with 1. 
If the list is at full capacity, the capacity of the list is expanded, 
using the <link id="TFPList.Expand">Expand</link> method.
</p>
<p>
To insert a pointer at a certain position in the list, use the <link
id="TFPList.Insert">Insert</link> method instead.
</p>
</descr>
<seealso>
<link id="TFPList.Delete">Delete</link>
<link id="TList.Grow">Grow</link>
<link id="TFPList.Insert">Insert</link>
</seealso>
</element>



<element name="TFPList.Clear">
<short>
Clears the pointer list.
</short>
<descr>
<var>Clear</var> removes all pointers from the list, and sets the capacity to
0, thus freeing any memory allocated to maintain the list.
</descr>
<seealso>
<link id="TFPList.Destroy">Destroy</link>
</seealso>
</element>


<!--    procedure Delete(Index: Integer); -->
<element name="TFPList.Delete">
<short>
Removes a pointer from the list.
</short>
<descr>
<p><var>Delete</var> removes the pointer at position <var>Index</var> from the
list, shifting all following pointers one position up (or to the left).
</p>
<p>
The memory the pointer is pointing to is <i>not</i> deallocated. 
</p>
</descr>
</element>


<element name="TFPList.Error">
<short>
Raises an <link id="EListError"/> exception.
</short>
<descr>
<var>Error</var> raises an <link id="EListError"/> exception, with a message
formatted with <var>Msg</var> and <var>Data</var>.
</descr>
</element>


<!--    procedure Exchange(Index1, Index2: Integer); -->
<element name="TFPList.Exchange">
<short>
Exchanges two pointers in the list.
</short>
<descr>
<var>Exchange</var> exchanges the pointers at positions <var>Index1</var>
and <var>Index2</var>. Both pointers must be withing the current range of
the list, or an <link id="EListError"/> exception will be raised.
</descr>
</element>


<element name="TFPList.Expand">
<short>
Increases the capacity of the list if needed.
</short>
<descr>
<p>
<var>Expand</var> increases the capacity of the list if the current element
count matches the current list capacity.
</p>
<p>
The capacity is increased according to the following algorithm:
</p>
<ol>
<li>If the capacity is less than 3, the capacity is increased with 4.</li>
<li>If the capacity is larger than 3 and less than 8, the capacity is increased with 8.</li>
<li>If the capacity is larger than 8, the capacity is increased with 16.</li>
</ol>
<p>
The return value is <var>Self</var>.
</p>
</descr>
<seealso>
<link id="TFPList.Capacity">Capacity</link>
<!-- <link id="TFPList.SetCapacity"> -->
</seealso>
</element>


<element name="TFPList.First">
<short>
Returns the first non-nil pointer in the list.
</short>
<descr>
<p>
<var>First</var> returns the value of the first non-nil pointer in the
list.
</p>
<p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
</descr>
<seealso>
<link id="TFPList.Last">Last</link>
</seealso>
</element>


<!--    function IndexOf(Item: Pointer): Integer; -->
<element name="TFPList.IndexOf">
<short>
Returns the index of a given pointer.
</short>
<descr>
<p>
<var>IndexOf</var> searches for the pointer <var>Item</var> in the list
of pointers, and returns the index of the pointer, if found. 
</p>
<p>
If no pointer with the value <var>Item</var> was found, -1 is returned.
</p>
</descr>
</element>


<element name="TFPList.Insert">
<short>
Inserts a new pointer in the list at a given position.
</short>
<descr>
<p>
<var>Insert</var> inserts pointer <var>Item</var> at position
<var>Index</var> in the list. All pointers starting from <var>Index</var>
are shifted to the right.
</p>
<p>
If <var>Index</var> is not a valid position, then a <link id="EListError"/>
exception is raised.
</p>
</descr>
<seealso>
<link id="TFPList.Add">Add</link>
<link id="TFPList.Delete">Delete</link>
</seealso>
</element>

<element name="TFPList.Insert.Item">
<short>Pointer to be inserted.</short>
</element>

<element name="TFPList.Insert.Index">
<short>Position where to insert</short>
</element>

<!--    function Last: Pointer; -->
<element name="TFPList.Last">
<short>
Returns the last non-nil pointer in the list.
</short>
<descr>
<p>
<var>Last</var> returns the value of the last non-nil pointer in the
list.
</p>
<p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
</descr>
<seealso>
<link id="TFPList.First">First</link>
</seealso>
</element>

<!--    procedure Move(CurIndex, NewIndex: Integer); -->
<element name="TFPList.Move">
<short>
Moves a pointer from one position in the list to another.
</short>
<descr>
<p>
<var>Move</var> moves the pointer at position <var>CurIndex</var>
to position <var>NewIndex</var>. This is done by storing the value 
at position <var>CurIndex</var>, deleting the pointer at position
<var>CurIndex</var>, and reinserting the value at position
<var>NewIndex</var>
</p>
<p>
If <var>CurIndex</var> or <var>Newindex</var> are not inside the valid
range of indices, an <link id="EListError"/> exception is raised.
</p>
</descr>
<seealso>
<link id="TFPList.Exchange">Exchange</link>
</seealso>
</element>

<!--    function Remove(Item: Pointer): Integer; -->
<element name="TFPList.Remove">
<short>
Removes a value from the list.
</short>
<descr>
<var>Remove</var> searches <var>Item</var> in the list, and, if it finds it,
deletes the item from the list. Only the first occurrence of <var>Item</var>
is removed.
</descr>
<seealso>
<link id="TFPList.Delete">Delete</link>
<link id="TFPList.IndexOf">IndexOf</link>
<link id="TFPList.Insert">Insert</link>
</seealso>
</element>

<!--    procedure Pack; -->
<element name="TFPList.Pack">
<short>
Removes <var>Nil</var> pointers from the list and frees unused memory.
</short>
<descr>
<var>Pack</var> removes all <var>nil</var> pointers from the list. 
The capacity of the list is then set to the number of pointers in the list.

This method can be used to free unused memory if the list has grown to
very large sizes and has a lot of unneeded nil pointers in it.
</descr>
<seealso>
<link id="TFPList.Clear"/>
</seealso>
</element>


<!--    procedure Sort(Compare: TFPListSortCompare); -->
<element name="TFPList.Sort">
<short>
Sorts the pointers in the list.
</short>
<descr>
<p>
<var>Sort></var> sorts the pointers in the list. Two pointers are compared
by passing them to the <var>Compare</var> function. The result of this
function determines how the pointers will be sorted:
</p>
<ul>
<li>If the result of this function is negative, the first pointer is 
assumed to be 'less' than the second and will be moved before the second 
in the list.</li>
<li>If the function result is positive, the first pointer is assumed to
be 'greater than' the second and will be moved after the second in the
list.</li>
<li>if the function result is zero, the pointers are assumed to be 'equal'
and no moving will take place.</li>
</ul>
<p>
The sort is done using a quicksort algorithm.
</p>
</descr>
</element>

<!--    property Capacity: Integer read FCapacity write SetCapacity; -->
<element name="TFPList.Capacity">
<short>
Current capacity (i.e. number of pointers that can be stored) of the list.
</short>
<descr>
<p><var>Capacity</var> contains the number of pointers the list can store
before it starts to grow. 
</p>
<p>
If a new pointer is added to the list using <link id="TFPList.Add">add</link>
or <link id="TFPList.Insert">insert</link>, and there is not enough memory to
store the new pointer, then the list will try to allocate more memory to
store the new pointer. Since this is a time consuming operation, it is
important that this operation be performed as little as possible. If
it is known how many pointers there will be before filling the list, it is
a good idea to set the capacity first before filling. This ensures that the
list doesn't need to grow, and will speed up filling the list.
</p>
</descr>
<seealso>
<link id="TFPList.SetCapacity">SetCapacity</link>
<link id="TFPList.Count">Count</link>
</seealso>
</element>

<!--    property Count: Integer read FCount write SetCount; -->
<element name="TFPList.Count">
<short>
Current number of pointers in the list.
</short>
<descr>
<var>Count</var> is the current number of (possibly <var>Nil</var>) pointers
in the list. Since the list is zero-based, the index of the largest pointer
is <var>Count-1</var>.
</descr>
<link id="TFPList.Capacity">Capacity</link>
</element>

<!--  property Items[Index: Integer]: Pointer read Get write Put; default; -->
<element name="TFPList.Items">
<short>
Provides access to the pointers in the list. 
</short>
<descr>
<p><var>Items</var> is used to access the pointers in the list. It is the
default property of the <var>TFPList</var> class, so it can be omitted. 
</p>
<p>
The list is zero-based, so Index must be in the range <var>0</var> to 
<var>Count-1</var>.
</p>
</descr>
</element>

<!--  property List: PPointerList read FList; -->

<element name="TFPList.List">
<short>
Memory array where pointers are stored.
</short>
<descr>
<var>List</var> points to the memory space where the pointers are stored.
This can be used to quickly copy the list of pinters to another location.
</descr>
</element>

<!--
 **********************************************************************
 ThreadList
 **********************************************************************
-->

<element name="TThreadList">  <!-- Class -->
<short>Thread-safe list object</short>
<descr>
TThreadList is a thread-safe <link id="Tlist"/> implementation. 
Unlike <var>TList</var>, it can be accessed read-write by multiple threads:
the list implementation will take care of locking the list when adding or
removing items from the list.
</descr>
<seealso>
<link id="TList"/>
</seealso>
</element>

<element name="TThreadList.Create">  <!-- Constructor -->
<short>Creates a new thread-safe list.</short>
<descr>
<var>Create</var> instantiates a new <var>TThreadList</var> instance. 
It initializes a critical section and an internal list object.
</descr>
<seealso>
<link id="TThreadList.Destroy"/>
</seealso>
</element>

<element name="TThreadList.Destroy">  <!-- Destructor -->
<short>Destroys the list instance.</short>
<descr>
<var>Destroy</var> finalizes the critical section, clears the internal list object and calls
the inherited destructor.
</descr>
<seealso>
<link id="TThreadList.Create"/>
</seealso>
</element>

<element name="TThreadList.Add">  <!-- Procedure -->
<short>Adds an element to the list.</short>
<descr>
<var>Add</var> attempts to lock the list and adds the pointer <var>Item</var>
to the list. After the pointer was added, the list is unlocked again.
</descr>
<seealso>
<link id="TThreadList.LockList">LockList</link>
<link id="TThreadList.Clear">Clear</link>
<link id="TThreadList.Remove">Remove</link>
<link id="TThreadList.UnLockList">UnlockList</link>
</seealso>
</element>

<element name="TThreadList.Clear">  <!-- Procedure -->
<short>Removes all emements from the list.</short>
<descr>
<var>Clear</var> attempts to lock the list and then clears the list; all
items are removed from the list. After the list is cleared, it is again 
unlocked.
</descr>
<seealso>
<link id="TThreadList.LockList">LockList</link>
<link id="TThreadList.Add">Add</link>
<link id="TThreadList.Remove">Remove</link>
<link id="TThreadList.UnLockList">UnlockList</link>
</seealso>
</element>

<element name="TThreadList.LockList">  <!-- Function -->
<short>Locks the list for exclusive access.</short>
<descr>
<var>LockList</var> locks the list for exclusive access. Locklist uses an
internal critical section, so all rules for multiple locking of critical
sections apply to locklist/unlocklist as well.
</descr>
<seealso>
<link id="TThreadList.Clear">Clear</link>
<link id="TThreadList.Add">Add</link>
<link id="TThreadList.Remove">Remove</link>
<link id="TThreadList.UnLockList">UnlockList</link>
</seealso>
</element>

<element name="TThreadList.Remove">  <!-- Procedure -->
<short>Removes an item from the list.</short>
<descr>
<var>Remove</var> attempts to lock the list and then removes
<var>Item</var> from the list. After the item is removed, the
list is again unlocked.
</descr>
<seealso>
<link id="TThreadList.LockList">LockList</link>
<link id="TThreadList.Add">Add</link>
<link id="TThreadList.Clear">Clear</link>
<link id="TThreadList.UnLockList">UnlockList</link>
</seealso>
</element>

<element name="TThreadList.UnlockList">  <!-- Procedure -->
<short>Unlocks the list after it was locked.</short>
<descr>
<var>UnLockList</var> unlocks the list when it was locked for exclusive access. 
UnLocklist and LockList use an internal critical section, so all rules for multiple 
locking/unlocking of critical sections apply.
</descr>
<seealso>
<link id="TThreadList.Clear">Clear</link>
<link id="TThreadList.Add">Add</link>
<link id="TThreadList.Remove">Remove</link>
<link id="TThreadList.LockList">lockList</link>
</seealso>
</element>

<!--
 **********************************************************************
 TBits helpers
 **********************************************************************
-->

<element name="BITSHIFT">  <!-- Constant -->
<short>Used to calculate the size of a bits array</short>
<seealso>
<link id="TBits"/>
<link id="TBits.Size"/>
</seealso>
</element>

<element name="MASK">  <!-- Constant -->
<short>Bitmask with all bits on.</short>
<seealso>
<link id="TBits"/>
</seealso>
</element>

<element name="MaxBitRec">  <!-- Constant -->
<short>Maximum number of bit records in TBits.</short>
<seealso>
<link id="TBits"/>
</seealso>
</element>

<element name="MaxBitFlags">  <!-- Constant -->
<short>Maximum number of bits in TBits collection.</short>
<seealso>
<link id="TBits"/>
</seealso>      
</element>

<element name="TBitArray">  <!-- Array type -->
<short>Array to store bits.</short>
<seealso>
<link id="TBits"/>
</seealso>
</element>

<!--
 **********************************************************************
 TBis
 **********************************************************************
-->


<element name="TBits">  <!-- Class -->
<short>Class to store collections of bits (binary values that can be 0 or 1)</short>
<descr>
<p><var>TBits</var> can be used to store collections of bits in an indexed
array. This is especially useful for storing collections of booleans:
Normally the size of a boolean is the size of the smallest enumerated type,
i.e. 1 byte. Since a bit can take 2 values it can be used to store a boolean
as well. Since TBits can store 8 bits in a byte, it takes 8 times less space
to store an array of booleans in a TBits class then it would take to store
them in a conventional array.
</p>
<p><var>TBits</var> introduces methods to store and retrieve bit values,
apply masks, and search for bits. 
</p>
</descr>
</element>

<element name="TBits.Create">  <!-- Constructor -->
<short>Creates a new bits collection.</short>
<descr>
<p>
<var>Create</var> creates a new bit collection with initial size <var>TheSize</var>.
The size of the collection can be changed later on. 
</p>
<p>All bits are initially set to zero.</p>
</descr>
<seealso>
<link id="TBits.Destroy">Destroy</link>
</seealso>
</element>

<element name="TBits.Destroy">  <!-- Destructor -->
<short>Destroys a bit collection</short>
<descr>
<p>
<var>Destroy</var> destroys a previously created bit collection and 
releases all memory used to store the bit collection.
</p>
<p>
<var>Destroy</var> should never be called directly, <var>Free</var>
should be used instead.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.Create">Create</link>
</seealso>
</element>

<element name="TBits.getFSize">  <!-- Function -->
<short>Returns the number of records used to store the bits.</short>
<descr>
<var>GetFSize</var> returns the number of records used to store the current
number of bits.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.Size">Size</link>
</seealso>
</element>

<element name="TBits.seton">  <!-- Procedure -->
<short>Turn a  particular bit on.</short>
<descr>
<var>SetOn</var> turns on the bit at position <var>bit</var>, i.e. sets it
to 1. 
If <var>bit</var> is at a position bigger than the current size, the collection
is expanded to the required size using <link id="TBits.grow">Grow</link>.
</descr>
<errors>
If <var>bit</var> is larger than the maximum allowed bits array size or
is negative, an <link id="EBitsError"/> exception is raised.
</errors>
<seealso>
<link id="TBits.Bits">Bits</link>
<link id="TBits.clear">Clear</link>
</seealso>
</element>

<element name="TBits.clear">  <!-- Procedure -->
<short>Clears a particular bit.</short>
<descr>
<var>Clear</var> clears the bit at position <var>bit</var>. If the array
If <var>bit</var> is at a position bigger than the current size, the collection
is expanded to the required size using <link id="TBits.grow">Grow</link>.
</descr>
<errors>
If <var>bit</var> is larger than the maximum allowed bits array size or
is negative, an <link id="EBitsError"/> exception is raised.
</errors>
<seealso>
<link id="TBits.Bits">Bits</link>
<link id="TBits.clear">seton</link>
</seealso>
</element>

<element name="TBits.clearall">  <!-- Procedure -->
<short>Clears all bits in the array.</short>
<descr>
<var>ClearAll</var> clears all bits in the array, i.e. sets them to zero. <var>
ClearAll</var> works faster than clearing all individual bits, since it 
uses the packed nature of the bits.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.Bits">Bits</link>
<link id="TBits.clear">clear</link>
</seealso>
</element>

<element name="TBits.andbits">  <!-- Procedure -->
<short>Performs an <var>and</var> operation on the bits.</short>
<descr>
<var>andbits</var> performs an <var>and</var> operation on the bits in 
the array with the bits of array <var>BitSet</var>. If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are cleared.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.clearall">ClearAll</link>
<link id="TBits.orbits">OrBits</link>
<link id="TBits.xorbits">XOrBits</link>
<link id="TBits.notbits">NotBits</link>
</seealso>
</element>

<element name="TBits.orbits">  <!-- Procedure -->
<short>Performs an <var>or</var> operation on the bits.</short>
<descr>
<p>
<var>andbits</var> performs an <var>or</var> operation on the bits in 
the array with the bits of array <var>BitSet</var>. 
</p>
<p>
If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
<p>
If the current array contains less bits than <var>BitSet</var> then it is
grown to the size of <var>BitSet</var> before the <var>or</var> operation is
performed.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.clearall">ClearAll</link>
<link id="TBits.andbits">andBits</link>
<link id="TBits.xorbits">XOrBits</link>
<link id="TBits.notbits">NotBits</link>
</seealso>
</element>

<element name="TBits.xorbits">  <!-- Procedure -->
<short>Performs a <var>xor</var> operation on the bits.</short>
<descr>
<p><var>XorBits</var> performs a <var>xor</var> operation on the bits in 
the array with the bits of array <var>BitSet</var>. 
</p>
<p>If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
<p>
If the current array contains less bits than <var>BitSet</var> then it is
grown to the size of <var>BitSet</var> before the <var>xor</var> operation is
performed.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.clearall">ClearAll</link>
<link id="TBits.andbits">andBits</link>
<link id="TBits.orbits">OrBits</link>
<link id="TBits.notbits">NotBits</link>
</seealso>
</element>

<element name="TBits.notbits">  <!-- Procedure -->
<short>Performs a <var>not</var> operation on the bits.</short>
<descr>
<p><var>NotBits</var> performs a <var>not</var> operation on the bits in 
the array with the bits of array <var>Bitset</var>. 
</p>
<p>If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.clearall">ClearAll</link>
<link id="TBits.andbits">andBits</link>
<link id="TBits.orbits">OrBits</link>
<link id="TBits.xorbits">XOrBits</link>
</seealso>
</element>

<element name="TBits.get">  <!-- Function -->
<short>Retrieve the value of a particular bit</short>
<descr>
<var>Get</var> returns <var>True</var> if the bit at position <var>bit</var>
is set, or <var>False</var> if it is not set.
</descr>
<errors>
If <var>bit</var> is not a valid bit index then an <link id="EBitsError"/>
exception is raised.
</errors>
<seealso>
<link id="TBits.Bits">Bits</link>
<link id="TBits.FindFirstBit">FindFirstBit</link>
<link id="TBits.seton">seton</link>
</seealso>
</element>

<element name="TBits.grow">  <!-- Procedure -->
<short>Expands the bits array to the requested size.</short>
<descr>
<var>Grow</var> expands the bit array so it can at least contain
<var>nbit</var> bits. If <var>nbit</var> is less than the current size,
nothing happens.
</descr>
<errors>
If there is not enough memory to complete the operation, then an
<link id="EBitsError"/>is raised.
</errors>
<seealso>
<link id="TBits.Size">Size</link>
</seealso>
</element>

<element name="TBits.equals">  <!-- Function -->
<short>Determines whether the bits of 2 arrays are equal.</short>
<descr>
<p><var>equals</var> returns <var>True</var> if all the bits in <var>BitSet</var>
are the same as the ones in the current BitSet; if not, <var>False</var> is
returned.
</p>
<p>
If the sizes of the two BitSets are different, the arrays are still reported
equal when all the bits in the larger set, which are not present in the smaller 
set, are zero. 
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.clearall">ClearAll</link>
<link id="TBits.andbits">andBits</link>
<link id="TBits.orbits">OrBits</link>
<link id="TBits.xorbits">XOrBits</link>
</seealso>
</element>

<element name="TBits.SetIndex">  <!-- Procedure -->
<short>Sets the start position for <link
id="TBits.FindNextBit">FindNextBit</link> and <link
id="TBits.FindPrevBit">FindPrevBit</link></short>
<descr>
<p>
<var>SetIndex</var> sets the search start position for<link
id="TBits.FindNextBit">FindNextBit</link> and 
<link id="TBits.FindPrevBit">FindPrevBit</link> to <var>Index</var>.
This means that these calls will start searching from position
<var>Index</var>.
</p>
<p>This mechanism provides an alternative to <link
id="TBits.FindFirstBit">FindFirstBit</link> which can also be used to
position for the <var>FindNextBit</var> and <var>FindPrevBit</var> calls.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.FindNextBit">FindNextBit</link>
<link id="TBits.FindPrevBit">FindPrevBit</link>
<link id="TBits.FindFirstBit">FindFirstBit</link>
<link id="TBits.OpenBit">OpenBit</link>
</seealso>
</element>

<element name="TBits.FindFirstBit">  <!-- Function -->
<short>Find first bit with a particular value</short>
<descr>
<p>
<var>FindFirstBit</var> searches for the first bit with value
<var>State</var>. It returns the position of this bit, or <var>-1</var> if
no such bit was found.
</p>
<p>The search starts at position 0 in the array. If the first search
returned a positive result, the found position is saved, and the
<link id="TBits.FindNextBit">FindNextBit</link> and <link
id="TBits.FindPrevBit">FindPrevBit</link> will use this position to resume the
search. To start a search from a certain position, the start position can be
set with the <link id="TBits.SetIndex">SetIndex</link> instead.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.FindNextBit">FindNextBit</link>
<link id="TBits.FindPrevBit">FindPrevBit</link>
<link id="TBits.OpenBit">OpenBit</link>
<link id="TBits.SetIndex">SetIndex</link>
</seealso>
</element>

<element name="TBits.FindNextBit">  <!-- Function -->
<short>Searches the next bit with a particular value.</short>
<descr>
<p>
<var>FindNextBit</var> resumes a previously started search. It searches for
the next bit with the value specified in the <link
id="TBits.FindFirstBit">FindFirstBit</link>. The search is done towards the
end of the array and starts at the position last reported by one of the 
<var>Find</var> calls or at the position set with <link id="TBits.SetIndex">
SetIndex</link>.
</p>
<p>
If another bit with the same value is found, its position
is returned. If no more bits with the same value are present in the array,
<var>-1</var> is returned.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.FindFirstBit">FindFirstBit</link>
<link id="TBits.FindPrevBit">FindPrevBit</link>
<link id="TBits.OpenBit">OpenBit</link>
<link id="TBits.SetIndex">SetIndex</link>
</seealso>
</element>

<element name="TBits.FindPrevBit">  <!-- Function -->
<short>Searches the previous bit with a particular value.</short>
<descr>
<p>
<var>FindPrevBit</var> resumes a previously started search. It searches for
the previous bit with the value specified in the <link
id="TBits.FindFirstBit">FindFirstBit</link>. The search is done towards the
beginning of the array and starts at the position last reported by one of the 
<var>Find</var> calls or at the position set with <link id="TBits.SetIndex">
SetIndex</link>.
</p>
<p>
If another bit with the same value is found, its position
is returned. If no more bits with the same value are present in the array,
<var>-1</var> is returned.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.FindFirstBit">FindFirstBit</link>
<link id="TBits.FindNextBit">FindNextBit</link>
<link id="TBits.OpenBit">OpenBit</link>
<link id="TBits.SetIndex">SetIndex</link>
</seealso>
</element>

<element name="TBits.OpenBit">  <!-- Function -->
<short>Returns the position of the first bit that is set to <var>False</var>.</short>
<descr>
<var>OpenBit</var> returns the position of the first bit whose value is
<var>0</var> (<var>False</var>), or <var>-1</var> if no open bit was found. 
This call is equivalent to
<var>FindFirstBit(False)</var>, except that it doesn't set the position for
the next searches.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBits.FindFirstBit">FindNextBit</link>
<link id="TBits.FindPrevBit">FindPrevBit</link>
<link id="TBits.FindFirstBit">FindFirstBit</link>
<link id="TBits.SetIndex">SetIndex</link>
</seealso>
</element>

<element name="TBits.Bits">  <!-- Property -->
<short>Access to all bits in the array.</short>
<descr>
<var>Bits</var> allows indexed access to all of the bits in the array. It
gives <var>True</var> if the bit is <var>1</var>, <var>False</var>
otherwise; Assigning to this property will set, respectively clear the bit.
</descr>
<errors>
If an index is specified which is out of the allowed range then an <link
id="EBitsError"/> exception is raised.
</errors>
<seealso>
<link id="TBits.Size">Size</link>
</seealso>
</element>

<element name="TBits.Size">  <!-- Property -->
<short>Current size of the array of bits.</short>
<descr>
<var>Size</var> is the current size of the bit array. Setting this property
will adjust the size; this is equivalent to calling <var>Grow(Value-1)</var>
</descr>
<errors>
If an invalid size (negative or too large) is specified, a <link
id="EBitsError"/> exception is raised.
</errors>
<seealso>
<link id="TBits.Bits">Bits</link>
</seealso>
</element>

<!--
  *********************************************************************
  TPersistent
  *********************************************************************
-->

<element name="TPersistent">  <!-- Class -->
<short>Base class for streaming system and persistent properties.</short>
<descr>
<p><var>TPersistent</var> is the basic class for the streaming system. Since it
is compiled in the <var>{$M+}</var> state, the compiler generates  RTTI
(Run-Time Type Information) for it and all classes that descend from it.
This information can be used to stream all properties of classes.
</p>
<p>
It also introduces functionality to assign the contents of 2 classes to 
each other.
</p>
<p>
<var>TPersistent</var> implements the <link id="IFPObserved"/> interface for the benefit
of descendant classes, but does not call <link id="IFPObserved.FPONotifyObservers"/>.
Descendants such as <link id="TStrings"/> and <link id="TCollection"/> and
<link id="TCollectionItem"/> do use it.
</p>
</descr>
<seealso>
<link id="TComponent"/>
<link id="IFPObserved"/>
<link id="TStrings"/> 
<link id="TCollection"/>
<link id="TCollectionItem"/>
</seealso>
</element>

<element name="TPersistent.AssignError">  <!-- Procedure -->
<short>Raises an <var>EConvertError</var> when an error occurs during
assignment.</short>
<descr>
<var>AssignError</var> raises an <var>EConvertError</var> exception with
the classnames of the <var>Source</var> and destination classes. It is used
when two incompatible classes are assigned to each other.
</descr>
<seealso>
<link id="TPersistent.Assign">Assign</link>
<link id="TPersistent.AssignTo">AssignTo</link>
</seealso>
</element>

<element name="TPersistent.AssignTo">  <!-- Procedure -->
<short>Generic assignment function.</short>
<descr>
<p>
<var>AssignTo</var> is the generic function to assign the class' contents to 
another class. This method must be overridden by descendant classes to
actually assign the content of the source instance to the destination
instance. 
</p>
<p>
The <link id="TPersistent"/> implementation of <var>Assignto</var> raises 
an <var>EConvertError</var> exception. This is done for the following
reason: If the source class doesn't know how to assign itself to the
destination class (using <var>AssignTo</var>), the destination class may 
know how get the data from the source class (using <link
id="TPersistent.Assign">Assign</link>). If all descendant methods are
implemented correctly, then if neither of the two classes knows how to
assign their contents to each other, execution will end up at <link
id="TPersistent.Assign"/>, which will simply execute 
</p>
<code>
  Dest.AssignTo(Self);
</code>
<p>
If neither of the classes knows how to assign to/from each other, then
execution will end up at the <var>TPersistent</var> implementation of
<var>AssignTo</var>, and an exception will be raised.
</p>
</descr>
<seealso>
<link id="TPersistent.Assign">Assign</link>
</seealso>
</element>

<element name="TPersistent.DefineProperties">  <!-- Procedure -->
<short>Declare non-published properties that need to be streamed.</short>
<descr>
<p>
<var>DefineProperties</var> must be overridden by descendant classes to 
indicate to the streaming system which non-published properties must 
also be streamed.
</p>
<p>
The streaming systems stores only published properties in the stream.
Sometimes it is necessary to store additional data in the stream, data
which is not published. This can be done by overriding the
<var>DefineProperties</var> method. The <var>Filer</var> object is the
class that is responsible for writing all properties to the stream. 
</p>
<p>
To define new properties, two methods of the <link id="TFiler"/> class
should be used:
</p>
<ol>
<li><link id="TFiler.DefineProperty">DefineProperty</link>, to define a
property which can be represented as text.</li>
<li><link id="TFiler.DefineBinaryProperty">DefineProperty</link>, to define a
property which contains binary data.</li>
</ol>
<p>
On order for the streaming to work correctly, a call to the inherited 
<var>DefineProperties</var> is also needed, so ancestor objects also
get the possibility to read or write their private data to the stream.
Failure to call the inherited method will result in component properties not
being streamed correctly.
</p>
</descr>
<seealso>
<link id="TFiler.DefineProperties"/>
<link id="TFiler"/>
</seealso>
</element>

<element name="TPersistent.GetOwner">  <!-- Function -->
<short>Returns the owner of the component.</short>
<descr>
<var>GetOwner</var> returns the owning component of the classes instane. 
The <var>TPersistent</var> implementation of <var>GetOwner</var> returns
<var>Nil</var>. <link id="TComponent"/> overrides this method.
</descr>
<seealso>
<link id="TComponent"/>
</seealso>
</element>

<element name="TPersistent.Destroy">  <!-- Destructor -->
<short>Destroys the <var>TPersistent</var> instance.</short>
<descr>
<var>Destroy</var> disposes of the persistent object. This method should
never be called directly. Instead the <var>Free</var> method should be used.
</descr>
</element>

<element name="TPersistent.Assign">  <!-- Procedure -->
<short>Assign the contents of one class to another.</short>
<descr>
<p>
<var>Assign</var> copies the contents of <var>Source</var> to
<var>Self</var>, if the classes of the destination and source classes are
compatible.
</p>
<p>
The <var>TPersistent</var> implementation of <var>Assign</var> does nothing
but calling the <link id="TPersistent.AssignTo">AssignTo</link> method of
source. This means that if the destination class does not know how to assign
the contents of the source class, the source class instance is asked to assign
itself to the destination class. This means that it is necessary to
implement only one of the two methods so that two classes can be assiged to
one another.
</p>
<remark>
<p>
In general, a statement of the form
</p>
<code>
  Destination:=Source;
</code>
<p>
(where <var>Destination</var> and <var>Source</var> are classes) does not 
achieve the same as a statement of the form
</p>
<code>
  Destination.Assign(Source);
</code>
<p>After the former statement, both <var>Source</var> and
<var>Destination</var> will point to the same object. The latter statemtent
will copy the <i>contents</i> of the <var>Source</var> class to the
<var>Destination</var> class.
</p>
</remark>
</descr>
<seealso>
<link id="TPersistent.AssignTo">AssignTo</link>
</seealso>
</element>

<element name="TPersistent.GetNamePath">  <!-- Function -->
<short>Returns a string that can be used to identify the class instance.</short>
<descr>
<p>
<var>GetNamePath</var> returns a string that can be used to identify the
class instance. This can be used to display a name for this instance in a
Object designer.
</p>
<p>
<var>GetNamePath</var> constructs a name by recursively prepending the
<var>Classname</var> of the <var>Owner</var> instance to the
<var>Classname</var> of this instance, separated by a dot.
</p>
</descr>
<seealso>
<link id="TPersistent.GetOwner"/>
</seealso>
</element>

<element name="TPersistentClass">  <!-- "class of" type -->
<short>Class reference type for <link id="TPersistent"/>.</short>
<descr>
<var>TPersistentClass</var> is the class reference type for the <link id="TPersistent"/> class.
</descr>
<seealso>
<link id="TPersistent"/>
</seealso>
</element>

<!--
  *********************************************************************
  TCollectionItem
  *********************************************************************
-->

<element name="TCollectionItem">  <!-- Class -->
<short>Basic object that is managed by a <link id="TCollection"/> class.</short>
<descr>
<p><var>TCollectionItem</var> and <link id='TCollection'/> form a pair of base
classes that manage a collection of named objects. The
<var>TCollectionItem</var> is the named object that is managed, it
represents one item in the collection. An item in the collection is
represented by three properties: <link id="TCollectionItem.DisplayName"/>, 
<link id="TCollection.Index"/> and <link id="TCollectionItem.ID"/>.
</p>
<p>A <var>TCollectionItem</var> object is never created directly. To manage 
a set of named items, it is necessary to make a descendant of
<var>TCollectionItem</var> to which needed properties and methods are
added. This descendant can then be managed with a <link id="TCollection"/>
class. The managing collection will create and destroy it's items by itself,
it should therefore never be necessary to create <var>TCollectionItem</var>
descendants manually.
</p>
</descr>
<seealso>
<link id="TCollection"/>
</seealso>
</element>

<element name="TCollectionItem.Changed">  <!-- Procedure -->
<short>Method to notify the managing collection that the name or index of
this item has changed.
</short>
<descr>
This method is called when the <link id="TCollectionItem.DisplayName"/> is
set or when the <link id="TCollectionItem.Index"/> is changed.
</descr>
<seealso>
<link id="TCollectionItem.Id"/>
<link id="TCollectionItem.Index"/>
<link id="TCollection.Update"/>
</seealso>
</element>

<element name="TCollectionItem.GetNamePath">  <!-- Function -->
<short>Returns the namepath of this collection item.</short>
<descr>
<var>GetNamePath</var> overrides the <link id="TPersistent.GetNamePath"/>
method to return the name of the managing collection and appends its <link
id="TCollectionItem.Index"/> property.
</descr>
<seealso>
<link id="TCollectionItem.Collection"/>
<link id="TPersistent.GetNamePath"/>
<link id="TCollectionItem.Index"/>
</seealso>
</element>

<element name="TCollectionItem.GetOwner">  <!-- Function -->
<short>Returns the managing collection.</short>
<descr>
<var>TCollectionItem</var> overrides <link id="TPersistent.GetOwner"/> to
and returns the <link id="TCollectionItem.Collection"/> that manages it.
</descr>
<seealso>
<link id="TPersistent.GetOwner"/>
<link id="TCollectionItem.Collection"/>
</seealso>
</element>

<element name="TCollectionItem.GetDisplayName">  <!-- Function -->
<short>Returns the <link id="TCollectionItem.DisplayName"/> of the 
collectionitem</short>
<descr>
<p>
<var>GetDisplayName</var> returns the value of the 
<link id="TCollectionItem.DisplayName"/> property. 
By default, this is the classname of the actual <var>TCollectionItem</var> descendant.
</p>
<p>
Descendants of <var>TCollectionItem</var> can and should override this 
method to return a more meaningful value.
</p>
</descr>
<seealso>
<link id="TCollectionItem.DisplayName"/>
</seealso>
</element>

<element name="TCollectionItem.SetIndex">  <!-- Procedure -->
<short>Write method for the <link id="TCollectionItem.Index"/> property.</short>
<descr>
<var>SetIndex</var> implements the write handler for the <link
id="TCollectionItem.Index"/> property. It requests the managing collection to 
move this item to the desired index <var>value</var>.
</descr>
<seealso>
<link id="TCollectionItem.Index"/>
</seealso>
</element>

<element name="TCollectionItem.SetDisplayName">  <!-- Procedure -->
<short>Write method for the <link id="TCollectionItem.DisplayName"/> property</short>
<descr>
<p><var>SetDisplayName</var> is the write method for the <link
id="TCollectionItem.DisplayName"/> property. It does nothing but notifying
the managing collection that the displayname has changed. It does NOT store
the actual <var>Value</var>.
</p>
<p>
Descendants of <var>TCollectionItem</var> should override this method to 
store the actual displayname if this is required. 
</p>
</descr>
<seealso>
<link id="TCollectionItem.DisplayName"/>
</seealso>
</element>

<element name="TCollectionItem.Create">  <!-- Constructor -->
<short>Creates a new instance of this collection item.</short>
<descr>
<var>Create</var> instantiates a new item in a <link id="TCollection"/>. It
is called by the <link id="TCollection.Add"/> function and should under
normal circumstances never be called directly.
called 
</descr>
<seealso>
<link id="TCollectionItem.Destroy"/>
</seealso>
</element>

<element name="TCollectionItem.Destroy">  <!-- Destructor -->
<short>Destroyes this collection item.</short>
<descr>
<p><var>Destroy</var> removes the item from the managing collection 
and Destroys the item instance. 
</p>
<p>
This is the only way to remove items from a collection;
</p>
</descr>
<seealso>
<link id="TCollectionItem.Create"/>
</seealso>
</element>

<element name="TCollectionItem.Collection">  <!-- Property -->
<short>Pointer to the collection managing this item.</short>
<descr>
<var>Collection</var> points to the collection managing this item. This
property can be set to point to a new collection. If this is done, the old
collection will be notified that the item should no longer be managed, and
the new collection is notified that it should manage this item as well.
</descr>
<seealso>
<link id="TCollection"/>
</seealso>
</element>

<element name="TCollectionItem.ID">  <!-- Property -->
<short>Initial index of this item.</short>
<descr>
<p><var>ID</var> is the initial value of <link id="TCollectionItem.Index"/>;
it doesn't change after the index changes. It can be used to uniquely
identify the item. The <var>ID</var> property doesn't change as items are
added and removed from the collection.
</p>
<p>
While the <link id="TCollectionItem.Index"/> property forms a continuous 
series, <var>ID</var> does not. If items are removed from the collection, 
their <var>ID</var> is not used again, leaving gaps. Only when the
collection is initialiiy created, the <var>ID</var> and <var>Index</var>
properties will be equal.
</p>
</descr>
<seealso>
<link id="TCollection.Items"/>
<link id="TCollectionItem.Index"/>
</seealso>
</element>

<element name="TCollectionItem.Index">  <!-- Property -->
<short>Index of the item in its managing collection <link id="TCollection.Items"/> property.</short>
<descr>
<p>
<var>Index</var> is the current index of the item in its managing
collection's <link id="TCollection.Items"/> property. This property may
change as items are added and removed from the collection.
</p>
<p>The index of an item is zero-based, i.e. the first item has index zero.
The last item has index <var>Count-1</var> where <var>Count</var> is the
number of items in the collection.
</p>
<p>
The <var>Index</var> property of the items in a collection form a continuous
series ranging from <var>0</var> to <var>Count-1</var>. The <link
id="TCollectionItem.ID"/> property does not form a continuous series, but
can also be used to identify an item. 
</p>
</descr>
<seealso>
<link id="TCollectionItem.ID"/>
<link id="TCollection.Items"/>
</seealso>
</element>

<element name="TCollectionItem.DisplayName">  <!-- Property -->
<short>Name of the item, displayed in the object inspector.</short>
<descr>
<p>
<var>DisplayName</var> contains the name of this item as shown in the object
inspector. For <var>TCollectionItem</var> this returns always the class name 
of the managing collection, followed by the index of the item.
</p>
<p><var>TCollectionItem</var> does not implement any functionality to store
the <var>DisplayName</var> property. The property can be set, but this will
have no effect other than that the managing collection is notified of a
change. The actual displayname will remain unchanged. To store the
<var>DisplayName</var> property,<var>TCollectionItem</var> descendants
should override the <link id="TCollectionItem.SetDisplayName"/> and
<link id="TCollectionItem.GetDisplayName"/> to add storage functionality.
</p>
</descr>
<seealso>
<link id="TCollectionItem.Index"/>
<link id="TCollectionItem.ID"/>
<link id="TCollectionItem.GetDisplayName"/>
<link id="TCollectionItem.SetDisplayName"/>
</seealso>
</element>

<element name="TCollectionItemClass">  <!-- "class of" type -->
<short>Class reference for <link id="TCollectionItem"/>.</short>
<descr>
<var>TCollectionItemClass</var> is used by the 
<link id="TCollection.ItemClass"/> property of <link id="TCollection"/> to
identify the descendant class of <link id="TCollectionItem"/> which should
be created and managed.
</descr>
<seealso>
<link id="TCollectionItem"/>
<link id="TCollection.ItemClass"/>
</seealso>
</element>

<!--
  *********************************************************************
  TCollection
  *********************************************************************
-->

<element name="TCollection">  <!-- Class -->
<short>Base class to manage collections of named objects.</short>
<descr>
<p><var>TCollection</var> implements functionality to manage a collection
of named objects. Each of these objects needs to be a descendant of the 
<link id="TCollectionItem"/> class. Exactly which type of object is managed
can be seen from the <link id="TCollection.ItemClass"/> property.
</p>
<p>
Normally, no <var>TCollection</var> is created directly. Instead, a 
descendants of <var>TCollection</var> and <link id="TCollectionItem"/> 
are created as a pair.
</p>
</descr>
<seealso>
<link id="TCollectionItem"/>
</seealso>
</element>

<element name="TCollection.GetAttrCount">  <!-- Function -->
<short>Returns the count of attributes associated with each item.</short>
<descr>
<p>
<var>GetAttrCount</var> returns 0 in the <var>TCollection</var>
implementation. It can be used to determine the number of attributes
associated with each collection item. Descendant objects should override
this method to return the number of attributes.
</p>
<p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
</descr>
<seealso>
<link id="TCollection.GetAttr"/>
<link id="TCollection.GetItemAttr"/>
</seealso>
</element>

<element name="TCollection.GetAttr">  <!-- Function -->
<short>Returns an attribute of the collection.</short>
<descr>
<p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
</descr>
<seealso>
<link id="TCollection.GetAttrCount"/>
<link id="TCollection.GetItemAttr"/>
</seealso>
</element>

<element name="TCollection.GetItemAttr">  <!-- Function -->
<short>Returns the attributes of an item.</short>
<descr>
<p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
</descr>
<seealso>
<link id="TCollection.GetAttr"/>
<link id="TCollection.GetAttrCount"/>
</seealso>
</element>

<element name="TCollection.GetNamePath">  <!-- Function -->
<short>Overrides <link id="TPersistent.GetNamePath"/> to return a proper
pathname.</short>
<descr>
<p>
<var>GetNamePath</var> returns the name path for this collection. If the
following conditions are satisfied:
</p>
<ol>
<li>There is an owner object.</li>
<li>The owner object returns a non-empty name path.</li>
<li>The <link id="TCollection.Propname"/> property is not empty</li>
</ol>
<p>
collection has an owner and the owning object has a name, then the function
returns the owner name, followed by the propname. If one of the conditions
is not satisfied, then the classname is returned.
</p>
</descr>
<seealso>
<link id="TCollection.GetOwner"/>
<link id="TCollection.Propname"/>
</seealso>
</element>

<element name="TCollection.Changed">  <!-- Procedure -->
<short>Procedure called if an item is added to or removed from the collection.</short>
<descr>
<var>Changed</var> is called if a change takes place in the collection
managed by the class. If the update count ghas reached zero, it 
calls <link id="TCollection.Update"/> with a nil argument.
</descr>
<seealso>
<link id="TCollection.Update"/>
<link id="TCollection.Add"/>
<link id="TCollection.Clear"/>
</seealso>
</element>

<element name="TCollection.GetItem">  <!-- Function -->
<short>Read handler for the <link id="TCollection.Items"/> property.</short>
<descr>
<var>GetItem</var> is the read handler for the <link
id="TCollection.Items"/> property. It returns the <var>Index</var>-th
element from the list of objects.
</descr>
<errors>
If <var>Index</var> is outside the allowed range, then an <link
id="EListError"/> exception is raised.
</errors>
<seealso>
<link id="TCollection.Items"/>
<link id="TCollection.Count"/>
<link id="TCollection.SetItem"/>
</seealso>
</element>

<element name="TCollection.SetItem">  <!-- Procedure -->
<short>Write handler for the <link id="TCollection.Items"/> property.</short>
<descr>
<var>SetItem</var> implements the write handler for the <link
id="TCollection.Items"/> property. It assignes <var>Value</var> to the 
<var>Index</var>-th element in the array. For this to work properly, the
<link id="TPersistent.Assign"/> method of the <var>Item</var> must work 
correctly.
</descr>
<errors>
If <var>Index</var> is outside the allowed range, then an <link
id="EListError"/> exception is raised.
</errors>
<seealso>
<link id="TCollection.Items"/>
<link id="TCollection.Count"/>
<link id="TCollection.GetItem"/>
</seealso>
</element>

<element name="TCollection.SetItemName">  <!-- Procedure -->
<short>Virtual method to set the name of the specified item</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TCollection.SetPropName">  <!-- Procedure -->
<short>Write handler for the <link id="TCollection.PropName"/> property</short>
<descr>
<var>SetPropName</var> must be overridden by descendant objects to set the 
<link id="TCollection.PropName"/> property to a suitable value. By default,
<var>SetPropName</var> sets the <var>PropName</var> property to empty.
</descr>
<seealso>
<link id="TCollection.PropName"/> 
</seealso>
</element>

<element name="TCollection.Update">  <!-- Procedure -->
<short>Hander called when an item in the collection has changed.</short>
<descr>
<p><var>Update</var> is called in the following cases:
</p>
<ol>
<li>An item is added to or removed from the collection.</li>
<li>An item is moved in the list, i.e. its <link id="TCollectionItem.Index"/>
property changes.</li>
<li>An item's <link id="TCollectionItem.DisplayName"/> property
changes.</li>
</ol>
<p>
Descendant classes can override this method to perform additional actions
when the collection changes. The <var>Item</var> parameter indicates the
item that was changed. This can be <var>Nil</var>
</p>
</descr>
<seealso>
<link id="TCollection.Changed"/>
</seealso>
</element>

<element name="TCollection.PropName">  <!-- Property -->
<short>Name of the property that this collection represents.</short>
<descr>
<var>PropName</var> indicates the name of the property that this collection
is supposed to represent. By default, this is the empty string. Descendants
can override this property to return the name of the property that is
represented by this collection.
</descr>
<seealso>
<link id="TCollection.SetPropName"/>
<link id="TCollection.GetPropName"/>
</seealso>
</element>

<element name="TCollection.Create">  <!-- Constructor -->
<short>Creates a new collection.</short>
<descr>
<var>Create</var> instantiates a new instance of the <var>TCollection</var> 
class which will manage objects of class <var>AItemClass</var>. 
It creates the list used to hold all objects, and stores the 
<var>AItemClass</var> for the adding of new objects to the collection.
</descr>
<seealso>
<link id="TCollection.ItemClass"/>
<link id="TCollection.Destroy"/>
</seealso>
</element>

<element name="TCollection.Destroy">  <!-- Destructor -->
<short>Destroys the collection and frees all the objects it manages.</short>
<descr>
<p>
<var>Destroy</var> first clears the collection, and then frees all memory
allocated to this instance. 
</p>
<p>
Don't call <var>Destroy</var> directly, call <var>Free</var> instead.
</p>
</descr>
<seealso>
<link id="TCollection.Create"/>
</seealso>
</element>

<element name="TCollection.Add">  <!-- Function -->
<short>Creates and adds a new item to the collection.</short>
<descr>
<var>Add</var> instantiates a new item of class <link
id="TCollection.ItemClass"/> and adds it to the list. The newly created
object is returned.
</descr>
<seealso>
<link id="TCollection.ItemClass"/>
<link id="TCollection.Clear"/>
</seealso>
</element>

<element name="TCollection.Assign">  <!-- Procedure -->
<short>Assigns one collection to another.</short>
<descr>
<p>
<var>Assign</var> assigns the contents of one collection to another.
It does this by clearing the items list, and adding as much elements as
there are in the <var>Source</var> collection; it assigns to each created
element the contents of it's counterpart in the <var>Source</var> element.
</p>
<p>
Two collections cannot be assigned to each other if instances of the
<var>ItemClass</var> classes cannot be assigned to each other. 
</p>
</descr>
<errors>
If the objects in the collections cannot be assigned to one another, then
an <var>EConvertError</var> is raised.
</errors>
<seealso>
<link id="TPersistent.Assign"/>
<link id="TCollectionItem"/>
</seealso>
</element>

<element name="TCollection.BeginUpdate">  <!-- Procedure -->
<short>Start an update batch.</short>
<descr>
<p>
<var>BeginUpdate</var> is called at the beginning of a batch update. It
raises the update count with 1.  
</p>
<p>
Call <var>BeginUpdate</var> at the beginning of a series of operations that
will change the state of the collection. This will avoid the call to 
<link id="TCollection.Update"/> for each operation.
At the end of the operations, a corresponding call to <var>EndUpdate</var> 
must be made. It is best to do this in the context of a 
<var>Try ... finally</var> block:
</p>
<code>
  With MyCollection Do
    try
      BeginUpdate;
      // Some Lengthy operations
    finally
      EndUpdate;
    end;  
</code>
<p>
This insures that the number of calls to <var>BeginUpdate</var> always
matches the number of calls to <link id="TCollection.EndUpdate"/>, even in
case of an exception.
</p>
</descr>
<seealso>
<link id="TCollection.EndUpdate"/>
<link id="TCollection.Changed"/>
<link id="TCollection.Update"/>
</seealso>
</element>

<element name="TCollection.Clear">  <!-- Procedure -->
<short>Removes all items from the collection.</short>
<descr>
<var>Clear</var> will clear the collection, i.e. each item in the collection
is destroyed and removed from memory. 
After a call to <var>Clear</var>, <var>Count</var> is zero.
</descr>
<seealso>
<link id="TCollection.Add"/>
<link id="TCollectionItem.Destroy"/>
<link id="TCollection.Destroy"/>
</seealso>
</element>

<element name="TCollection.EndUpdate">  <!-- Procedure -->
<short>Ends an update batch.</short>
<descr>
<var>EndUpdate</var> signals the end of a series of operations that change
the state of the collection, possibly triggering an update event. 
It does this by decreasing the update count with 1 and calling <link
id="TCollection.Changed"/> it should always be used in conjunction with
<link id="TCollection.BeginUpdate"/>, preferably in the <var>Finally</var>
section of a <var>Try ... Finally</var> block.
</descr>
<seealso>
<link id="TCollection.BeginUpdate"/>
<link id="TCollection.Changed"/>
<link id="TCollection.Update"/>
</seealso>
</element>

<element name="TCollection.FindItemID">  <!-- Function -->
<short>Searches for an Item in the collection, based on its
<link id="TCollectionItem.ID"/> property.</short>
<descr>
<p>
<var>FindItemID</var> searches through the collection for the item that has
a value of <var>ID</var> for its <link id="TCollectionItem.ID"/> property,
and returns the found item. If no such item is found in the collection, 
<var>Nil</var> is returned. 
</p>
<p>The routine performs a linear search, so this can be slow on very large
collections.
</p>
</descr>
<seealso>
<link id="TCollection.Items"/>
<link id="TCollectionItem.ID"/>
</seealso>
</element>

<element name="TCollection.Count">  <!-- Property -->
<short>Number of items in the collection.</short>
<descr>
<p>
<var>Count</var> contains the number of items in the collection. 
</p>
<remark>
The items in the collection are identified by their <link
id="TCollectionItem.Index"/> property, which is a zero-based index, meaning
that it can take values between <var>0</var> and <var>Count-1</var>, borders
included.
</remark>
</descr>
<seealso>
<link id="TCollectionItem.Index"/>
<link id="TCollection.Items"/>
</seealso>
</element>

<element name="TCollection.ItemClass">  <!-- Property -->
<short>Class pointer for each item in the collection.</short>
<descr>
<var>ItemClass</var> is the class pointer with which each new item in the
collection is created. It is the value that was passed to the collection's
constructor when it was created, and does not change during the lifetime of
the collection.
</descr>
<seealso>
<link id="TCollectionItem"/>
<link id="TCollection.Items"/>
</seealso>
</element>

<element name="TCollection.Items">  <!-- Property -->
<short>Indexed array of items in the collection.</short>
<descr>
<p>
<var>Items</var> provides indexed access to the items in the collection.
Since the array is zero-based, <var>Index</var> should be an integer 
between <var>0</var> and <var>Count-1</var>.
</p>
<p>It is possible to set or retrieve an element in the array. When setting
an element of the array, the object that is assigned should be compatible
with the class of the objects in the collection, as given by the 
<link id="TCollection.ItemClass"/> property.
</p>
<p>Adding an element to the array can be done with the <link
id="TCollection.Add"/> method. The array can be cleared with the <link
id="TCollection.Clear"/> method. Removing an element of the array should
be done by freeing that element.
</p>
</descr>
<seealso>
<link id="TCollection.Count"/>
<link id="TCollection.ItemClass"/>
<link id="TCollection.Clear"/>
<link id="TCollection.Add"/>
</seealso>
</element>

<!--
  *********************************************************************
  IStringsAdapter
  *********************************************************************
-->

<element name="IStringsAdapter">  <!-- Class -->
<short>IStringsAdapter Interface declaration.</short>
<descr>Is not yet supported in Free Pascal.
</descr>
<seealso>
<link id="TStrings"/>
</seealso>
</element>

<!--
  *********************************************************************
  TStrings
  *********************************************************************
-->

<element name="TStrings">  <!-- Class -->
<short>Class to manage arrays or collections of strings</short>
<descr>
<p><var>TStrings</var> implements an abstract class to manage an array of
strings. It introduces methods to set and retrieve strings in the array,
searching for a particular string, concatenating the strings and so on.
It also allows an arbitrary object to be associated with each string.
</p>
<p>
It also introduces methods to manage a series of <var>name=value</var> 
settings, as found in many configuration files.
</p>
<p>An instance of <var>TStrings</var> is never created directly, instead a
descendant class such as <link id="TStringList"/> should be created. This is
because <var>TStrings</var> is an abstract class which does not implement
all methods; <var>TStrings</var> also doesn't store any strings, this is the
functionality introduced in descendants such as <link id="TStringList"/>.
</p>
<p>
<var>TStrings</var> implements the <link id="IFPObserved"/> interface: when
the stringlist is changed, a <var>ooChanged</var> notification is sent to
all observers.
</p>
</descr>
<seealso>
<link id="TStringList"/>
<link id="IFPObserved"/>
</seealso>
</element>

<element name="TStrings.DefineProperties">  <!-- Procedure -->
<short>Method to stream the contents of the string collection</short>
<descr>
<var>DefineProperties</var> allows the contents of the string collection
to be streamed. As such, it overrides <link id="TPersistent.DefineProperties"/>
</descr>
<seealso>
<link id="TPersistent.DefineProperties"/>
</seealso>
</element>

<element name="TStrings.Error">  <!-- Procedure -->
<short>Raises an <link id="EStringListError"/> exception.</short>
<descr>
<p>
<var>Error</var> raises an <link id="EStringListError"/> exception. It passes
<var>Msg</var> as a format with <var>Data</var> as the only argument.
</p>
<p>This method can be used by descendant objects to raise an error.</p>
</descr>
<seealso>
<link id="EStringListError"/>
</seealso>
</element>

<element name="TStrings.Get">  <!-- Function -->
<short>Abstract read handler for the <link id="TStrings.Strings"/> property.</short>
<descr>
<p>
<var>Get</var> is the abstract read handler for the <link id="TStrings.Strings"/> 
property. This is an abstract method, hence it is not implemented in 
<var>TStrings</var>.
</p>
<p>
Descendant classes, such as <link id="TStringList"/> must override this
method and implement a routine that retrieves the <var>Index</var>-th string
in the list. <var>Index</var> should have a value between <var>0</var> and
<var>Count-1</var>, in all other cases an error should be raised using
<link id="TStrings.Error"/>.
</p>
</descr>
<seealso>
<link id="TStrings.Strings"/>
<link id="TStrings.Put"/>
<link id="TStrings.GetObject"/>
</seealso>
</element>

<element name="TStrings.GetCapacity">  <!-- Function -->
<short>Abstract Read handler for the <link id="TStrings.Capacity"/> property.</short>
<descr>
<p>
<var>GetCapacity</var> is the read handler for the <link
id="TStrings.Capacity"/> property. The implementation in <var>TStrings</var>
will return 0. 
</p>
<p>Descendant classes can override this method. It should return the 
current number of strings that can be held by the stringlist before 
it attempts to expand it's storage space.
</p>
</descr>
<seealso>
<link id="TStrings.Capacity"/>
<link id="TStrings.SetCapacity"/>
</seealso>
</element>

<element name="TStrings.GetCount">  <!-- Function -->
<short>Abstract read handler for the <link id="TStrings.Count"/> property.</short>
<descr>
<p>
<var>GetCount</var> is the abstract read handler for the <link
id="TStrings.Count"/> property. This is an abstract method, hence it is not implemented in 
<var>TStrings</var>.
</p>
<p>
Descendant classes must override this method. It should return the 
current number of strings in the list. (empty strings included). 
</p>
</descr>
<seealso>
<link id="TStrings.Count"/>
</seealso>
</element>

<element name="TStrings.GetObject">  <!-- Function -->
<short>Abstract read handler for the <link id="TStrings.Objects"/> property.</short>
<descr>
<p>
<var>GetObject</var> is the read handler for the <link
id="TStrings.Objects"/> property. The <var>TStrings</var> implementation of
this method ignores the <var>Index</var> argument and simply 
returns <var>Nil</var>.
</p>
<p>
Descendant classes that should support object storage should override this
method and return the object associated to the <var>Index</var>-th string 
in the list. <var>Index</var> should have a value between <var>0</var> and
<var>Count-1</var>. If <var>Index</var> is outside the allowed range, an
error should be raised using <link id="TStrings.Error"/>.
</p>
</descr>
<seealso>
<link id="TStrings.Objects"/>
<link id="TStrings.PutObject"/>
<link id="TStrings.Get"/>
</seealso>
</element>

<element name="TStrings.GetTextStr">  <!-- Function -->
<short>Read handler for the <link id="TStrings.Text"/> property.</short>
<descr>
<p><var>GetTextStr</var> is the read handler for the <link id="TStrings.Text"/>
property. It simply concatenates all strings in the list with a linefeed between
them, and returns the resulting string.
</p>
<p>
Descendant classes may override this method to implement a more efficient
algorithm which is more suitable to their storage method.
</p>
</descr>
<seealso>
<link id="TStrings.Text"/>
<link id="TStrings.SetTextStr"/>
</seealso>
</element>

<element name="TStrings.Put">  <!-- Procedure -->
<short>Write handler for the <link id="TStrings.Strings"/> property.</short>
<descr>
<p>
<var>Put</var> is the write handler for the <link id="TStrings.Strings"/> 
property. It does this by saving the object associated to the 
<var>Index</var>-th string, deleting the <var>Index</var>-th string, and
inserting <var>S</var> and the saved object at position <var>Index</var>
with <link id="TStrings.InsertObject"/>
</p>
<p>
Descendant classes may wish to override <var>Put</var> to implement a more
efficient method. 
</p>
</descr>
<seealso>
<link id="TStrings.Strings"/>
<link id="TStrings.Get"/>
<link id="TStrings.PutObject"/>
</seealso>
</element>

<element name="TStrings.PutObject">  <!-- Procedure -->
<short>Write handler for the <link id="TStrings.Objects"/> property.</short>
<descr>
<p>
<var>PutObject</var> is the write handler for the <link
id="TStrings.Objects"/> property. The <var>TStrings</var> implementation of 
<var>PutObject</var> does nothing.
</p>
<p>
Descendant objects that should support Object storage must override this
method to store the <var>AObject</var> so that it is associated with the
<var>Index</var>-th string in the list. <var>Index</var> should have a value
between <var>0</var> and <var>Count-1</var>. If the value of
<var>Index</var> is out of range, an error should be raised using <link
id="TStrings.Error"/>.
</p>
</descr>
<seealso>
<link id="TStrings.Objects"/>
<link id="TStrings.GetObject"/>
<link id="TStrings.Put"/>
</seealso>
</element>

<element name="TStrings.SetCapacity">  <!-- Procedure -->
<short>Write handler for the <link id="TStrings.Capacity"/> property.</short>
<descr>
<p>
<var>SetCapacity</var> is the write handler for the <link
id="TStrings.Capacity"/> property. The <var>TStrings</var> implementation
of <var>SetCapacity</var> does nothing.
</p>
<p>
Descendant classes can override this method to set the current capacity of
the stringlist to <var>NewCapacity</var>. The capacity is the number of strings the list can hold
before it tries to expand its storage space. <var>NewCapacity</var> should
be no less than <var>Count</var>. 
</p>
</descr>
<seealso>
<link id="TStrings.Capacity"/>
<link id="TStrings.GetCapacity"/>
</seealso>
</element>

<element name="TStrings.SetTextStr">  <!-- Procedure -->
<short>Write handler for the <link id="TStrings.Text"/> property.</short>
<descr>
<p>
<var>SetTextStr</var> is the write method for the <link id="TStrings.Text"/>
property. It does nothing other than calling <link id="TStrings.SetText"/>.
</p>
<p>
Descendant classes may override this method to implement a more efficient 
algoritm that fits their storage method better.
</p>
</descr>
<seealso>
<link id="TStrings.Text"/>
<link id="TStrings.GetTextStr"/>
</seealso>
</element>

<element name="TStrings.SetUpdateState">  <!-- Procedure -->
<short>Sets the update state.</short>
<descr>
<p>
<var>SetUpdateState</var> sets the update state to <var>Updating</var>. The
<var>TStrings</var> implementation of <var>SetUpdateState</var> does
nothing.
</p>
<p>
Descendant objects may override this method to implement optimizations. If
<var>Updating</var> is <var>True</var> then the list of strings is about to
be updated (possibly many times). If it is <var>False</var> no more updates
will take place till the next <var>SetUpdateState</var> call.
</p>
</descr>
<seealso>
<link id="TStrings.BeginUpdate"/>
<link id="TStrings.EndUpdate"/>
</seealso>
</element>

<element name="TStrings.Destroy">  <!-- Destructor -->
<short>Frees all strings and objects, and removes the list from memory.</short>
<descr>
<var>Destroy</var> is the destructor of <var>TStrings</var> it does nothing
except calling the inherited destructor.
</descr>
<seealso>
</seealso>
</element>

<element name="TStrings.Add">  <!-- Function -->
<short>Add a string to the list</short>
<descr>
<var>Add</var> adds <var>S</var> at the end of the list and returns the
index of <var>S</var> in the list (which should equal <link id="Tstrings.Count"/>
</descr>
<seealso>
<link id="TStrings.Objects"/>
<link id="TStrings.AddObject"/>"
<link id="TStrings.Insert"/>
<link id="TStrings.Delete"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Count"/>
</seealso>
</element>

<element name="TStrings.AddObject">  <!-- Function -->
<short>Add a string and associated object to the list.</short>
<descr>
<p>
<var>AddObject</var> adds <var>S</var> to the list of strings, and
associates <var>AObject</var> with it. It returns the index of <var>S</var>.
</p>
<remark>
An object added to the list is not automatically destroyed by the list of
the list is destroyed or the string it is associated with is deleted. It is
the responsibility of the application to destroy any objects associated with
strings.
</remark>
</descr>
<seealso>
<link id="TStrings.Add"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Objects"/>
<link id="TStrings.InsertObject"/>
</seealso>
</element>

<element name="TStrings.Append">  <!-- Procedure -->
<short>Add a string to the list.</short>
<descr>
<var>Append</var> does the same as <link id="TStrings.Add"/>, only it does
not return the index of the inserted string. 
</descr>
<seealso>
<link id="TStrings.Add"/>
</seealso>
</element>

<element name="TStrings.AddStrings">  <!-- Procedure -->
<short>Add contents of another stringlist to this list.</short>
<descr>
<var>AddStrings</var> adds the contents of <var>TheStrings</var> to the
stringlist. Any associated objects are added as well.
</descr>
<seealso>
<link id="TStrings.Add"/>
<link id="TStrings.Assign"/>
</seealso>
</element>

<element name="TStrings.Assign">  <!-- Procedure -->
<short>Assign the contents of another stringlist to this one.</short>
<descr>
<var>Assign</var> replaces the contents of the stringlist with the contents
of <var>Source</var> if <var>Source</var> is also of type
<var>TStrings</var>. Any associated objects are copied as well.
</descr>
<seealso>
<link id="TStrings.Add"/>
<link id="TStrings.AddStrings"/>
<link id="TPersistent.Assign"/>
</seealso>
</element>

<element name="TStrings.BeginUpdate">  <!-- Procedure -->
<short>Mark the beginning of an update batch.</short>
<descr>
<p>
<var>BeginUpdate</var> increases the update count by one. It is advisable to
call <var>BeginUpdate</var> before lengthy operations on the stringlist. At
the end of these operation, <link id="TStrings.EndUpdate"/> should be
called to mark the end of the operation.  Descendant classes may use this
information to perform optimizations. e.g. updating the screen only once
after many strings were added to the list.
</p>
<p>
All <var>TStrings</var> methods that modify the string list call
<var>BeginUpdate</var> before the actual operation, and call
<var>endUpdate</var> when the operation is finished. Descendant classes
should also call these methods when modifying the string list. 
</p>
<remark>
<p>
Always put the corresponding call to <link id="TStrings.EndUpdate"/> in the
context of a <var>Finally</var> block, to ensure that the update count is
always descreased at the end of the operation, even if an exception
occurred:
</p>
<code>
  With MyStrings do
    try
      BeginUpdate;
      // Some lengthy operation.
    Finally
      EndUpdate
    end;  
</code>
</remark>
</descr>
<seealso>
<link id="TStrings.EndUpdate"/>
</seealso>
</element>

<element name="TStrings.Clear">  <!-- Procedure -->
<short>Removes all strings and associated objects from the list.</short>
<descr>
<p>
<var>Clear</var> will remove all strings and their associated objects from
the list. After a call to clear, <link id="TStrings.Count"/> is zero.
</p>
<p>
Since it is an abstract method, <var>TStrings</var> itself does not implement 
<var>Clear</var>. Descendant classes such as <link
id="TStringList"/> implement this method.
</p>
</descr>
<seealso>
<link id="TStrings.Objects"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Delete"/>
<link id="TStrings.Count"/>"
</seealso>
</element>

<element name="TStrings.Delete">  <!-- Procedure -->
<short>Delete a string from the list.</short>
<descr>
<p>
<var>Delete</var> deletes the string at position <var>Index</var> from the
list. The associated object is also removed from the list, but not
destroyed. <var>Index</var> is zero-based, and should be in the range 
<var>0</var> to <var>Count-1</var>.
</p>
<p>
Since it is an abstract method, <var>TStrings</var> itself does not implement 
<var>Delete</var>. Descendant classes such as <link
id="TStringList"/> implement this method.
</p>
</descr>
<errors>
If <var>Index</var> is not in the allowed range, an <link
id="EStringListError"/> is raised.
</errors>
<seealso>
<link id="TStrings.Insert"/>
<link id="TStrings.Objects"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Clear"/>
</seealso>
</element>

<element name="TStrings.EndUpdate">  <!-- Procedure -->
<short>Mark the end of an update batch.</short>
<descr>
<p>
<var>EndUpdate</var> should be called at the end of a lengthy operation on
the stringlist, but only if there was a call to <var>BeginUpdate</var> before
the operation was started. It is best to put the call to
<var>EndUpdate</var> in the context of a <var>Finally</var> block, so it
will be called even if an exception occurs.
</p>
<p>
For more information, see <link id="TStrings.BeginUpdate"/>.
</p>
<p>
<var>TStrings</var> implements the <link id="IFPObserved"/> interface: when
<var>EndUpdate</var> is called, a <var>ooChanged</var> notification is sent to
all observers.
</p>
</descr>
<seealso>
<link id="TStrings.BeginUpdate"/>
<link id="IFPObserved"/>
</seealso>
</element>

<element name="TStrings.Equals">  <!-- Function -->
<short>Compares the contents of two stringlists.</short>
<descr>
<p>
<var>Equals</var> compares the contents of the stringlist with the contents
of <var>TheStrings</var>. If the contents match, i.e. the stringlist contain 
an equal amount of strings, and all strings match, then <var>True</var> is
returned. If the number of strings in the lists is unequal, or they
contain one or more different strings, <var>False</var> is returned.
</p>
<remark>
<ol>
<li>The strings are compared case-insensitively.</li>
<li>The associated objects are not compared</li>
</ol>
</remark> 
</descr>
<seealso>
<link id="TStrings.Objects"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Count"/>
<link id="TStrings.Assign"/>
</seealso>
</element>

<element name="TStrings.Exchange">  <!-- Procedure -->
<short>Exchanges two strings in the list.</short>
<descr>
<p>
<var>Exchange</var> exchanges the strings at positions <var>Index1</var>
and <var>Index2</var>. The associated objects are also exchanged.
</p>
<p>
Both indexes must be in the range of valid indexes, i.e. must have a
value between <var>0</var> and <var>Count-1</var>.
</p>
</descr>
<errors>
If either <var>Index1</var> or <var>Index2</var> is not in the range of valid
indexes, an <link id="EStringListError"/> exception is raised.
</errors>
<seealso>
<link id="TStrings.Move"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Count"/>
</seealso>
</element>

<element name="TStrings.GetText">  <!-- Function -->
<short>Returns the contents as a PChar</short>
<descr>
<p>
<var>GetText</var> allocates a memory buffer and compies the contents of the
stringlist to this buffer as a series of strings, separated by an
end-of-line marker. The buffer is zero terminated.
</p>
<remark>
The caller is responsible for freeing the returned memory buffer. 
</remark>
</descr>
<seealso>
</seealso>
</element>

<element name="TStrings.IndexOf">  <!-- Function -->
<short>Find a string in the list and return its position.</short>
<descr>
<p>
<var>IndexOf</var> searches the list for <var>S</var>. The search is
case-insensitive. If a matching entry is found, its position is returned.
if no matching string is found, <var>-1</var> is returned.
</p>
<remark>
<ol>
<li>Only the first occurrence of the string is returned.</li>
<li>The returned position is zero-based, i.e. 0 indicates the first string
in the list.</li>
</ol>
</remark>
</descr>
<seealso>
<link id="TStrings.IndexOfObject"/>
<link id="TStrings.IndexOfName"/>
<link id="TStrings.Strings"/>
</seealso>
</element>

<element name="TStrings.IndexOfName">  <!-- Function -->
<short>Finds the index of a name in the name-value pairs.</short>
<descr>
<p>
<var>IndexOfName</var> searches in the list of strings for a name-value pair
with name part <var>Name</var>. If such a pair is found, it returns the
index of the pair in the stringlist. If no such pair is found, the function
returns <var>-1</var>. The search is done case-insensitive.
</p>
<remark>
<ol>
<li>Only the first occurrence of a matching name-value pair is returned.</li>
<li>The returned position is zero-based, i.e. 0 indicates the first string
in the list.</li>
</ol>
</remark>
</descr>
<seealso>
<link id="TStrings.IndexOf"/>
<link id="TStrings.IndexOfObject"/>
<link id="TStrings.Strings"/>
</seealso>
</element>

<element name="TStrings.IndexOfObject">  <!-- Function -->
<short>Finds an object in the list and returns its index.</short>
<descr>
<p>
<var>IndexOfObject</var> searchs through the list of strings till it find a
string associated with <var>AObject</var>, and returns the index of this
string. If no such string is found, <var>-1</var> is returned.
</p>
<remark>
<ol>
<li>Only the first occurrence of a string with associated object
<var>AObject</var> is returned; if more strings in the list can be
associated with <var>AObject</var>, they will not be found by this routine.</li>
<li>The returned position is zero-based, i.e. 0 indicates the first string
in the list.</li>
</ol>
</remark>
</descr>
<seealso>
</seealso>
</element>

<element name="TStrings.Insert">  <!-- Procedure -->
<short>Insert a string in the list.</short>
<descr>
<p>
<var>Insert</var> inserts the string <var>S</var> at position
<var>Index</var> in the list. <var>Index</var> is a zero-based position, 
and can have values from <var>0</var> to <var>Count</var>. If
<var>Index</var> equals <var>Count</var> then the string is appended to the
list.
</p>
<remark>
<ol>
<li>All methods that add strings to the list use <var>Insert</var> to add
a string to the list.</li>
<li>If the string has an associated object, use <link
id="TStrings.InsertObject"/> instead.</li>
</ol>
</remark>
</descr>
<errors>
If <var>Index</var> is less than zero or larger than <var>Count</var> then
an <link id="EStringListError"/> exception is raised.
</errors>
<seealso>
<link id="TStrings.Add"/>
<link id="TStrings.InsertObject"/>
<link id="TStrings.Append"/>
<link id="TStrings.Delete"/>
</seealso>

</element>

<element name="TStrings.InsertObject">  <!-- Procedure -->
<short>Insert a string and associated object in the list.</short>
<descr>
<p>
<var>InsertObject</var> inserts the string <var>S</var> and its associated
object<var>AObject</var> at position <var>Index</var> in the list. 
<var>Index</var> is a zero-based position, and can have values from 
<var>0</var> to <var>Count</var>. If <var>Index</var> equals 
<var>Count</var> then the string is appended to the list.
</p>
</descr>
<errors>
If <var>Index</var> is less than zero or larger than <var>Count</var> then
an <link id="EStringListError"/> exception is raised.
</errors>
<seealso>
<link id="TStrings.Insert"/>
<link id="TStrings.AddObject"/>
<link id="TStrings.Append"/>
<link id="TStrings.Delete"/>
</seealso>
</element>

<element name="TStrings.LoadFromFile">  <!-- Procedure -->
<short>Load the contents of a file as a series of strings.</short>
<descr>
<p>
<var>LoadFromFile</var> loads the contents of a file into the stringlist.
Each line in the file (as marked by the end-of-line marker of the
particular OS the application runs on) becomes one string in the stringlist. 
This action replaces
the contents of the stringlist, it does not append the strings to the
current content.
</p>
<p>
<var>LoadFromFile</var> simply creates a <link id="TFileStream">file
stream</link> with the given filename, and then executes 
<link id="TStrings.LoadfromStream"/>; after that the file stream object 
is destroyed again.
</p>
</descr>
<seealso>
<link id="TStrings.LoadFromStream"/>
<link id="TStrings.SaveToFile"/>
<link id="Tstrings.SaveToStream"/>
</seealso>
</element>

<element name="TStrings.LoadFromStream">  <!-- Procedure -->
<short>Load the contents of a stream as a series of strings.</short>
<descr>
<var>LoadFromStream</var> loads the contents of <var>Stream</var>
 into the stringlist.
Each line in the stream (as marked by the end-of-line marker of the
particular OS the application runs on) becomes one string in the stringlist. 
This action replaces
the contents of the stringlist, it does not append the strings to the
current content. 
</descr>
<seealso>
<link id="TStrings.LoadFromFile"/>
<link id="TStrings.SaveToFile"/>
<link id="Tstrings.SaveToStream"/>
</seealso>
</element>

<element name="TStrings.Move">  <!-- Procedure -->
<short>Move a string from one place in the list to another.</short>
<descr>
<p>
<var>Move</var> moves the string at position <var>CurIndex</var> so
it has position <var>NewIndex</var> after the move operation. The object
associated to the string is also moved. <var>CurIndex</var> and
<var>NewIndex</var> should be in the range of <var>0</var> to
<var>Count-1</var>.
</p>
<remark>
<p>
<var>NewIndex</var> is <em>not</em> the position in the stringlist before
the move operation starts. The move operation
</p>
<ol>
<li>removes the string from position <var>CurIndex</var></li>
<li>inserts the string at position <var>NewIndex</var></li>
</ol>
<p>
This may not lead to the desired result if <var>NewIndex</var> is bigger
than <var>CurIndex</var>. Consider the following example:
</p>
<code>
  With MyStrings do
    begin
    Clear;
    Add('String 0');
    Add('String 1');
    Add('String 2');
    Add('String 3');
    Add('String 4');
    Move(1,3);
    end;
</code>
<p>
After the <var>Move</var> operation has completed, 'String 1' will be between 'String 3'
and 'String 4'. 
</p>
</remark>
</descr>
<errors>
If either <var>CurIndex</var> or <var>NewIndex</var> is outside the allowed
range, an <link id="EStringListError"/> is raised.
</errors>
<seealso>
<link id="TStrings.Exchange"/>
</seealso>
</element>

<element name="TStrings.SaveToFile">  <!-- Procedure -->
<short>Save the contents of the list to a file.</short>
<descr>
<p>
<var>SaveToFile</var> saves the contents of the stringlist to the file with
name <var>FileName</var>. It writes the strings to the file, separated by
end-of-line markers, so each line in the file will contain 1 string from the
stringlist.
</p>
<p>
<var>SaveToFile</var> creates a <link id="TFileStream">file stream</link>
with name <var>FileName</var>, calls <link id="TStrings.SaveToStream"/>
and then destroys the file stream object.
</p>
</descr>
<errors>
An <link id="EStreamError"/> exception can be raised if the file <var>FileName</var> cannot be opened,
or if it cannot be written to.
</errors>
<seealso>
<link id="TStrings.SaveToStream"/>
<link id="Tstrings.LoadFromStream"/>
<link id="TStrings.LoadFromFile"/>
</seealso>
</element>

<element name="TStrings.SaveToStream">  <!-- Procedure -->
<short>Save the contents of the string to a stream.</short>
<descr>
<p>
<var>SaveToStream</var> saves the contents of the stringlist to
<var>Stream</var>. It writes the strings to the stream, separated by
end-of-line markers, so each 'line' in the stream will contain 1 string from the
stringlist.
</p>
</descr>
<errors>
An <link id="EStreamError"/> exception can be raised if the stream cannot be written to.
</errors>
<seealso>
<link id="TStrings.SaveToFile"/>
<link id="Tstrings.LoadFromStream"/>
<link id="TStrings.LoadFromFile"/>
</seealso>
</element>

<element name="TStrings.SetText">  <!-- Procedure -->
<short>Set the contents of the list from a PChar.</short>
<descr>
<var>SetText</var> parses the contents of <var>TheText</var> and fills the
stringlist based on the contents. It regards <var>TheText</var> as a series
of strings, separated by end-of-line markers. Each of these strings is added
to the stringlist.
</descr>
<seealso>
<link id="TStrings.Text"/>
</seealso>
</element>

<element name="TStrings.Capacity">  <!-- Property -->
<short>Capacity of the list, i.e. number of strings that the list can
currently hold before it tries to expand.</short>
<descr>
<p>
<var>Capacity</var> is the number of strings that the list can hold before
it tries to allocate more memory. 
</p>
<p><var>TStrings</var> returns <link id="TStrings.Count"/> when read. Trying
to set the capacity has no effect. Descendant classes such as 
<link id="TStringlist"/> can override this property such that it actually
sets the new capacity.
</p>
</descr>
<seealso>
<link id="TStringList"/>
<link id="TStrings.Count"/>
</seealso>
</element>

<element name="TStrings.GetNameValue">
<short>Return both name and value of a name,value pair based on it's index.</short>
<descr></descr>
</element>


<element name="TStrings.Delimiter">
<short>Delimiter character used in <link id="#rtl.classes.TStrings.DelimitedText">DelimitedText</link>.</short>
<descr>
<var>Delimiter</var> is the delimiter character used to separate the
different strings in the stringlist when they are read or set through the
<link id="TStrings.DelimitedText">DelimitedText</link> property.
</descr>
<seealso>
<link id="TStrings.DelimitedText"/>
</seealso>
</element>


<element name="TStrings.DelimitedText">
<short>Get or set all strings in the list in a delimited form.</short>
<descr>
<p>
<var>DelimitedText</var> returns all strings, properly quoted with <link
id="TStrings.Quotechar">QuoteChar</link> and separated by the <link
id="TStrings.Delimiter">Delimiter</link> character.
</p>
<p>
Strings are quoted if they contain a space or any character with ASCII value
less than 32.
</p>
<p>
The <link id="TStrings.CommaText">CommaText</link> property is a special
case of delimited text where the delimiter character is a comma and the
quote character is a double quote.
</p>
<p>
If <link id="TStrings.StrictDelimiter">StrictDelimiter</link> is set to
<var>True</var>, then no quoting is done (The <var>QuoteChar</var> property 
is disregarded completely): the returned text will contain
the items in the stringlist, separated by the <var>Delimiter</var>
character. When writing the <var>DelimitedText</var> property, the text will
be split at all occurrences of the <var>Delimiter</var> character; however, 
when reading, the <var>QuoteChar</var> property will be taken into account.
</p>
</descr>
<seealso>
<link id="TStrings.Delimiter"/>
<link id="TStrings.Text"/>
<link id="TStrings.QuoteChar"/>
<link id="TStrings.CommaText"/>
</seealso>
</element>


<element name="TStrings.QuoteChar">
<short>Quote character used in <link id="#rtl.classes.TStrings.DelimitedText">DelimitedText</link>.</short>
<descr>
<var>QuoteChar</var> is the character used by the  <link
id="TStrings.DelimitedText">DelimitedText</link>  property to quote strings
that have a space or non-printing character in it.
</descr>
</element>

<element name="TStrings.NameValueSeparator">
<short>Value of the character used to separate name,value pairs</short>
<descr>
<p>
<var>NameValueSeparator</var> is the character used to separate name,value
pair. By default, this is the equal sign (=), resulting in Name=Value pairs.
</p>
<p>
It can be set to a colon for Name : Value pairs.
</p>
</descr>
</element>


<element name="TStrings.ValueFromIndex">
<short>Return the value part of a string based on it's index.</short>
<descr>
<var>ValueFromIndex</var> returns the value part of a string based on the
string index. The value part are all characters in the string after the 
<link id="TStrings.NameValueSeparator">NameValueSeparator</link>
character, or all characters if the <var>NameValueSeparator</var> character
is not present.
</descr>
</element>


<element name="TStringList.CustomSort">
<short>Sort the stringlist using a custom sort algorithm</short>
<descr>
<var>CustomSort</var> sorts the stringlist with a custom comparison
function. The function should compare 2 elements in the list, and return a
negative number if the first item is before the second. It should return 0
if the elements are equal, and a positive result indicates that the second
elements should be before the first.
</descr>
<seealso>
<link id="TStringList.Sorted"/>
<link id="TStringList.Sort"/>
</seealso>
</element>


<element name="TStringList.CaseSensitive">
<short>Indicates whether comparing strings happens in a case sensitive manner.</short>
<descr>
<p>
<var>CaseSensitive</var> indicates how string values are compared: When
<var>True</var> this happens case sensitively, and when <var>False</var>,
case must match.
</p>
<p>
This property influences <link id="TStrings.IndexOf">IndexOf</link>, <link
id="TStringList.Find">Find</link>, <link id="TStrings.IndexOfName">IndexOfName</link>
and <link id="TStringList.Sort">Sort</link>.
</p>
</descr>
<seealso>
<link id="TStrings.IndexOf">IndexOf</link>
<link id="TStringList.Find">Find</link>
<link id="TStrings.IndexOfName">IndexOfName</link> 
<link id="TStringList.Sort">Sort</link>
</seealso>
</element>

<element name="TStrings.CommaText">  <!-- Property -->
<short>Contents of the list as a comma-separated string.</short>
<descr>
<p>
<var>CommaText</var> represents the stringlist as a single string,
consisting of a comma-separated concatenation of the strings in the list. 
If one of the strings contains spaces, comma's or quotes it will be enclosed by 
double quotes. Any double quotes in a string will be doubled. For instance
the following strings:
</p>
<pre>
Comma,string
Quote"string
Space string
NormalSttring
</pre>
<p>
is converted to
</p>
<code>
"Comma,string","Quote""String","Space string",NormalString
</code>
<p>
Conversely, when setting the <var>CommaText</var> property, the text will be parsed
according to the rules outlined above, and the strings will be set
accordingly. Note that spaces will in this context be regarded as string
separators, unless the string as a whole is contained in double quotes.
Spaces that occur next to a delimiter will be ignored.
The following string:
</p>
<pre>
"Comma,string" , "Quote""String",Space string,, NormalString
</pre>
<p>
Will be converted to
</p>
<pre>
Comma,String
Quote"String
Space
String

NormalString
</pre>
<p>
This is a special case of the <link id="TStrings.DelimitedText"/> property where the
quote character is always the double quote, and the delimiter is always the
colon.
</p>
</descr>
<seealso>
<link id="TStrings.Text"/>
<link id="TStrings.SetText"/>
</seealso>
</element>

<element name="TStrings.Count">  <!-- Property -->
<short>Number of strings in the list.</short>
<descr>
<p>
<var>Count</var> is the current number of strings in the list.
<var>TStrings</var> does not implement this property; descendant classes
should override the property read handler to return the correct value.
</p>
<p>
Strings in the list are always uniquely identified by their
<var>Index</var>; the index of a string is zero-based, i.e. it's supported
range is <var>0</var> to <var>Count-1</var>. trying to access a string with
an index larger than or equal to <var>Count</var> will result in an error.
Code that iterates over the list in a stringlist should always take into
account the zero-based character of the list index.
</p>
</descr>
<seealso>
<link id="TStrings.Strings"/>
<link id="TStrings.Objects"/>
<link id="TStrings.Capacity"/>
</seealso>
</element>

<element name="TStrings.Names">  <!-- Property -->
<short>Name parts of the name-value pairs in the list.</short>
<descr>
<p>
<var>Names</var> provides indexed access to the names of the name-value
pairs in the list. It returns the name part of the <var>Index</var>-th
string in the list.
</p>
<remark>
The index is not an index based on the number of name-value pairs in the
list. It is the name part of the name-value pair a string <var>Index</var>
in the list. If the string at position <var>Index</var> is not a name-value
pair (i.e. does not contain the equal sign (=)), then an empty name is
returned.
</remark> 
</descr>
<seealso>
<link id="TStrings.Values"/>
<link id="TStrings.IndexOfName"/>
</seealso>
</element>

<element name="TStrings.Objects">  <!-- Property -->
<short>Indexed access to the objects associated with the strings in the
list.</short>
<descr>
<p>
<var>Objects</var> provides indexed access to the objects associated to
the strings in the list. <var>Index</var> is a  zero-based index and 
must be in the range of <var>0</var> to <var>Count-1</var>. 
</p>
<p>
Setting the <var>objects</var> property will not free the previously associated object,
if there was one. The caller is repsonsible for freeing the object that
was previously associated to the string.
</p>
<p>
<var>TStrings</var> does not implement any storage for objects. Reading the
<var>Objects</var> property will always return <var>Nil</var>, Setting the
property will have no effect. It is the responsability of the descendant
classes to provide storage for the associated objects.
</p>
</descr>
<errors>
If an <var>Index</var> outside the valid range is specified, an <link
id="EStringListError"/> exception will be raised.
</errors>
<seealso>
<link id="TStrings.Strings"/>
<link id="TStrings.IndexOfObject"/>
<link id="TStrings.Names"/>
<link id="TStrings.Values"/>
</seealso>
</element>

<element name="TStrings.Values">  <!-- Property -->
<short>Value parts of the name-value pairs in the list.</short>
<descr>
<p>
<var>Values</var> represents the value parts of the name-value pairs in the
list.
</p>
<p>
When reading this property, if there is a name-value pair in the list 
of strings that has name part <var>Name</var>, then the corresponding value 
is returned. If there is no such pair, an empty string is returned.
</p>
<p>
When writing this value, first it is checked whether there exists a 
name-value pair in the list with name <var>Name</var>. If such a pair is
found, it's value part is overwritten with the specified value. If no
such pair is found, a new name-value pair is added with the specified
<var>Name</var> and value.
</p>
<remark>
<ol>
<li>Names are compared case-insensitively.</li>
<li>Any character, including whitespace, up till the first equal (=) sign 
in a string is considered part of the name.</li>
</ol>
</remark>
</descr>
<seealso>
<link id="TStrings.Names"/>
<link id="TStrings.Strings"/>
<link id="TStrings.Objects"/>
</seealso>
</element>

<element name="TStrings.Strings">  <!-- Property -->
<short>Indexed access to the strings in the list.</short>
<descr>
<p>
<var>Strings</var> is the default property of <var>TStrings</var>. It
provides indexed read-write access to the list of strings. Reading it will
return the string at position <var>Index</var> in the list. Writing it will
set the string at position <var>Index</var>. 
</p>
<p>
<var>Index</var> is the position of the string in the list. It is
zero-based, i.e. valued values range from <var>0</var> (the first string in
the list) till <var>Count-1</var> (the last string in the list). 
When browsing through the strings in the list, this fact must be taken into
account.
</p>
<p>
To access the objects associated with the strings in the list, use the <link
id="TStrings.Objects"/> property. The name parts of name-value pairs can be
accessed with the <link id="TStrings.Names"/> property, and the values can
be set or read through the <link id="TStrings.Values"/> property.
</p>
<p>
Searching through the list can be done using the <link
id="TStrings.IndexOf"/> method.
</p>
</descr>
<errors>
If <var>Index</var> is outside the allowed range, an <link
id="EStringListError"/> exception is raised.
</errors>
<seealso>
<link id="TStrings.Count"/>
<link id="TStrings.Objects"/>
<link id="TStrings.Names"/>
<link id="TStrings.Values"/>
<link id="TStrings.IndexOf"/>
</seealso>
</element>

<element name="TStrings.Text">  <!-- Property -->
<short>Contents of the list as one big string.</short>
<descr>
<p>
<var>Text</var> returns, when read, the contents of the stringlist as one 
big string consisting of all strings in the list, separated by an
end-of-line marker. When this property is set, the string will be cut into
smaller strings, based on the positions of end-of-line markers in the
string. Any previous content of the stringlist will be lost.
</p>
<remark>
If any of the strings in the list contains an end-of-line marker, then the
resulting string will appear to contain more strings than actually present
in the list. To avoid this ambiguity, use the <link id="TStrings.CommaText"/> 
property instead.
</remark>
</descr>
<seealso>
<link id="TStrings.Strings"/>
<link id="TStrings.Count"/>
<link id="TStrings.CommaText"/>
</seealso>
</element>

<element name="TStrings.StringsAdapter">  <!-- Property -->
<short>Not implemented in Free Pascal.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TDuplicates">  <!-- Enumeration type -->
<short>Type to describe what to do with duplicate values in a <link
id="TStringlist"/>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TDuplicates.dupIgnore">  <!-- Enumeration value -->
<short>Duplicate values will not be added to the list, but no error will
be triggered.</short>
</element>

<element name="TDuplicates.dupAccept">  <!-- Enumeration value -->
<short>Duplicate values can be added to the list.</short>
</element>

<element name="TDuplicates.dupError">  <!-- Enumeration value -->
<short>If an attempt is made to add a duplicate value to the list, an
<link id="EStringListError"/> exception is raised.</short>
</element>

<element name="dupIgnore">  <!-- Enumeration value -->
<short>Duplicate values will not be added to the list, but no error will
be triggered.</short>
</element>

<element name="dupAccept">  <!-- Enumeration value -->
<short>Duplicate values can be added to the list.</short>
</element>

<element name="dupError">  <!-- Enumeration value -->
<short>If an attempt is made to add a duplicate value to the list, an <link id="EStringListError"/> exception is raised.</short>
</element>

<element name="TStringItemList">  <!-- Array type -->
<short>Array of <link id="TStringItem"/> records.</short>
<descr>
This declaration is provided for Delphi compatibility, it is not used in
Free Pascal.
</descr>
</element>



<!--
  *********************************************************************
  TStringList
  *********************************************************************
-->

<element name="TStringList">  <!-- Class -->
<short>Standard implementation of the <link id="TStrings"/> class.</short>
<descr>
<p>
<var>TStringList</var> is a descendant class of <link id="TStrings"/> that
implements all of the abstract methods introduced there. It also introduces 
some additional methods:
</p>
<ul>
<li>Sort the list, or keep the list sorted at all times</li>
<li>Special handling of duplicates in sorted lists</li>
<li>Notification of changes in the list</li>
</ul>
</descr>
<seealso>
<link id="TStrings"/>
<link id="TStringList.Duplicates"/>
<link id="TStringList.Sorted"/>
</seealso>
</element>

<element name="TStringList.Changed">  <!-- Procedure -->
<short>Called when the list of strings was modified.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Changing">  <!-- Procedure -->
<short>Called when the list is changing.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Get">  <!-- Function -->
<short>Overrides the standard read handler for the <link id="TStrings.Strings"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.GetCapacity">  <!-- Function -->
<short>Overrides the standard read handler for the <link
id="TStrings.Capacity"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.GetCount">  <!-- Function -->
<short>Overrides the standard read handler for the <link   
id="TStrings.Count"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.GetObject">  <!-- Function -->
<short>Overrides the standard read handler for the <link   
id="TStrings.Objects"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Put">  <!-- Procedure -->
<short>Overrides the standard write handler for the <link   
id="TStrings.Strings"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.PutObject">  <!-- Procedure -->
<short>Overrides the standard write handler for the <link
id="TStrings.Objects"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.SetCapacity">  <!-- Procedure -->
<short>Overrides the standard write handler for the <link
id="TStrings.Capacity"/> property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.SetUpdateState">  <!-- Procedure -->
<short>Overrides the standard <link id="TStrings.SetUpdateState"/>
call.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Destroy">  <!-- Destructor -->
<short>Destroys the stringlist.</short>
<descr>
<p>
<var>Destroy</var> clears the stringlist, release all memory allocated for
the storage of the strings, and then calls the inherited destroy method.
</p>
<remark>
Any objects associated to strings in the list will <em>not</em> be
destroyed; it is the responsability of the caller to destroy all objects
associated with strings in the list.
</remark>
</descr>
</element>

<element name="TStringList.Add">  <!-- Function -->
<short>Implements the <link id="TStrings.Add"/> function.</short>
<descr>
<p>
<var>Add</var> will add <var>S</var> to the list. If the list is sorted and
the string <var>S</var> is already present in the list and 
<link id="TStringList.Duplicates"/> is <var>dupError</var> then an <link
id="EStringListError"/> exception is raised. If <var>Duplicates</var> is
set to <var>dupIgnore</var> then the return value is the index of the
previous entry.
</p>
<p>
If the list is sorted, new strings will not necessarily be added to the end
of the list, rather they will be inserted at their alphabetical position.
</p>
</descr>
<errors>
If the list is sorted and the string <var>S</var> is already present in the list and 
<link id="TStringList.Duplicates"/> is <var>dupError</var> then an <link
id="EStringListError"/> exception is raised.
</errors>
<seealso>
<link id="TStringList.Insert"/>
<link id="TStringList.Duplicates"/>
</seealso>
</element>

<element name="TStringList.Clear">  <!-- Procedure -->
<short>Implements the <link id="TStrings.Clear"/> function.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Delete">  <!-- Procedure -->
<short>Implements the <link id="TStrings.Delete"/> function.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Exchange">  <!-- Procedure -->
<short>Implements the <link id="TStrings.Exchange"/> function.</short>
<descr>
<p>
<var>Exchange</var> will exchange two items in the list as described in 
<link id="TStrings.Exchange"/>. 
</p>
<remark>
<var>Exchange</var> will not check whether the list os sorted or not; 
if <var>Exchange</var> is called on a sorted list and the strings are not
identical, the sort order of the list will be destroyed.
</remark>
</descr>
<seealso>
<link id="TStringList.Sorted"/>
<link id="TStrings.Exchange"/>
</seealso>
</element>

<element name="TStringList.Find">  <!-- Function -->
<short>Locates the index for a given string in sorted lists.</short>
<descr>
<p>
<var>Find</var> returns <var>True</var> if the string <var>S</var> is present in the
list. Upon exit, the <var>Index</var> parameter will contain the position of
the string in the list. If the string is not found, the function will return
<var>False</var> and <var>Index</var> will contain the position where the
string will be inserted if it is added to the list.
</p>
<remark>
<ol>
<li>Use this method only on sorted lists. For unsorted lists, use <link
id="TStringList.IndexOf"/> instead.</li>
<li>Find uses a binary search method to locate the string</li>
</ol>
</remark>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.IndexOf">  <!-- Function -->
<short>Overrides the <link id="TStrings.IndexOf"/> property.</short>
<descr>
<var>IndexOf</var> overrides the ancestor method <link
id="TStrings.indexOf"/>. It tries to optimize the
search by executing a binary search if the list is sorted. The function
returns the position of <var>S</var> if it is found in the list, or -1 if
the string is not found in the list.
</descr>
<seealso>
<link id="TStrings.IndexOf"/>
<link id="TStringList.Find"/>
</seealso>
</element>

<element name="TStringList.Insert">  <!-- Procedure -->
<short>Overrides the <link id="TStrings.Insert"/> method.</short>
<descr>
<var>Insert</var> will insert the string <var>S</var> at position
<var>Index</var> in the list. If the list is sorted, an <link
id="EStringListError"/> exception will be raised instead. <var>Index</var>
is a zero-based position. 
</descr>
<errors>
If <var>Index</var> contains an invalid value (less than zero or larger than
<var>Count</var>, or the list is sorted, an <link id="EStringListError"/>
exception will be raised.
</errors>
<seealso>
<link id="TStringList.Add"/>
<link id="TStrings.Insert"/>
<link id="TStrings.InsertObject"/>
</seealso>
</element>

<element name="TStringList.Sort">  <!-- Procedure -->
<short>Sorts the strings in the list.</short>
<descr>
<var>Sort</var> will sort the strings in the list using the quicksort
algorithm. If the list has its <link id="TStringList.Sorted"/> property set
to <var>True</var> then nothing will be done. 
</descr>
<seealso>
<link id="TStringList.Sorted"/>
</seealso>
</element>

<element name="TStringList.Duplicates">  <!-- Property -->
<short>Describes the behaviour of a sorted list with respect to duplicate
strings.</short>
<descr>
<p>
<var>Duplicates</var> describes what to do in case a duplicate value is
added to the list:
</p>
<table>
<tr><td>dupIgnore</td><td><printshort id="TDuplicates.dupIgnore"/></td></tr>
<tr><td>dupError</td><td><printshort id="TDuplicates.dupError"/></td></tr>
<tr><td>dupAccept</td><td><printshort id="TDuplicates.dupAccept"/></td></tr>
</table>
<p>
If the stringlist is not sorted, the <var>Duplicates</var> setting is
ignored.
</p>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringList.Sorted">  <!-- Property -->
<short>Determines whether the list is sorted or not.</short>
<descr>
<p>
<var>Sorted</var> can be set to <var>True</var> in order to cause the list
of strings to be sorted. Further additions to the list will be inserted at
the correct position so the list remains sorted at all times. Setting the 
property to <var>False</var> has no immediate effect, but will allow strings
to be inserted at any position.
</p>
<remark>
<ol>
<li>
When <var>Sorted</var> is <var>True</var>, <link id="TStringList.Insert"/>
cannot be used. For sorted lists, <link id="TStringList.Add"/> should be
used instead.</li>
<li>If <var>Sorted</var> is <var>True</var>, the <link
id="TStringList.Duplicates"/> setting has effect. This setting is ignored
when <var>Sorted</var> is <var>False</var>.</li>
</ol>
</remark>
</descr>
<seealso>
<link id="TStringList.Sort"/>
<link id="TStringList.Duplicates"/>
<link id="TStringList.Add"/>
<link id="TstringList.Insert"/>
</seealso>
</element>

<element name="TStringList.OnChange">  <!-- Property -->
<short>Event triggered after the list was modified.</short>
<descr>
<p>
<var>OnChange</var> can be assigned to respond to changes that have occurred
in the list. The handler is called whenever strings are added, moved,
modified or deleted from the list. 
</p>
<p>
The <var>Onchange</var> event is triggered after the modification took place. 
When the modification is about to happen, an <link
id="TstringList.OnChanging"/> event occurs.
</p>
</descr>
<seealso>
<link id="TStringList.OnChanging"/>
</seealso>
</element>

<element name="TStringList.OnChanging">  <!-- Property -->
<short>Event triggered when the list is about to be modified.</short>
<descr>
<p>
<var>OnChanging</var> can be assigned to respond to changes that will occurred
in the list. The handler is called whenever strings will be added, moved,
modified or deleted from the list.
</p>
<p>
The <var>Onchanging</var> event is triggered before the modification will
take place. When the modification has happened, an <link           
id="TstringList.OnChange"/> event occurs.
</p>
</descr> 
<seealso>
<link id="TStringList.OnChange"/>
</seealso>
</element>

<!--
  *********************************************************************
  TStream
  *********************************************************************
-->

<element name="TStream">  <!-- Class -->
<short>Base class for streams.</short>
<descr>
<p>
<var>TStream</var> is the base class for all streaming classes. It defines
methods for <link id="TStream.Read">reading</link>, <link
id="TStream.Write">writing</link> from and to streams, as well as functions to
determine the size of the stream as well as the current position of the
stream.
</p>
<p>Descendant classes such as <link id="TMemoryStream"/> or <link
id="TFileStream"/> then override these methods to write streams to
memory or file.
</p>
</descr>
<seealso>
<link id="TMemoryStream"/>
<link id="TFileStream"/>
<link id="TStringStream"/>
</seealso>
</element>

<element name="TStream.SetSize">  <!-- Procedure -->
<short>Sets the size of the stream</short>
<descr>
<var>SetSize</var> is the write handler for the <link id="TStream.Size"/>
property. The <var>TStream</var> implementation of <var>SetSize</var> does
nothing, but descendant classes may override this methods to allow
programmers to set the size of the stream.
</descr>
<seealso>
<link id="TStream.GetSize"/>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TStream.Read">  <!-- Function -->
<short>Reads data from the stream to a buffer and returns the number of
bytes read.</short>
<descr>
<p>
<var>Read</var> attempts to read <var>Count</var> from the stream to 
<var>Buffer</var> and returns the number of bytes actually read.
</p>
<p>This method should be used when the number of bytes is not determined. 
If a specific number of bytes is expected, use <link
id="TSTream.ReadBuffer"/> instead. 
</p>
<p>
As implemented in <var>TStream</var>, <var>Read</var> does nothing but
raises an <link id="EStreamError"/> exception to indicate that reading 
is not supported. Descendant classes that allow reading must override 
this method to do the actual reading.
</p>
<p>
Descendant classes should (if they don't explicitly raise an exception) return a
positive value (>=0), where zero indicates an error.
</p>
</descr>
<errors>
In case a descendant class does not allow reading from the stream, an
exception is raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadBuffer"/>
</seealso>
</element>

<element name="TStream.Write">  <!-- Function -->
<short>Writes data from a buffer to the stream and returns the number of
bytes written.</short>
<descr>
<p>
<var>Write</var> attempts to write <var>Count</var> bytes from
<var>Buffer</var> to the stream. It returns the actual number of bytes
written to the stream.
</p>
<p>This method should be used when the number of bytes that should be
written is not determined. If a specific number of bytes should be 
written, use <link id="TSTream.WriteBuffer"/> instead. 
</p>
<p>
As implemented in <var>TStream</var>, <var>Write</var> does nothing but
raises <link id="EStreamError"/> exception to indicate that writing is not supported.
Descendant classes that allow writing must override this method to do the actual writing.
</p>
<p>
Descendant classes should (if they don't explicitly raise an exception) return a
positive value (>=0), where zero indicates an error.
</p>
</descr>
<errors>
In case a descendant class does not allow writing to the stream, an
exception is raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteBuffer"/>
</seealso>
</element>

<element name="TStream.Seek">  <!-- Function -->
<short>Sets the current position in the stream</short>
<descr>
<p>
<var>Seek</var> sets the position of the stream to <var>Offset</var> bytes
from <var>Origin</var>. There is a 32-bit variant of this function and a
64-bit variant. The difference can be made by choosing the correct
<var>Offset</var> parameter: the integer-typed parameter selects the 32-bit
variant, the parameter of type <link id="TSeekOrigin"/> selects the 64-bit
variant of the function.
</p>
<p>
The <var>Origin</var> parameter for the 32-bit version can have one of the following values:
</p>
<table>
<tr><td>Constant</td><td>Meaning</td></tr>
<tr><td>soFromBeginning</td><td>Set the position relative to the start of the stream.</td></tr>
<tr><td>soFromCurrent</td><td>Set the position relative to the current position in the stream.</td></tr>
<tr><td>soFromEnd</td><td>Set the position relative to the end of the stream.</td></tr>
</table>
<p>
These values are defined in the <link id="SysUtils"/> unit.
</p>
<p>
The <var>Origin</var> parameter for the 64-bit version has one of the following values:
</p>
<table>
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>soBeginning</td><td><printshort id="TSeekOrigin.soBeginning"/></td></tr>
<tr><td>soCurrent</td><td><printshort id="TSeekOrigin.soCurrent"/></td></tr>
<tr><td>soEnd</td><td><printshort id="TSeekOrigin.soEnd"/></td></tr>
</table>
<p>
<var>Offset</var> should be negative when the origin is <var>SoFromEnd</var> (<var>soEnd</var>). 
It should be positive for <var>soFromBeginning</var> and can have both signs for <var>soFromCurrent</var>
</p>
<p>
This is an abstract method, which must be overridden by descendant classes.
They may choose not to implement this method for all values of
<var>Origin</var> and <var>Offset</var>. 
</p>
<remark>
Internally, all calls are re-routed to the 64-bit version of the call.
When creating a descendant of <var>TStream</var>, the 64-bit version of the call should
be overridden.
</remark>
</descr>
<errors>
An exception may be raised if this method is called with an invalid pair of
<var>Offset</var>,<var>Origin</var> values. e.g. a negative
<var>offset</var> for <var>soFromBeginning</var> (or <var>soBeginning</var>).
</errors>
<seealso>
<link id="TStream.Position"/>
</seealso>
</element>

<element name="TStream.ReadBuffer">  <!-- Procedure -->
<short>Reads data from the stream to a buffer</short>
<descr>
<p>
<var>ReadBuffer</var> reads <var>Count</var> bytes of the stream into
<var>Buffer</var>. If the stream does not contain <var>Count</var> bytes,
then an exception is raised.
</p>
<p>
<var>ReadBuffer</var> should be used to read in a fixed number of bytes,
such as when reading structures or the content of variables. If the number
of bytes is not determined, use <link id="TStream.Read"/> instead.
<var>ReadBuffer</var> uses <var>Read</var> internally to do the actual
reading.
</p>
</descr>
<errors>
If the stream does not allow to read <var>Count</var> bytes, then an
exception is raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteBuffer"/>
</seealso>
</element>

<element name="TStream.WriteBuffer">  <!-- Procedure -->
<short>Writes data from a buffer to the stream</short>
<descr>
<p>
<var>WriteBuffer</var> writes <var>Count</var> bytes to the stream from
<var>Buffer</var>. If the stream does not allow <var>Count</var> bytes to be
written, then an exception is raised.
</p>
<p>
<var>WriteBuffer</var> should be used to write a fixed number of bytes,
such as when writing structures or the content of variables. If the number
of bytes is not determined, use <link id="TStream.Write"/> instead.
<var>WriteBuffer</var> uses <var>Write</var> internally to do the actual
writing.
</p>
</descr>
<errors>
If the stream does not allow to write <var>Count</var> bytes, then an
exception is raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadBuffer"/>
</seealso>
</element>

<element name="TStream.CopyFrom">  <!-- Function -->
<short>Copy data from one stream to another</short>
<descr>
<p>
<var>CopyFrom</var> reads <var>Count</var> bytes from <var>Source</var> and
writes them to the current stream. This updates the current position in the
stream. After the action is completed, the number of bytes copied is
returned. If <var>Count</var> is zero, then the whole contents of the
<var>Source</var> stream is copied. It is positioned on the first byte of
data, and <var>Size</var> bytes are copied. Note that this cannot be used
with streams that do not allow seeking or do not allow determining the size
of the stream.
</p>
<p>
This can be used to quickly copy data from one stream to another or to copy
the whole contents of the stream.
</p>
</descr>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.Write"/>
</seealso>
</element>

<element name="TStream.ReadComponent">  <!-- Function -->
<short>Reads component data from a stream</short>
<descr>
<p>
<var>ReadComponent</var> reads a component state from the stream and
transfers this state to <var>Instance</var>. If <var>Instance</var> is nil,
then it is created first based on the type stored in the stream.
<var>ReadComponent</var> returns the component as it is read from the stream.
</p>
<p>
<var>ReadComponent</var> simply creates a <link id="TReader"/> object and
calls its <link id="TReader.ReadRootComponent">ReadRootComponent</link>
method.
</p>
</descr>
<errors>
If an error occurs during the reading of the component, an <link
id="EFilerError"/> exception is raised.
</errors>
<seealso>
<link id="TStream.WriteComponent"/>
<link id="TStream.ReadComponentRes"/>
<link id="TReader.ReadRootComponent"/>
</seealso>
</element>

<element name="TStream.ReadComponentRes">  <!-- Function -->
<short>Reads component data and resource header from a stream</short>
<descr>
<p>
<var>ReadComponentRes</var> reads a resource header from the stream, and then
calls <link id="TStream.ReadComponent">ReadComponent</link> to read the
component state from the stream into <var>Instance</var>. 
</p>
<p>
This method is usually called by the global streaming method when
instantiating forms and datamodules as created by an IDE. It should be used
mainly on Windows, to store components in Windows resources.
</p>
</descr>
<errors>
If an error occurs during the reading of the component, an <link
id="EFilerError"/> exception is raised.
</errors>
<seealso>
<link id="TStream.ReadComponent"/>
<link id="TStream.WriteComponentRes"/>
</seealso>
</element>

<element name="TStream.WriteComponent">  <!-- Procedure -->
<short>Write component data to the stream</short>
<descr>
<p>
<var>WriteComponent</var> writes the published properties of
<var>Instance</var> to the stream, so they can later be read with <link
id="TStream.ReadComponent"/>. This method is intended to be used by an IDE,
to preserve the state of a form or datamodule as designed in the IDE.
</p>
<p>
<var>WriteComponent</var> simply calls <link
id="TStream.WriteDescendant">WriteDescendant</link> with <var>Nil</var>
ancestor.
</p>
</descr>
<seealso>
<link id="TStream.ReadComponent"/>
<link id="TStream.WriteComponentRes"/>
</seealso>
</element>

<element name="TStream.WriteComponentRes">  <!-- Procedure -->
<short>Write resource header and component data to a stream</short>
<descr>
<p>
<var>WriteComponentRes</var> writes a <var>ResName</var> resource header 
to the stream and then calls <link id="TStream.WriteComponent">WriteComponent</link> 
to write the published properties of <var>Instance</var> to the stream.
</p>
<p>
This method is intened for use by an IDE that can use it to store forms or
datamodules as designed in a Windows resource stream.
</p>
</descr>
<seealso>
<link id="TStream.WriteComponent"/>
<link id="TStream.ReadComponentRes"/>
</seealso>
</element>

<element name="TStream.WriteDescendant">  <!-- Procedure -->
<short>Write component data to a stream, relative to an ancestor</short>
<descr>
<p>
<var>WriteDescendant</var> writes the state of <var>Instance</var> to the
stream where it differs from <var>Ancestor</var>, i.e. only the changed 
properties are written to the stream.
</p>
<p>
<var>WriteDescendant</var> creates a <link id="TWriter"/> object and calls 
its <link id="TWriter.WriteDescendant">WriteDescendant</link> object. The
writer is passed a <link id="TBinaryObjectWriter">binary driver
object</link> by default. 
</p>
</descr>
<seealso>
</seealso>
</element>

<element name="TStream.WriteDescendantRes">  <!-- Procedure -->
<short>Write resource header and component data to a stream, relative to an ancestor</short>
<descr>
<p>
<var>WriteDescendantRes</var> writes a <var>ResName</var> resource header,
and then calls <link id="TStream.WriteDescendant">WriteDescendant</link> to
write the state of <var>Instance</var> to the
stream where it differs from <var>Ancestor</var>, i.e. only the changed
properties are written to the stream.
</p>
<p>
This method is intened for use by an IDE that can use it to store forms or
datamodules as designed in a Windows resource stream.
</p>
</descr>
<seealso>
</seealso>
</element>

<element name="TStream.WriteResourceHeader">  <!-- Procedure -->
<short>Write resource header to the stream</short>
<descr>
<p>
<var>WriteResourceHeader</var> writes a resource-file header for a resource
called <var>ResName</var>. It returns in <var>FixupInfo</var> the argument
that should be passed on to <link id="TStream.FixupResourceHeader"/>.
</p>
<p>
<var>WriteResourceHeader</var> should not be used directly. It is called by
the <link id="TStream.WriteComponentRes"/> and 
<link id="TStream.WriteDescendantRes"/>
methods.
</p>
</descr>
<seealso>
<link id="TStream.FixupResourceHeader"/>
<link id="TStream.WriteComponentRes"/>
<link id="TStream.WriteDescendantRes"/>
</seealso>
</element>

<element name="TStream.FixupResourceHeader">  <!-- Procedure -->
<short>Not implemented in FPC</short>
<descr>
<p>
<var>FixupResourceHeader</var> is used to write the size of the resource
after a component was written to stream. The size is determined from the
current position, and it is written at position <var>FixupInfo</var>. After
that the current position is restored.
</p>
<p>
<var>FixupResourceHeader</var> should never be called directly; it is
handled by the streaming system. 
</p>
</descr>
<seealso>
<link id="TStream.WriteResourceHeader"/>
<link id="TStream.WriteComponentRes"/>  
<link id="TStream.WriteDescendantRes"/>
</seealso>
</element>


<element name="TStream.ReadResHeader">  <!-- Procedure -->
<short>Read a resource header from the stream.</short>
<descr>
<p>
<var>ReadResourceHeader</var> reads a reasource file header from the stream.
It positions the stream just beyond the header.
</p>
<p>
<var>ReadResourceHeader</var> should not be called directly, it is called by
the streaming system when needed. 
</p>
</descr>
<errors>
If the resource header is invalid an <link id="EInvalidImage"/> exception is
raised.
</errors>
<seealso>
<link id="TStream.ReadComponentRes"/>
<link id="EInvalidImage"/>
</seealso>
</element>

<element name="TStream.ReadByte">  <!-- Function -->
<short>Read a byte from the stream and return its value.</short>
<descr>
<var>ReadByte</var> reads one byte from the stream and returns its value.
</descr>
<errors>
If the byte cannot be read, a <link id="EStreamError"/> exception will be
raised. This is a utility function which symply calls the
<link id="TStream.Read">Read</link> function.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteByte"/>
<link id="TStream.ReadWord"/>
<link id="TStream.ReadDWord"/>
<link id="TStream.ReadAnsiString"/>
</seealso>
</element>


<element name="TStream.ReadWord">  <!-- Function -->
<short>Read a word from the stream and return its value.</short>
<descr>
<var>ReadWord</var> reads one Word (i.e. 2 bytes) from the stream 
and returns its value. This is a utility function which symply calls the
<link id="TStream.Read">Read</link> function.
</descr>
<errors>
If the word cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteWord"/>
<link id="TStream.ReadByte"/>
<link id="TStream.ReadDWord"/>
<link id="TStream.ReadAnsiString"/>
</seealso>
</element>

<element name="TStream.ReadDWord">  <!-- Function -->
<short>Read a DWord from the stream and return its value.</short>
<descr>
<var>ReadDWord</var> reads one DWord (i.e. 4 bytes) from the stream 
and returns its value. This is a utility function which simply calls the
<link id="TStream.Read">Read</link> function.
</descr>
<errors>
If the DWord cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteDWord"/>
<link id="TStream.ReadByte"/>
<link id="TStream.ReadWord"/>
<link id="TStream.ReadAnsiString"/>
</seealso>
</element>

<element name="TStream.ReadAnsiString">  <!-- Function -->
<short>Read an ansistring from the stream and return its value.</short>
<descr>
<var>ReadAnsiString</var> reads an ansistring from the stream 
and returns its value. This is a utility function which simply calls the
read function several times.

The Ansistring should be stored as 4 bytes (a DWord) representing the length
of the string, and then the string value itself. 
The <link id="TStream.WriteAnsiString">WriteAnsiString</link> function
writes an ansistring in such a format.
</descr>
<errors>
If the AnsiString cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteAnsiString"/>
<link id="TStream.ReadByte"/>
<link id="TStream.ReadWord"/>
<link id="TStream.ReadDWord"/>
</seealso>
</element>

<element name="TStream.WriteByte">  <!-- Procedure -->
<short>Write a byte to the stream.</short>
<descr>
<var>WriteByte</var> writes the byte <var>B</var> to the stream. This is a
utility function which simply calls the <link
id="TStream.Write">Write</link> function.

The byte can be read from the stream using the <link
id="TStream.ReadByte">ReadByte</link> function.
</descr>
<errors>
If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadByte"/>
<link id="TStream.WriteWord"/>
<link id="TStream.WriteDWord"/>
<link id="TStream.WriteAnsiString"/>
</seealso>
</element>

<element name="TStream.WriteWord">  <!-- Procedure -->
<short>Write a word to the stream.</short>
<descr>
<var>WriteWord</var> writes the word <var>W</var> (i.e. 2 bytes) to the stream. This is a
utility function which simply calls the <link
id="TStream.Write">Write</link> function.

The word can be read from the stream using the <link
id="TStream.ReadWord">ReadWord</link> function.
</descr>
<errors>
If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadWord"/>
<link id="TStream.WriteByte"/>
<link id="TStream.WriteDWord"/>
<link id="TStream.WriteAnsiString"/>
</seealso>
</element>

<element name="TStream.WriteDWord">  <!-- Procedure -->
<short>Write a DWord to the stream.</short>
<descr>
<var>WriteDWord</var> writes the DWord <var>D</var> (i.e. 4 bytes) to the stream. This is a
utility function which simply calls the <link
id="TStream.Write">Write</link> function.

The DWord can be read from the stream using the <link
id="TStream.ReadDWord">ReadDWord</link> function.
</descr>
<errors>
If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadDWord"/>
<link id="TStream.WriteByte"/>
<link id="TStream.WriteWord"/>
<link id="TStream.WriteAnsiString"/>
</seealso>
</element>

<element name="TStream.WriteAnsiString">  <!-- Procedure -->
<short>Write an ansistring to the stream.</short>
<descr>
<var>WriteAnsiString</var> writes the AnsiString <var>S</var> (i.e. 4 bytes) to the stream. This is a
utility function which simply calls the <link
id="TStream.Write">Write</link> function.

The ansistring is written as a 4 byte length specifier, followed by the
ansistring's content.

The ansistring can be read from the stream using the <link
id="TStream.ReadAnsiString">ReadAnsiString</link> function.
</descr>
<errors>
If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadAnsiString"/>
<link id="TStream.WriteByte"/>
<link id="TStream.WriteWord"/>
<link id="TStream.WriteDWord"/>
</seealso>
</element>

<element name="TStream.Position">  <!-- Property -->
<short>The current position in the stream.</short>
<descr>
<p>
<var>Position</var> can be read to determine the current position in the
stream. It can be written to set the (absolute) position in the stream.
The position is zero-based, so to set the position at the beginning of the
stream, the position must be set to zero. 
</p>
<remark>
Not all <var>TStream</var>  descendants support setting the position in the 
stream, so this should be used with care.
</remark>
</descr>
<errors>
Some descendants may raise an <link id="EStreamError"/> exception if they
do not support setting the stream position.
</errors>
<seealso>
<link id="TStream.Size"/>
<link id="TStream.Seek"/>
</seealso>
</element>

<element name="TStream.Size">  <!-- Property -->
<short>The current size of the stream.</short>
<descr>
<p>
<var>Size</var> can be read to determine the stream size or to set the
stream size. 
</p>
<remark>
Not all descendants of <var>TStream</var> support getting or setting the
stream size; they may raise an exception if the <var>Size</var> property 
is read or set.
</remark>
</descr>
<seealso>
<link id="TStream.Position"/>
<link id="TStream.Seek"/>
</seealso>
</element>

<!--
  *********************************************************************
  THandleStream
  *********************************************************************
-->

<element name="THandleStream">  <!-- Class -->
<short>Base class for streams that are identified by an OS handle.</short>
<descr>
<p>
<var>THandleStream</var> is an abstract descendant of the <link
id="TStream"/>
class that provides methods for a stream to handle all reading and writing 
to and from a handle, provided by the underlying OS. To this end, it
overrides the <link id="THandleStream.Read">Read</link> and  <link
id="THandleStream.Write">Write</link> methods of TStream. 
</p>
<remark>
<ul>
<li>
<var>ThandleStream</var> does not obtain a handle from the OS by itself,
it just handles reading and writing to such a handle by wrapping the system
calls for reading and writing; 
Descendant classes should obtain a handle from the OS by themselves and pass it on in the inherited 
constructor.</li>
<li>
Contrary to Delphi, no seek is implemented for <var>THandleStream</var>,
since pipes and sockets do not support this. The seek is implemented in
descendant methods that support it.
</li>
</ul>
</remark>
</descr>
<seealso>
<link id="TStream"/>
<link id="TFileStream"/>
</seealso>
</element>

<element name="THandleStream.Create">  <!-- Constructor -->
<short>Create a handlestream from an OS Handle.</short>
<descr>
<var>Create</var> creates a new instance of a <var>THandleStream</var>
class. It stores <var>AHandle</var> in an internal variable and 
then calls the inherited constructor. 
</descr>
<seealso>
<link id="TStream"/>
</seealso>
</element>

<element name="THandleStream.Read">  <!-- Function -->
<short>Overrides standard read method.</short>
<descr>
<p>
<var>Read</var> overrides the <link id="TStream.Read">Read</link> 
method of <var>TStream</var>. It uses the <link
id="THandleStream.Handle">Handle</link> property to read the
<var>Count</var> bytes into <var>Buffer</var>
</p>
<p>
If no error occurs while reading, the number of bytes actually read will be
returned.
</p>
</descr>
<errors>
If the operating system reports an error while reading from the handle, -1
is returned.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="THandleStream.Write"/>
<link id="THandleStream.Handle"/>
</seealso>
</element>

<element name="THandleStream.Write">  <!-- Function -->
<short>Overrides standard write method.</short>
<descr>
<p>
<var>Write</var> overrides the <link id="TStream.Write">Write</link> 
method of <var>TStream</var>. It uses the <link
id="THandleStream.Handle">Handle</link> property to write the
<var>Count</var> bytes from <var>Buffer</var>. 
</p>
<p>
If no error occurs while writing, the number of bytes actually written will be
returned.
</p>
</descr>
<errors>
If the operating system reports an error while writing to the handle, 0 is returned. 
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="THandleStream.Write"/>
<link id="THandleStream.Handle"/>
</seealso>
</element>

<element name="THandleStream.Handle">  <!-- Property -->
<short>The OS handle of the stream.</short>
<descr>
<var>Handle</var> represents the Operating system handle to which reading 
and writing is done. The handle can be read only, i.e. it cannot be set
after the <var>THandlestream</var> instance  was created. It should be 
passed to the constructor <link id="THandleStream.Create"/>
</descr>
<seealso>
<link id="THandleStream"/>
<link id="THandleStream.Create"/>
</seealso>
</element>

<!--
  *********************************************************************
  TFileStream
  *********************************************************************
-->

<element name="TFileStream">  <!-- Class -->
<short>Stream that stores its data in a named file on disk.</short>
<descr>
<p>
<var>TFileStream</var> is a <link id="TStream"/> descendant that
stores or reads it's data from a named file in the filesystem of 
the operating system.
</p>
<p>
To this end, it overrides some of the methods in <var>TStream</var>
and implements them for the case of files on disk, and it adds the <link
id="TFileStream.Filename">FileName</link> property to the list of public
properties.
</p>
</descr>
<seealso>
<link id="TFileStream.Create"/>
<link id="TStream"/>
</seealso>
</element>

<element name="TFileStream.SetSize">  <!-- Procedure -->
<short>Sets the size of the file stream.</short>
<descr>
<p>
<var>SetSize</var> sets the size of the file at <var>NewSize</var> bytes.
Errors returned by the operating system call will be silently ignored.
</p>
<p>
This is the protected write method of the public <link id="TStream.Size"/>
property.
</p>
</descr>
<seealso>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TFileStream.Create">  <!-- Constructor -->
<short>Creates a file stream.</short>
<descr>
<p>
<var>Create</var> creates a new instance of a <var>TFileStream</var> class.
It opens the file <var>AFileName</var> with mode <var>Mode</var>, which can
have one of the following values:
</p>
<table>
<tr>
<td>fmCreate</td><td><printshort id="fmCreate"/></td>
</tr>
<tr>
<td>fmOpenRead</td><td><printshort id="fmOpenRead"/></td>
</tr>
<tr>
<td>fmOpenWrite</td><td><printshort id="fmOpenWrite"/></td>
</tr>
<tr>
<td>fmOpenReadWrite</td><td><printshort id="fmOpenReadWrite"/></td>
</tr>
</table>
<p>
These constants (except <var>fmCreate</var>) can be OR-ed with the following to
specify how sharing and file locking is supposed to be handled:
</p>
<table>
<tr><td>fmShareCompat</td><td><printshort id="#rtl.sysutils.fmShareCompat"/></td></tr>
<tr><td>fmShareExclusive</td><td><printshort id="#rtl.sysutils.fmShareExclusive"/></td></tr>
<tr><td>fmShareDenyWrite</td><td><printshort id="#rtl.sysutils.fmShareDenyWrite"/></td></tr>
<tr><td>fmShareDenyRead</td><td><printshort id="#rtl.sysutils.fmShareDenyRead"/></td></tr>
<tr><td>fmShareDenyNone</td><td><printshort id="#rtl.sysutils.fmShareDenyNone"/></td></tr>
</table>
<p>
Note that sharing is advisory on Unix-like platforms.
</p>
<p>
After the file has been opened in the requested mode and a handle has been
obtained from the operating system, the inherited constructor is called.
</p>
</descr>
<errors>
If the file could not be opened in the requested mode, an <link
id="EFOpenError"/> exception is raised.
</errors>
<seealso>
<link id="TStream"/>
<link id="TFileStream.FileName"/>
<link id="THandleStream.Create"/>
</seealso>
</element>

<element name="TFileStream.Destroy">  <!-- Destructor -->
<short>Destroys the file stream.</short>
<descr>
<p>
<var>Destroy</var> closes the file (causing possible buffered data to be
written to disk) and then calls the inherited destructor.
</p>
<p>
Do not call <var>destroy</var> directly, instead call the <var>Free</var> 
method. Destroy does not check whether <var>Self</var> is nil, while
<var>Free</var> does.
</p>
</descr>
<seealso>
<link id="TFileStream.Create"/>
</seealso>
</element>

<element name="TFileStream.Seek">  <!-- Function -->
<short>Overrides the standard method.</short>
<descr>
<p>
<var>Seek</var> attempts to set the position of the stream at
<var>Offset</var> bytes from <var>Origin</var>. <var>Offset</var> can have
any integer value which would set the position within the boundaries of the
file, and thus the valid range depends on the value of <var>Origin</var>.
<var>Origin</var> can have one of the following values:
</p>
<table>
<tr>
<td>soFromBeginning</td><td><printshort id="soFromBeginning"/></td>
</tr>
<tr>
<td>soFromCurrent</td><td><printshort id="soFromCurrent"/></td>
</tr>
<tr>
<td>soFromEnd</td><td><printshort id="soFromEnd"/></td>
</tr>
</table>
<p>
<var>Seek</var> returns the new position in the file, or -1 on error.
</p>
</descr>
<errors>
On error, -1 is returned, and the position is not changed.
</errors>
<seealso>
<link id="TStream.Position"/>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TFileStream.FileName">  <!-- Property -->
<short>The filename of the stream.</short>
<descr>
<var>FileName</var> is the name of the file that the stream reads from or writes
to. It is the name as passed in the constructor of the stream; it cannot be
changed. To write to another file, the stream must be freed and created
again with the new filename.
</descr>
<seealso>
<link id="TFileStream.Create"/>
</seealso>
</element>

<!--
  *********************************************************************
  TCustomMemoryStream
  *********************************************************************
-->

<element name="TCustomMemoryStream">  <!-- Class -->
<short>Abstract stream that stores its data in memory.</short>
<descr>
<p>
<var>TCustomMemoryStream</var> is the parent class for streams that stored
their data in memory. It introduces all needed functions to handle reading
from and navigating through the memory, and introduces a 
<link id="TCustomMemoryStream.Memory">Memory</link> property which points to
the memory area where the stream data is kept. 
</p>
<p>
The only thing which <var>TCustomMemoryStream</var> does not do is obtain 
memory to store data when writing data  or the writing of data. This
functionality is implemented in descendant streams such as <link
id='TMemoryStream'/>. The reason for this approach is that this way it is
possible to create e.g. read-only descendants of
<var>TCustomMemoryStream</var> that point to a fixed part in memory which
can be read from, but not written to. 
</p>
<remark>
Since <var>TCustomMemoryStream</var> is an abstract class, do not create 
instances of <var>TMemoryStream</var> directly. Instead,
create instances of descendants such as <link id="TMemoryStream"/>. 
</remark>
</descr>
<seealso>
<link id="TMemoryStream"/>
<link id="TStream"/>
</seealso>
</element>

<element name="TCustomMemoryStream.SetPointer">  <!-- Procedure -->
<short>Sets the internal memory pointer and size of the memory block.</short>
<descr>
<p>
<var>SetPointer</var> updates the internal memory pointer and the size of
the memory area pointed to.  
</p>
<p>
Descendant memory streams should call this method whenever they set or reset
the memory the stream should read from or write to.
</p>
</descr>
<seealso>
<link id="TCustomMemoryStream.Memory"/>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TCustomMemoryStream.Read">  <!-- Function -->
<short>Reads <var>Count</var> bytes from the stream into <var>buffer</var>.</short>
<descr>
<p>
<var>Read</var> reads <var>Count</var> bytes from the stream into the memory
pointed to by <var>buffer</var>. It returns the number of bytes actually
read.
</p>
<p>
This method overrides the <link id="TStream.Read"/> method of <link
id="TStream"/>. It will read as much bytes as are still available in the
memory area pointer to by <link id="TCustomMemoryStream.Memory">Memory</link>.
After the bytes are read, the internal stream position is updated.
</p>
</descr>
<seealso>
<link id="TCustomMemoryStream.Memory"/>
<link id="TStream.Read"/>
</seealso>
</element>

<element name="TCustomMemoryStream.Seek">  <!-- Function -->
<short>Sets a new position in the stream.</short>
<descr>
<var>Seek</var> overrides the abstract <link id="TStream.Seek"/> method.
It simply updates the internal stream position, and returns the new
position.
</descr>
<errors>
No checking is done whether the new position is still a valid position, i.e.
whether the position is still within the range <var>0..Size</var>.
Attempting a seek outside the valid memory range of the stream may result in
an exception at the next read or write operation.
</errors>
<seealso>
<link id="TStream.Position"/>
<link id="TStream.Size"/>
<link id="TCustomMemoryStream.Memory"/>
</seealso>
</element>

<element name="TCustomMemoryStream.SaveToStream">  <!-- Procedure -->
<short>Writes the contents of the memory stream to another stream.</short>
<descr>
<p>
<var>SaveToStream</var> writes the contents of the memory stream to  
<var>Stream</var>. The content of <var>Stream</var> is not cleared first.
The current position of the memory stream is not changed by this action.
</p>
<remark>
<p>
This method will work much faster than the use of the 
<link id="TStream.CopyFrom"/> method:
</p>
<code>
  Seek(0,soFromBeginning);
  Stream.CopyFrom(Self,Size);
</code>
<p>
because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>SaveToStream</var> writes the contents of the memory as one big block.
</p>
</remark>
</descr>
<errors>
If an error occurs when writing to <var>Stream</var> an <link
id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TCustomMemoryStream.SaveToFile"/>
<link id="TStream.CopyFrom"/>
</seealso>
</element>

<element name="TCustomMemoryStream.SaveToFile">  <!-- Procedure -->
<short>Writes the contents of the stream to a file.</short>
<descr>
<p>
<var>SaveToFile</var> writes the contents of the stream to a file with name
<var>FileName</var>.
It simply creates a filestream and writes the contents of the memorystream
to this file stream using <link id="TCustomMemoryStream.SaveToStream"/>.
</p>
<remark>
<p>
This method will work much faster than the use of the <link
id="TStream.CopyFrom"/> method:
</p>
<code>
  Stream:=TFileStream.Create(fmCreate,FileName);
  Seek(0,soFromBeginning);
  Stream.CopyFrom(Self,Size);
</code>
<p>
because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>SaveToFile</var> writes the contents of the memory as one big block.
</p>
</remark>
</descr>
<errors>
If an error occurs when creating or writing to the file, an <link
id="EStreamError"/> exception may occur.
</errors>
<seealso>
<link id="TCustomMemoryStream.SaveToStream"/>
<link id="TFileStream"/>
<link id="TStream.CopyFrom"/>
</seealso>
</element>

<element name="TCustomMemoryStream.Memory">  <!-- Property -->
<short>Pointer to the data kept in the memory stream.</short>
<descr>
<p>
<var>Memory</var> points to the memory area where stream keeps it's data.
The property is read-only, so the pointer cannot be set this way.
</p>
<remark>
Do not write to the memory pointed to by <var>Memory</var>, since the memory
content may be read-only, and thus writing to it may cause errors.
</remark>
</descr>
<seealso>
<link id="TStream.Size"/>
</seealso>
</element>

<!--
  *********************************************************************
  TMemoryStream
  *********************************************************************
-->

<element name="TMemoryStream">  <!-- Class -->
<short>Standard implementation of a stream that stores its data in memory</short>
<descr>
<p>
<var>TMemoryStream</var> is a <link id="TStream"/> descendant that stores
it's data in memory. It descends directly from <link id="TCustomMemoryStream"/>
and implements the necessary to allocate and de-allocate memory directly from
the heap. It implements the <link id="TMemoryStream.Write">Write</link> method
which is missing in <var>TCustomMemoryStream</var>.
</p>
<p>
<var>TMemoryStream</var> also introduces methods to load the contents of
another stream or a file into the memory stream.
</p>
<p>
It is not necessary to do any memory management manually, as the stream 
will allocate or de-allocate memory as needed. When the stream is freed, all
allocated memory will be freed as well.
</p>
</descr>
<seealso>
<link id="TCustomMemoryStream"/>
<link id="TStream"/>
</seealso>
</element>

<element name="TMemoryStream.Realloc">  <!-- Function -->
<short>Sets the new capacity for the memory stream</short>
<descr>
<p>
<var>SetCapacity</var> sets the capacity of the memory stream, i.e.
does the actual allocation or de-allocation of memory for the stream. It
allocates at least <var>NewCapacity</var> bytes on the heap, moves the 
current contents of the stream to this location (as much as fits in) and 
returns the new memory location. 
Extra allocated memory is not initialized, i.e. may contain garbage.
</p>
<p>
Memory is allocated in blocks of 4 Kb; this can be changed by overriding 
the method.
</p>
</descr>
<seealso>
<link id="TMemoryStream.Capacity"/>
</seealso>
</element>

<element name="TMemoryStream.Capacity">  <!-- Property -->
<short>Current capacity of the stream.</short>
<descr>
<p>
<var>Capacity</var> is the current capacity of the stream, this is the 
current size of the memory allocated to the stream. This is not necessarily
equal to the size of the stream, but will always be larger than or equal to
the size of the stream. When writing to the stream, the <link
id="TMemoryStream.Write"/> sets the capacity to the needed value.
</p>
<p>
If a lot of write operations will occur, performance may be improved by
setting the capacity to a large value, so less reallocations of memory will
occur while writing to the stream.
</p>
</descr>
<seealso>
<link id="TMemoryStream.ReAlloc"/>
</seealso>
</element>

<element name="TMemoryStream.Destroy">  <!-- Destructor -->
<short>Frees any allocated memory and destroys the memory stream.</short>
<descr>
<var>Destroy</var> clears the memory stream, thus in effect freeing any memory 
allocated for it, and then frees the memory stream.
</descr>
</element>

<element name="TMemoryStream.Clear">  <!-- Procedure -->
<short>Zeroes the position, capacity and size of the stream.</short>
<descr>
<var>Clear</var> sets the position and size to 0, and sets the capacity of
the stream to 0, thus freeing all memory allocated for the stream.
</descr>
<seealso>
<link id="TStream.Size"/>
<link id="TStream.Position"/>
<link id="TCustomMemoryStream.Memory"/>
</seealso>
</element>

<element name="TMemoryStream.LoadFromStream">  <!-- Procedure -->
<short>Loads the contents of a stream into memory.</short>
<descr>
<p>
<var>LoadFromStream</var> loads the contents of <var>Stream</var> into
the memorybuffer of the stream. Any previous contents of the memory 
stream are overwritten. Memory is allocated as needed.
</p>
<remark>
<p>
The <var>LoadFromStream</var> uses the <link id="TStream.Size">Size</link>
property of <var>Stream</var> to determine how much memory must be
allocated. Some streams do not allow the stream size to be determined, so
care must be taken when using this method.
</p>
<p>
This method will work much faster than the use of the <link
id="TStream.CopyFrom"/> method:
</p>
<code>
  Seek(0,soFromBeginning);
  CopyFrom(Stream,Stream.Size);
</code>
<p>
because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>LoadFromStream</var> reads the contents of the stream as one big block.
</p>
</remark>
</descr>
<errors>
If an error occurs when reading from the stream, an <link
id="EStreamError"/> may occur.
</errors>
<seealso>
<link id="TStream.CopyFrom"/>
<link id="TMemoryStream.LoadFromFile"/>
</seealso>
</element>

<element name="TMemoryStream.LoadFromFile">  <!-- Procedure -->
<short>Loads the contents of a file into memory.</short>
<descr>
<p>
<var>LoadFromFile</var> loads the contents of the file with name
<var>FileName</var> into the memory stream. The current contents of the
memory stream is replaced by the contents of the file. Memory is allocated
as needed.
</p>
<p>
The <var>LoadFromFile</var> method simply creates a filestream and then
calls the <link id="TMemoryStream.LoadFromStream"/> method.
</p>
</descr>
If an error occurs when creating or reading from the stream, an <link
id="EStreamError"/> may occur.
<seealso>
<link id="TMemoryStream.LoadFromStream"/>
</seealso>
</element>

<element name="TMemoryStream.SetSize">  <!-- Procedure -->
<short>Sets the size for the memory stream.</short>
<descr>
<var>SetSize</var> sets the size of the memory stream to <var>NewSize</var>.
This will set the capacity of the stream to <var>NewSize</var> and correct
the current position in the stream when needed.
</descr>
<seealso>
<link id="TStream.Position"/>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TMemoryStream.Write">  <!-- Function -->
<short>Writes data to the stream's memory.</short>
<descr>
<p>
<var>Write</var> writes <var>Count</var> bytes from <var>Buffer</var>
to the stream's memory, starting at the current position in the stream.
If more memory is needed than currently allocated, more memory will be
allocated. Any contents in the memory stream at the current position will be
overwritten. The function returns the number of bytes actually written
(which should under normal circumstances always equal <var>Count</var>).
</p>
<p>
This method overrides the <link id="TStream.Write"/> method.
</p>
</descr>
<errors>
If no more memory could be allocated, then an exception will be raised.
</errors>
<seealso>
<link id="TCustomMemoryStream.Read"/>
</seealso>

</element>

<!--
  *********************************************************************
  TStringStream
  *********************************************************************
-->

<element name="TStringStream">  <!-- Class -->
<short>Stream that stores its data in a string.</short>
<descr>
<p>
<var>TStringStream</var> stores its data in an ansistring. The contents of
this string is available as the 
<link id="TStringStream.DataString">DataString</link> property. It also
introduces some methods to read or write parts of the stringstream's data
as a string.
</p>
<p>The main purpose of a <var>TStringSTream</var> is to be able to treat a
string as a stream from which can be read.
</p>
</descr>
<seealso>
<link id="TStream"/>
<link id="TStringStream.DataString"/>
<link id="TStringStream.ReadString"/>
<link id="TStringStream.WriteString"/>
</seealso>
</element>

<element name="TStringStream.SetSize">  <!-- Procedure -->
<short>Sets the size of the stream.</short>
<descr>
<var>SetSize</var> sets the size of the stream to <var>newsize</var>. 
It does this by setting the size of the ansisting in which the stream 
is stored. <var>NewSize</var> can have any value greater than or equal to
zero.
</descr>
<errors>
In case there is not enough memory, an exception may be raised.
</errors>
<seealso>
<link id="TStream.Size"/>
</seealso>
</element>

<element name="TStringStream.Create">  <!-- Constructor -->
<short>Creates a new stringstream and sets its initial content.</short>
<descr>
<var>Create</var> creates a new <var>TStringStream</var> instance and
sets its initial content to <var>Astring</var>. The position is still 0 but
the size of the stream will equal the length of the string.
</descr>
<seealso>
<link id="TStringStream.DataString"/>
</seealso>
</element>

<element name="TStringStream.Read">  <!-- Function -->
<short>Reads from the stream.</short>
<descr>
<var>Read</var> overrides the <link id="TStream.Read">Read</link>
from <link id="TStream"/>. It tries to read <var>Count</var> bytes into
<var>Buffer</var>. It returns the number of bytes actually read. The
position of the stream is advanced with the number of bytes actually read;
When the reading has reached the end of the <link
id="TStringSTream.DataString">DataString</link>, then the reading stops,
i.e. it is not possible to read beyond the end of the datastring.
</descr>
<seealso>
<link id="TStream.Read"/>
<link id="TStringStream.Write"/>
<link id="TStringStream.DataString"/>
</seealso>
</element>

<element name="TStringStream.ReadString">  <!-- Function -->
<short>Reads a string of length <var>Count</var></short>
<descr>
<p>
<var>ReadString</var> reads <var>Count</var> bytes from the stream and
returns the read bytes as a string. If less than <var>Count</var> bytes 
were available, the string has as many characters as bytes could be read.
</p>
<p>The <var>ReadString</var> method is a wrapper around the <link
id="TStringStream.Read">Read</link> method. It does not do the same stringas
the <link id="TStream.ReadAnsiString"/> method, which first reads a length
integer to determine the length of the string to be read.
</p>
</descr>
<seealso>
<link id="TStringStream.Read"/>
<link id="TStream.ReadAnsiString"/>
</seealso>
</element>

<element name="TStringStream.Seek">  <!-- Function -->
<short>Sets the position in the stream.</short>
<descr>
<var>Seek</var> implements the abstract <link id="TStream.Seek">Seek</link>
method.
</descr>
<seealso>
</seealso>
</element>

<element name="TStringStream.Write">  <!-- Function -->
<short><var>Write</var> overrides the <link id="TStream.Write"/>
method.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringStream.WriteString">  <!-- Procedure -->
<short><var>WriteString</var> writes a string to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TStringStream.DataString">  <!-- Property -->
<short>Contains the contents of the stream in string form</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TResourceStream
  *********************************************************************
-->

<element name="TResourceStream">  <!-- Class -->
<short>Stream that reads its data from a resource object.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TResourceStream.Initialize">  <!-- Procedure -->
<short>Initializes the resource stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TResourceStream.Create">  <!-- Constructor -->
<short>Creates a new instance of a resource stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TResourceStream.CreateFromID">  <!-- Constructor -->
<short>Creates a new instance of a resource stream with a resource</short>
<descr>
The resource is loaded from the loaded module (identified by the handle
<var>Instance</var>), identifier <var>ResID</var> and type
<var>ResType</var>.
</descr>
<seealso>
</seealso>
</element>

<element name="TResourceStream.Destroy">  <!-- Destructor -->
<short>Destroys the instance of the resource stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>


<element name="TValueType">  <!-- Enumeration type -->
<short>Enumerated type used to identify the kind of streamed property</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TValueType.vaNull">  <!-- Enumeration value -->
<short>Empty value. Ends a list.</short>
</element>

<element name="TValueType.vaList">  <!-- Enumeration value -->
<short>Identifies the start of a list of values</short>
</element>

<element name="TValueType.vaInt8">  <!-- Enumeration value -->
<short>Integer value, 8 bits long.</short>
</element>

<element name="TValueType.vaInt16">  <!-- Enumeration value -->
<short>Integer value, 16 bits long.</short>
</element>

<element name="TValueType.vaInt32">  <!-- Enumeration value -->
<short>Integer value, 32 bits long.</short>
</element>

<element name="TValueType.vaExtended">  <!-- Enumeration value -->
<short>Extended value.</short>
</element>

<element name="TValueType.vaString">  <!-- Enumeration value -->
<short>String value.</short>
</element>

<element name="TValueType.vaIdent">  <!-- Enumeration value -->
<short>Identifier.</short>
</element>

<element name="TValueType.vaFalse">  <!-- Enumeration value -->
<short>Boolean <var>False</var> value.</short>
</element>

<element name="TValueType.vaTrue">  <!-- Enumeration value -->
<short>Boolean <var>True</var> value.</short>
</element>

<element name="TValueType.vaBinary">  <!-- Enumeration value -->
<short>Binary data follows.</short>
</element>

<element name="TValueType.vaSet">  <!-- Enumeration value -->
<short>Set data follows.</short>
</element>

<element name="TValueType.vaLString">  <!-- Enumeration value -->
<short>Ansistring data follows.</short>
</element>

<element name="TValueType.vaNil">  <!-- Enumeration value -->
<short>Nil pointer.</short>
</element>

<element name="TValueType.vaCollection">  <!-- Enumeration value -->
<short>Collection follows</short>
</element>

<element name="TValueType.vaSingle">  <!-- Enumeration value -->
<short>Single type follows.</short>
</element>

<element name="TValueType.vaCurrency">  <!-- Enumeration value -->
<short>Currency value follows</short>
</element>

<element name="TValueType.vaDate">  <!-- Enumeration value -->
<short>Date value follows</short>
</element>

<element name="TValueType.vaWString">  <!-- Enumeration value -->
<short>Widestring value follows.</short>
</element>

<element name="TValueType.vaInt64">  <!-- Enumeration value -->
<short>Integer value, 64 bits long.</short>
</element>

<element name="TFilerFlag">  <!-- Enumeration type -->
<short>Flags used by the <link id="TFiler"/> class</short>
<descr>
The <var>TFiler</var> class uses this enumeration type to decide whether the
streamed object was streamed as part of an inherited form or not.
</descr>
<seealso>
<link id="TFiler"/>
</seealso>
</element>

<element name="TFilerFlag.ffInherited">  <!-- Enumeration value -->
<short>Stored object is an inherited object.</short>
</element>

<element name="TFilerFlag.ffChildPos">  <!-- Enumeration value -->
<short>The position of the child on it's parent is included.</short>
</element>

<element name="TFilerFlag.ffInline">  <!-- Enumeration value -->
<short>Used for frames.</short>
</element>

<element name="TFilerFlags">  <!-- Set type -->
<short>Set of <link id="TFilerFlag"/></short>
</element>

<element name="TReaderProc">  <!-- Procedure type -->
<short>Reader procedure used by <link id="TPersistent.DefineProperties">DefineProperties</link></short>
<descr>
The <var>TReaderProc</var> reader procedure is a callback procedure which 
will be used by a <link id="TPersistent"/> descendant to read user 
properties from a stream during the streaming process. The <var>Reader</var>
argument is the writer object which can be used read properties from the
stream.
</descr>
<seealso>
<Link id="TPersistent.DefineProperties"/>
</seealso>
</element>

<element name="TWriterProc">  <!-- Procedure type -->
<short>Writer procedure used by <link id="TPersistent.DefineProperties">DefineProperties</link></short>
<descr>
The <var>TWriterProc</var> writer procedure is a callback procedure which 
will be used by a <link id="TPersistent"/> descendant to write user 
properties from a stream during the streaming process. The <var>Writer</var>
argument is the writer object which can be used write properties to the
stream.
</descr>
<seealso>
<Link id="TPersistent.DefineProperties"/>
</seealso>
</element>

<element name="TStreamProc">  <!-- Procedure type -->
<short>Procedure type used in streaming.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TFiler
  *********************************************************************
-->

<element name="TFiler">  <!-- Class -->
<short>Class responsible for streaming of components.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TFiler.SetRoot">  <!-- Procedure -->
<short>Sets the root component which is being streamed.</short>
<descr>
Sets the root component. 
The root component is the initial component which is being streamed.
</descr>
<seealso>
</seealso>
</element>

<element name="TFiler.DefineProperty">  <!-- Procedure -->
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TFiler.DefineBinaryProperty">  <!-- Procedure -->
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TFiler.Root">  <!-- Property -->
<short>The root component is the initial component which is being streamed.
</short>
<descr>
The streaming process will stream a component and all the components which
it owns. The <var>Root</var> component is the component which is initially
streamed.
</descr>
<seealso>
<link id="TFiler.LookupRoot">LookupRoot</link>
</seealso>
</element>

<element name="TFiler.LookupRoot">  <!-- Property -->
<short>Component used to look up ancestor components.</short>
<descr>
When comparing inherited component's values against parent values, the
values are compared with the component in <var>LookupRoot</var>. Initially,
it is set to <link id="TFiler.Root">Root</link>.
</descr>
<seealso>
<link id="TFiler.Root">Root</link>
</seealso>
</element>

<element name="TFiler.Ancestor">  <!-- Property -->
<short>Ancestor component from which an inherited component is streamed.</short>
<descr>
When streaming a component, this is the parent component. Only properties
that differ from the parent's property value will be streamed.
</descr>
<seealso>
<link id="TFiler.Root">Root</link>
<link id="TFiler.LookupRoot">LookupRoot</link>
</seealso>
</element>

<element name="TFiler.IgnoreChildren">  <!-- Property -->
<short>Determines whether children will be streamed as well.</short>
<descr>
By default, all children (i.e. owned objects) will also be streamed when
streaming a component. This property can be used to prevent owned objects
from being streamed.
</descr>
</element>

<element name="TComponentClass">  <!-- "class of" type -->
<short>Class of TComponent</short>
<descr>
The <var>TComponentClass</var> type is used when constructing 
<link id="TComponent"/> descendant instances and when registering
components.
</descr>
<seealso>
<link id="TComponent"/>
</seealso>
</element>

<!--
  *********************************************************************
  TAbstractObjectReader
  *********************************************************************
-->

<element name="TAbstractObjectReader">  <!-- Class -->
<short>Abstract driver class to read stored component data.</short>
<descr>
<p>
The Free Pascal streaming mechanism, while compatible with Delphi's
mechanism, differs from it in the sense that the streaming mechanism uses
a driver class when streaming components. The <var>TAbstractObjectReader</var>
class is the base driver class for reading property values from streams.
It consists entirely of abstract methods, which must be implemented by
descendant classes.
</p>
<p>
Different streaming mechanisms can be implemented by making a descendant
from <var>TAbstractObjectReader</var>. The <link id="TBinaryObjectReader"/>
class is such a descendant class, which streams data in binary (Delphi
compatible) format.
</p>
<p>
All methods described in this class, mustbe implemented by descendant
classes.
</p>
</descr>
<seealso>
<link id="TBinaryObjectReader"/>
</seealso>
</element>

<element name="TAbstractObjectReader.NextValue">  <!-- Function -->
<short>Returns the type of the next value in the stream.</short>
<descr>
<p>
This function should return the type of the next value in the stream, 
but should not read the actual value, i.e. the stream position should not be altered by
this method. This is used to 'peek' in the stream what value is next.
</p>
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadValue"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadValue">  <!-- Function -->
<short>Reads the type of the next value.</short>
<descr>
This function returns the type of the next value in the stream and reads it.
i.e. after the call to this method, the stream is positioned to read the
value of the type returned by this function.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadValue"/>
</seealso>
</element>

<element name="TAbstractObjectReader.BeginRootComponent">  <!-- Procedure -->
<short>Starts the reading of the root component.</short>
<descr>
This function can be used to initialize the driver class for reading a
component. It is called once at the beginning of the read process, and 
is immediately followed by a call to <link
id="TAbstractObjectReader.BeginComponent">BeginComponent</link>.
</descr>
<seealso>
<link id="TAbstractObjectReader.BeginComponent"/>
</seealso>
</element>

<element name="TAbstractObjectReader.BeginComponent">  <!-- Procedure -->
<short>Marks the reading of a new component.</short>
<descr>
<p>
This method is called when the streaming process wants to start reading a 
new component. 
</p>
<p>
Descendant classes should override this method to read the start of a
component new component definition and return the needed arguments. 
<var>Flags</var> should be filled with any flags that were found at the
component definition, as well as <var>AChildPos</var>. The
<var>CompClassName</var> should be filled with the class name of the
streamed component, and the <var>CompName</var> argument should be filled
with the name of the component.
</p>
<p>
<var>AChildPos</var> is used to change the ordering in which components
appear below their parent component when streaming descendant forms.
</p>
</descr>
<seealso>
<link id="TAbstractObjectReader.BeginRootComponent"/>
<link id="TAbstractObjectReader.BeginProperty"/>
</seealso>
</element>

<element name="TAbstractObjectReader.BeginProperty">  <!-- Function -->
<short>Marks the reading of a property value.</short>
<descr>
<var>BeginProperty</var> is called by the streaming system when it wants to
read a new property. The return value of the function is the name of the 
property which can be read from the stream.
</descr>
<seealso>
<link id="TAbstractObjectReader.BeginComponent"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadBinary">  <!-- Procedure -->
<short>Read binary data from the stream.</short>
<descr>
<var>ReadBinary</var> is called when binary data should be read from the
stream 
(i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaBinary</var>). The data should be stored in the <var>DestData</var> memory stream
by descendant classes.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadFloat">  <!-- Function -->
<short>Read a float value from the stream.</short>
<descr>
<var>ReadFloat</var> is called by the streaming system when it wants to read
a float from the stream (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaExtended</var>). The return value should be the value of the float.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadSingle">  <!-- Function -->
<short>Read a single (real-type) value from the stream.</short>
<descr>
<var>ReadSingle</var> is called by the streaming system when it wants to read
a single-type float from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaSingle</var>). The return value should be the value of 
the float.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadDate">  <!-- Function -->
<short>Read a date value from the stream.</short>
<descr>
<var>ReadDate</var> is called by the streaming system when it wants to read
a date/time value from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaDate</var>). The return value should be the date/time
value. (This value can be stored as a float, since <var>TDateTime</var> is
nothing but a float.)
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadIdent">  <!-- Function -->
<short>Read an identifier from the stream.</short>
<descr>
<p>
<var>ReadIdent</var> is called by the streaming system if it expects to read
an identifier of type <var>ValueType</var> from the stream after a call to
<link id="TAbstractObjectReader.Readvalue">ReadValue</link> returned
<var>vaIdent</var>. The identifier 
should be returned as a string. Note that in some cases the identifier does 
not actually have to be in the stream. The following table indicates which
identifiers must actually be read:
</p>
<table>
<tr><td>ValueType</td><td>Expected value</td></tr>
<tr><td>vaIdent</td><td>Read from stream.</td></tr>
<tr><td>vaNil</td><td>'Nil'. This does not have to be read from the stream.</td></tr>
<tr><td>vaFalse</td><td>'False'. This does not have to be read from the stream.</td></tr>
<tr><td>vaTrue</td><td>'True'. This does not have to be read from the stream.</td></tr>
<tr><td>vaNull</td><td>'Null'. This does not have to be read from the stream.</td></tr>
</table>
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadInt8">  <!-- Function -->
<short>Read an 8-bit integer from the stream.</short>
<descr>
<var>ReadInt8</var> is called by the streaming process if it expects to 
read an integer value with a size of 8 bits (1 byte) from the stream (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaInt8</var>). 
The return value is the value if the integer. Note that the size of the
value in the stream does not actually have to be 1 byte.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadInt16">  <!-- Function -->
<short>Read a 16-bit integer from the stream.</short>
<descr>
<var>ReadInt16</var> is called by the streaming process if it expects to 
read an integer value with a size of 16 bits (2 bytes) from the stream (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaInt16</var>). 
The return value is the value if the integer. Note that the size of the 
value in the stream does not actually have to be 2 bytes.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadInt32">  <!-- Function -->
<short>Read a 32-bit integer from the stream.</short>
<descr>
<var>ReadInt32</var> is called by the streaming process if it expects to 
read an integer value with a size of 32 bits (4 bytes) from the stream (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaInt32</var>). 
The return value is the value of the integer. Note that the size of the 
value in the stream does not actually have to be 4 bytes.
</descr> 
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadInt64">  <!-- Function -->
<short>Read a 64-bit integer from the stream.</short>
<descr>
<var>ReadInt64</var> is called by the streaming process if it expects to 
read an int64 value with a size of 64 bits (8 bytes) from the stream (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaInt64</var>). 
The return value is the value if the integer. Note that the size of the 
value in the stream does not actually have to be 8 bytes.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadSet">  <!-- Function -->
<short>Reads a set from the stream.</short>
<descr>
<p>
This method is called by the streaming system if it expects to read a 
set from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaSet</var>). The return value is the contents of the
set, encoded in a bitmask the following way:
</p>
<p>
For each (enumerated) value in the set, the bit corresponding to the 
ordinal value of the enumerated value should be set. i.e. 
as <var>1 shl ord(value)</var>.
</p>
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadStr"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadStr">  <!-- Function -->
<short>Read a shortstring from the stream</short>
<descr>
<var>ReadStr</var> is called by the streaming system if it expects to read a
string from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaLString</var>,<var>vaWstring</var> or 
<var>vaString</var>). The return value is the string.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadString"/>
</seealso>
</element>

<element name="TAbstractObjectReader.ReadString">  <!-- Function -->
<short>Read a string of type <var>StringType</var> from the stream.</short>
<descr>
<var>ReadStr</var> is called by the streaming system if it expects to read a
string from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaLString</var>,<var>vaWstring</var> or 
<var>vaString</var>). The return value is the string.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadFloat"/>
<link id="TAbstractObjectReader.ReadDate"/>
<link id="TAbstractObjectReader.ReadSingle"/>
<link id="TAbstractObjectReader.ReadIdent"/>
<link id="TAbstractObjectReader.ReadInt8"/>
<link id="TAbstractObjectReader.ReadInt16"/>
<link id="TAbstractObjectReader.ReadInt32"/>
<link id="TAbstractObjectReader.ReadInt64"/>
<link id="TabstractObjectReader.ReadSet"/>
<link id="TabstractObjectReader.ReadStr"/>
</seealso>
</element>

<element name="TAbstractObjectReader.SkipComponent">  <!-- Procedure -->
<short>Skip till the end of the component.</short>
<descr>
This method is used to skip the entire declaration of a component in the
stream. Each descendant of <var>TAbstractObjectReader</var> should implement
this in a way which is optimal for the implemented stream format.
</descr>
<seealso>
<link id="TAbstractObjectReader.BeginComponent"/>
<link id="TAbstractObjectReader.SkipValue"/>
</seealso>
</element>

<element name="TAbstractObjectReader.SkipValue">  <!-- Procedure -->
<short>Skip the current value.</short>
<descr>
<var>SkipValue</var> should be used when skipping a value in the stream;
The method should determine the type of the value which should be skipped
by itself, if this is necessary.
</descr>
<seealso>
<link id="TAbstractObjectReader.SkipComponent"/>
</seealso>
</element>

<!--
  *********************************************************************
  TBinaryObjectReader
  *********************************************************************
-->

<element name="TBinaryObjectReader">  <!-- Class -->
<short>Driver class descendant which reads component data stored in binary format.</short>
<descr>
<p>
The <var>TBinaryObjectReader</var> class reads component data stored in 
binary form in a file. For this, it overrides or implements all abstract
methods from <link id="TAbstractObjectReader"/>. No new functionality is 
added by this class, it is a driver class for the streaming system.
</p>
<p>
It should never be necessary to create an instance of this class directly.
Instead, the <link id="TStream.WriteComponent"/> call should be used.
</p>
</descr>
<seealso>
<link id="TAbstractObjectReader"/>
<link id="TBinaryObjectWriter"/>
</seealso>
</element>

<element name="TBinaryObjectReader.Create">  <!-- Constructor -->
<short>Creates a new binary data reader instance.</short>
<descr>
<var>Create</var> instantiates a new binary component data reader. The
<var>Stream</var> stream is the stream from which data will be read. The
<var>BufSize</var> argument is the size of the internal buffer that will be
used by the reader. This can be used to optimize the reading process.
</descr>
<seealso>
<link id="TAbstractObjectReader"/>
</seealso>
</element>

<element name="TBinaryObjectReader.Destroy">  <!-- Destructor -->
<short>Destroys the binary data reader.</short>
<descr>
<var>Destroy</var> frees the buffer allocated when the instance was created.
It also positions the stream on the last used position in the stream (the
buffering may cause the reader to read more bytes than were actually used.)
</descr>
<seealso>
<link id="TBinaryObjectReader.Create"/>
</seealso>
</element>

<element name="TFindMethodEvent">  <!-- Procedure type -->
<short>Occurs when the streaming process needs to locate a method</short>
<descr>
If a <link id="TReader"/> instance needs to locate a method and it doesn't
find it in the streamed form, then the <link
id="TReader.OnFindMethod">OnFindMethod</link> event handler will be called,
if one is installed. This event can be assigned in order to use different
locating methods. If a method is found, then its address should be returned
in <var>Address</var>. The <var>Error</var> should be set to <var>True</var> 
if the reader should raise an exception after the event was handled. If it 
is set to <var>False</var> no exception will be raised, even if no method
was found. On entry, <var>Error</var> will be set to <var>True</var>.
</descr>
</element>

<element name="TSetNameEvent">  <!-- Procedure type -->
<short>Occurs when the reader needs to set a component's name.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReferenceNameEvent">  <!-- Procedure type -->
<short>Occurs when a named object needs to be looked up.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAncestorNotFoundEvent">  <!-- Procedure type -->
<short>This event occurs when an ancestor component cannot be found.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReadComponentsProc">  <!-- Procedure type -->
<short>Callback type when reading a component from a stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReaderError">  <!-- Procedure type -->
<short>Event handler type, called when an error occurs during the streaming.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TFindComponentClassEvent">  <!-- Procedure type -->
<short>Event handler type, occurs when a component class pointer must be
found when reading a component from a stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TCreateComponentEvent">  <!-- Procedure type -->
<short>Event handler type, occurs when a component instance must be created
when a component is read from a stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TReader
  *********************************************************************
-->

<element name="TReader">  <!-- Class -->
<short>Generic reader object which reads component data from any given source.</short>
<descr>
<p>
The <var>TReader</var> class is a reader class that implements generic
component streaming capabilities, independent of the format of the data in
the stream. It uses a driver class <link id="TAbstractObjectReader"/> to
do the actual reading of data. The interface of the <var>TReader</var> class
should be identical to the interface in Delphi.
</p>
<p>
Note that the <var>TReader</var> design is such that it can read a single
component from a stream. It will read all children of this component, but
it is not designed to read multiple components in succession from one stream.
</p>
<p>
It should never be necessary to create an instance of this class directly.
Instead, the <link id="TStream.ReadComponent"/> call should be used.
</p>
</descr>
<seealso>
<link id="TFiler"/>
<link id="TWriter"/>
<link id="TAbstractObjectReader"/>
</seealso>
</element>

<element name="TReader.Error">  <!-- Function -->
<short>Calls an installed error handler and passes it <var>Message</var></short>
<descr>
<p>
<var>Error</var> returns <var>False</var> if no <link id="TReader.OnError"/>
handler is installed. If one is installed, then it will be called, passing
the reader instance, message, and function return value as parameters.
</p>
<p>
If the function result <var>False</var>, i.e. when there is no handler
installed or the handler restured <var>False</var>, then the calling code
will raise an exception.
</p>
</descr>
<seealso>
<link id="TReader.FindMethod"/>
</seealso>
</element>

<element name="TReader.FindMethod">  <!-- Function -->
<short>Return the address of a published method.</short>
<descr>
<p>
<var>FindMethod</var> will search for the method in <var>ARoot</var>. If it
isn't found there, then it will call a <var>OnFindMethod</var> handler, if
one is installed, passing it the method name <var>AMethodName</var>, the
result pointer and a variable which says whether an exception should be
raised if no method with name <var>AMethodName</var> is found.
</p>
<p>
If the method cannot be found and the <link
id="TReader.OnFindMethod">OnFindMethod</link> returns <var>True</var>, then
an exception will be raised.
</p>
</descr>
<seealso>
<link id="TReader.OnFindMethod"/>
<link id="TFindMethodEvent"/>
</seealso>
</element>

<element name="TReader.ReadProperty">  <!-- Procedure -->
<short>Read and process a property name</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadPropValue">  <!-- Procedure -->
<short>Reads a property value for <var>PropInfo</var>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.PropertyError">  <!-- Procedure -->
<short>Skips a property value and raises an exception.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadData">  <!-- Procedure -->
<short>Reads the components data after it has been created.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.PropName">  <!-- Property -->
<short>Name of the property being read at this moment.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.CanHandleExceptions">  <!-- Property -->
<short>Indicates whether the reader is handling exceptions at this stage.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.Create">  <!-- Constructor -->
<short>Creates a new reader class</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.Destroy">  <!-- Destructor -->
<short>Destroys a reader class.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.BeginReferences">  <!-- Procedure -->
<short>Initializes the component referencing mechanism.</short>
<descr>
When streaming components, the streaming mechanism keeps a list of existing
components that can be referenced to. This method initializes up that system.
</descr>
</element>

<element name="TReader.CheckValue">  <!-- Procedure -->
<short>Raises an exception if the next value in the stream is not of type
<var>Value</var></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.DefineProperty">  <!-- Procedure -->
<short>Reads a user-defined property from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.DefineBinaryProperty">  <!-- Procedure -->
<short>Reads a user-defined binary property from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.EndOfList">  <!-- Function -->
<short>Returns true if the stream contains an end-of-list marker.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.EndReferences">  <!-- Procedure -->
<short>Finalizes the component referencing mechanism.</short>
<descr>
When streaming components, the streaming mechanism keeps a list of existing
components that can be referenced to. This method cleans up that system.
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.FixupReferences">  <!-- Procedure -->
<short>Tries to resolve all unresolved component references.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.NextValue">  <!-- Function -->
<short>Returns the type of the next value.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadBoolean">  <!-- Function -->
<short>Reads a boolean from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadChar">  <!-- Function -->
<short>Reads a character from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadCollection">  <!-- Procedure -->
<short>Reads a collection from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadComponent">  <!-- Function -->
<short>Starts reading a component from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadComponents">  <!-- Procedure -->
<short>Starts reading child components from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadFloat">  <!-- Function -->
<short>Reads a float from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadSingle">  <!-- Function -->
<short>Reads a single-type real from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadDate">  <!-- Function -->
<short>Reads a date from the stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadIdent">  <!-- Function -->
<short>Reads an identifier from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadInteger">  <!-- Function -->
<short>Reads an integer from the stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadInt64">  <!-- Function -->
<short>Reads a 64-bit integer from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadListBegin">  <!-- Procedure -->
<short>Checks for the beginning of a list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadListEnd">  <!-- Procedure -->
<short>Checks for the end of a list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadRootComponent">  <!-- Function -->
<short>Starts reading a root component.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadString">  <!-- Function -->
<short>Reads a string from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.ReadValue">  <!-- Function -->
<short>Reads the next value type from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.CopyValue">  <!-- Procedure -->
<short>Copy a value to a writer.</short>
<descr>
<var>CopyValue</var> reads the next value from the reader stream, and writes
it to the passed <var>Writer</var>.
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.Owner">  <!-- Property -->
<short>Owner of the component being read</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.Parent">  <!-- Property -->
<short>Parent of the component being read.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.Driver">  <!-- Property -->
<short>The driver in use for streaming the data.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>



<element name="TReader.OnError">  <!-- Property -->
<short>Handler called when an error occurs.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnFindMethod">  <!-- Property -->
<short>Handler to find or change a method address.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnSetName">  <!-- Property -->
<short>Handler called when setting a component name.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnReferenceName">  <!-- Property -->
<short>Handler called when another component is referenced.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnAncestorNotFound">  <!-- Property -->
<short>Handler called when the ancestor component cannot be found.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnCreateComponent">  <!-- Property -->
<short>Handler called when a component needs to be created.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TReader.OnFindComponentClass">  <!-- Property -->
<short>Handler called when a component class reference needs to be found.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TAbstractObjectWriter
  *********************************************************************
-->

<element name="TAbstractObjectWriter">  <!-- Class -->
<short>Abstract driver class for writing component data.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.BeginCollection">  <!-- Procedure -->
<short>Start writing a collection.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.BeginComponent">  <!-- Procedure -->
<short>Start writing a component</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.BeginList">  <!-- Procedure -->
<short>Start writing a list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.EndList">  <!-- Procedure -->
<short>Mark the end of a list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.BeginProperty">  <!-- Procedure -->
<short>Start writing a property</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.EndProperty">  <!-- Procedure -->
<short>Marks the end of writing of a property.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteBinary">  <!-- Procedure -->
<short>Writes binary data to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteBoolean">  <!-- Procedure -->
<short>Writes a boolean value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteFloat">  <!-- Procedure -->
<short>Writes a float value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteSingle">  <!-- Procedure -->
<short>Writes a single-type real value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteDate">  <!-- Procedure -->
<short>Writes a date type to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteIdent">  <!-- Procedure -->
<short>Writes an identifier to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteInteger">  <!-- Procedure -->
<short>Writes an integer value to the stream</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteMethodName">  <!-- Procedure -->
<short>Writes a methodname to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteSet">  <!-- Procedure -->
<short>Writes a set value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TAbstractObjectWriter.WriteString">  <!-- Procedure -->
<short>Writes a string value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TBinaryObjectWriter
  *********************************************************************
-->

<element name="TBinaryObjectWriter">  <!-- Class -->
<short>Driver class which stores component data in binary form.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TBinaryObjectWriter.Create">  <!-- Constructor -->
<short>Creates a new instance of a binary object writer.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TBinaryObjectWriter.Destroy">  <!-- Destructor -->
<short>Destroys an instance of the binary object writer.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TBinaryObjectWriter.BeginCollection"
link="TAbstractObjectWriter.BeginCollection">  
<short>Start writing a collection.</short>
</element>

<element name="TBinaryObjectWriter.BeginComponent"
link="TAbstractObjectWriter.BeginComponent">  <!-- Procedure -->
<short>Start writing a component</short>
</element>

<element name="TBinaryObjectWriter.BeginList"
link="TAbstractObjectWriter.BeginList">  <!-- Procedure -->
<short>Start writing a list.</short>
</element>

<element name="TBinaryObjectWriter.EndList"
link="TAbstractObjectWriter.EndList">  <!-- Procedure -->
<short>Mark the end of a list.</short>
</element>

<element name="TBinaryObjectWriter.BeginProperty"
link="TAbstractObjectWriter.BeginProperty">  <!-- Procedure -->
<short>Start writing a property</short>
</element>

<element name="TBinaryObjectWriter.EndProperty"
link="TAbstractObjectWriter.EndProperty">  <!-- Procedure -->
<short>Marks the end of writing of a property.</short>
</element>

<element name="TBinaryObjectWriter.WriteBinary"
link="TAbstractObjectWriter.WriteBinary">  <!-- Procedure -->
<short>Writes binary data to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteBoolean"
link="TAbstractObjectWriter.WriteBoolean">  <!-- Procedure -->
<short>Writes a boolean value to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteFloat"
link="TAbstractObjectWriter.WriteFloat">  <!-- Procedure -->
<short>Writes a float value to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteSingle"
link="TAbstractObjectWriter.WriteSingle">  <!-- Procedure -->
<short>Writes a single-type real value to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteDate"
link="TAbstractObjectWriter.WriteDate">  <!-- Procedure -->
<short>Writes a date type to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteIdent"
link="TAbstractObjectWriter.WriteIdent">  <!-- Procedure -->
<short>Writes an identifier to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteInteger"
link="TAbstractObjectWriter.WriteInteger">  <!-- Procedure -->
<short>Writes an integer value to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteMethodName"
link="TAbstractObjectWriter.WriteMethodName">  <!-- Procedure -->
<short>Writes a methodname to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteSet"
link="TAbstractObjectWriter.WriteSet">  <!-- Procedure -->
<short>Writes a set value to the stream.</short>
</element>

<element name="TBinaryObjectWriter.WriteString"
link="TAbstractObjectWriter.WriteString">  <!-- Procedure -->
<short>Writes a string value to the stream.</short>
</element>

<!--
  *********************************************************************
  TTextObjectWriter
  *********************************************************************
-->

<element name="TTextObjectWriter">  <!-- Class -->
<short>Driver class which stores component data in text format.</short>
<descr>
Not yet implemented.
</descr>
<seealso>
</seealso>
</element>

<element name="TFindAncestorEvent">  <!-- Procedure type -->
<short>Event that occurs w</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TWriter
  *********************************************************************
-->

<element name="TWriter">  <!-- Class -->
<short>Object to write component data to an arbitrary format.</short>
<descr>
<p>
The <var>TWriter</var> class is a writer class that implements generic
component streaming capabilities, independent of the format of the data in
the stream. It uses a driver class <link id="TAbstractObjectWriter"/> to
do the actual reading of data. The interface of the <var>TWriter</var> class
should be identical to the interface in Delphi.
</p>
<p>
Note that the <var>TWriter</var> design is such that it will write a single
component to a stream. It will write all children of this component, but
it is not designed to write multiple components in succession to one stream.
</p>
<p>
It should never be necessary to create an instance of this class directly.
Instead, the <link id="TStream.WriteComponent"/> call should be used.
</p>
</descr>
<seealso>
<link id="TFiler"/>
<link id="TWriter"/>
<link id="TAbstractObjectReader"/>
</seealso>
</element>

<element name="TWriter.SetRoot" link="TFiler.SetRoot">   <!-- Procedure -->
<short>Sets the root component</short>
</element>

<element name="TWriter.WriteBinary">  <!-- Procedure -->
<short>Writes binary data to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteProperty">  <!-- Procedure -->
<short>Writes one property to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteProperties">  <!-- Procedure -->
<short>Writes the published properties to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.Create">  <!-- Constructor -->
<short>Creates a new Writer instance with a driver.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.Create">  <!-- Constructor -->
<short>Creates a new Writer with a stream and bufsize.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.Destroy">  <!-- Destructor -->
<short>Destroys the writer instance.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.DefineProperty">  <!-- Procedure -->
<short>Callback used when defining and streaming custom properties.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.DefineBinaryProperty">  <!-- Procedure -->
<short>Callback used when defining and streaming custom properties.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteBoolean">  <!-- Procedure -->
<short>Write boolean value to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteCollection">  <!-- Procedure -->
<short>Write a collection to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteComponent">  <!-- Procedure -->
<short>Stream a component to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteChar">  <!-- Procedure -->
<short>Write a character to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteDescendant">  <!-- Procedure -->
<short>Write a descendant component to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteFloat">  <!-- Procedure -->
<short>Write a float to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteSingle">  <!-- Procedure -->
<short>Write a single-type real to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteDate">  <!-- Procedure -->
<short>Write a date to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteIdent">  <!-- Procedure -->
<short>Write an identifier to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteInteger">  <!-- Procedure -->
<short>Write an integer to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteListBegin">  <!-- Procedure -->
<short>Write a start-of-list marker to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteListEnd">  <!-- Procedure -->
<short>Write an end-of-list marker to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteRootComponent">  <!-- Procedure -->
<short>Write a root component to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.WriteString">  <!-- Procedure -->
<short>Write a string to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.RootAncestor">  <!-- Property -->
<short>Ancestor of root component.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.OnFindAncestor">  <!-- Property -->
<short>Event occurring when an ancestor component must be found.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TWriter.Driver">  <!-- Property -->
<short>Driver used when writing to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TParser
  *********************************************************************
-->

<element name="TParser">  <!-- Class -->
<short>Class to parse the contents of a stream containing text data.</short>
<descr>
<p>This class breaks a stream of text data in tokens. Its primary use is to help reading the contents of a form file (usually a file with dfm, xfm or lfm extension), and for this reason it isn't suitable to be used as a general parser.</p>
<p>The parser is always positioned on a certain token, whose type is stored in the <link id="TParser.Token">Token</link> property. Various methods are provided to obtain the token value in the desired format.</p>
<p>To advance to the next token, invoke <link id="TParser.NextToken">NextToken</link> method.</p>
</descr>
<seealso>
<link id="TParser.Token"/>
<link id="TParser.NextToken"/>
</seealso>
</element>

<element name="TParser.Create">  <!-- Constructor -->
<short>Creates a new parser instance.</short>
<descr>
<p><var>Create</var> creates a new <var>TParser</var> instance, using <var>Stream</var> as the stream to read data from, and reads the first token from the stream.</p>
</descr>
<errors>
<p>If an error occours while parsing the first token, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.Token"/>
</seealso>
</element>

<element name="TParser.Destroy">  <!-- Destructor -->
<short>Destroys the parser instance.</short>
<descr>
</descr>
<errors>
None.
</errors>
<seealso>
</seealso>
</element>

<element name="TParser.CheckToken">  <!-- Procedure -->
<short>Checks whether the token if of the given type.</short>
<descr>
</descr>
<errors>
<p>If current token isn't of type <var>T</var>, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.Token"/>
</seealso>
</element>

<element name="TParser.CheckTokenSymbol">  <!-- Procedure -->
<short>Checks whether the token equals the given symbol</short>
<descr>
<p><var>CheckTokenSymbol</var> performs a case-insensitive comparison of current token value with <var>S</var>.</p>
<p>Current token must be of type <link id="toSymbol"/>, otherwise an <link id="EParserError"/> exception is raised.</p>
</descr>
<errors>
<p>If the comparison fails, or current token isn't a symbol, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.TokenSymbolIs"/>
<link id="toSymbol"/>
</seealso>
</element>

<element name="TParser.Error">  <!-- Procedure -->
<short>Raises an <link id="EParserError"/> exception with the given message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TParser.ErrorFmt">  <!-- Procedure -->
<short>Raises an <link id="EParserError"/> exception and formats the message.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TParser.ErrorStr">  <!-- Procedure -->
<short>Raises an <link id="EParserError"/> exception with the given message</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TParser.HexToBinary">  <!-- Procedure -->
<short>Writes hexadecimal data to a stream.</short>
<descr>
<p><var>HexToBinary</var> reads a sequence of hexadecimal characters from the input stream and converts them to a sequence of bytes which is written to <var>Stream</var>. Each byte is represented by two contiguous hexadecimal characters.</p>
<p>Whitespace is allowed between hexadecimal characters if it doesn't appear between two characters that form the same byte.</p>
<p><var>HexToBinary</var> stops when the first non-hexadecimal and non-whitespace character is found, or the end of the input stream is reached.</p>
<remark>
<p>This method begins reading after the current token: that is, current token, even if it's a valid hexadecimal value, isn't included.</p>
</remark>
</descr>
<errors>
<p>If a single hexadecimal character is found, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
</seealso>
</element>

<element name="TParser.NextToken">  <!-- Function -->
<short>Reads the next token and returns its type.</short>
<descr>
<p><var>NextToken</var> parses the next token in the stream and returns its type. The type of the token can also be retrieved later reading <link id="TParser.Token">Token</link> property.</p>
<p>If the end of the stream is reached, <link id="toEOF"/> is returned.</p>
<p>For details about token types, see <link id="TParser.Token"/></p>
</descr>
<errors>
<p>If an error occours while parsing the token, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.Token"/>
</seealso>
</element>

<element name="TParser.SourcePos">  <!-- Function -->
<short>Returns the current position in the stream.</short>
<descr>
<remark>This is not the character position relative to the current source line, but the byte offset from the beginning of the stream.</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TParser.SourceLine"/>
</seealso>
</element>

<element name="TParser.TokenComponentIdent">  <!-- Function -->
<short>Returns the path of a subcomponent starting from the current token.</short>
<descr>
<p>If current token is <link id="toSymbol"/>, <var>TokenComponentIdent</var> tries to find subcomponent names separated by a dot (<var>.</var>). The returned string is the longest subcomponent path found. If there are no subcomponents, current symbol is returned.</p>
<remark><p>After this method has been called, subsequent calls to <link id="TParser.TokenString">TokenString</link> or <link id="TParser.TokenWideString">TokenWideString</link> return the same value returned by <var>TokenComponentIdent</var>.</p></remark>
<p><b>Example</b></p>
<p>If source stream contains <var>a.b.c</var> and <var>TParser</var> is positioned on the first token (<var>a</var>), this method returns <var>a.b.c</var>.</p>
</descr>
<errors>
<p>If <link id="TParser.Token">Token</link> isn't <link id="toSymbol"/>, or no valid symbol is found after a dot, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.Token"/>
<link id="TParser.TokenString"/>
<link id="TParser.TokenWideString"/>
<link id="toSymbol"/>
</seealso>
</element>

<element name="TParser.TokenFloat">  <!-- Function -->
<short>Returns the current token as a float.</short>
<descr>
<p>If current token type is <link id="toFloat"/>, this method returns the token value as a float.</p>
<p>To specify a negative number, no space must exist between unary minus and number.</p>
<p>Floating point numbers can be postfixed with a character that specifies the floating point type. See <link id="TParser.FloatType">FloatType</link> for further information.</p>
<remark>
<p>In the input stream the decimal separator, if present, must be a dot (<var>.</var>).</p>
</remark>
</descr>
<errors>
<p>If <link id="TParser.Token">Token</link> isn't <link id="toFloat"/>, an <link id="EParserError"/> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.FloatType"/>
<link id="TParser.NextToken"/>
<link id="TParser.Token"/>
<link id="toFloat"/>
</seealso>
</element>

<element name="TParser.TokenInt">  <!-- Function -->
<short>Returns the current token as an integer.</short>
<descr>
<p>If current token type is <link id="toInteger"/>, this method returns the token value as an integer.</p>
<p>In the input stream an integer can be an hexadecimal (prefixed by <var>'$'</var> character) or decimal number. Decimal numbers can be prefixed by an unary minus: if this is the case, no space must exist between minus and number.</p>
</descr>
<errors>
<p>If <link id="TParser.Token">Token</link> isn't <link id="toInteger"/>, an <link id="sysutils.EConvertError">EConvertError</link> exception is raised.</p>
</errors>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.Token"/>
<link id="toInteger"/>
</seealso>
</element>

<element name="TParser.TokenString">  <!-- Function -->
<short>Returns the current token as a string.</short>
<descr>
<p>If current token type is <link id="toString"/> or <link id="toWString"/>, this method returns the contents of the string. That is, enclosing quotes are removed, embedded quotes are unescaped and control strings are converted to the appropriate sequence of characters.</p>
<p>If current token type isn't a string, a string containing the token representation in the input stream is returned, without any conversion: hexadecimal integers are returned with the leading <var>$</var>, and floating point suffixes like <var>s</var>, <var>c</var> or <var>d</var> are kept. For tokens whose type isn't a special type, return value of <var>TokenString</var> equals <link id="TParser.Token">Token</link>.</p>
<remark><p>If <link id="TParser.Token">Token</link> is <link id="toWString"/>, <link id="TParser.TokenWideString">TokenWideString</link> should be used instead.</p></remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.TokenWideString"/>
<link id="TParser.Token"/>
<link id="toString"/>
<link id="toWString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TParser.TokenWideString">
<short>Returns the current token as a widestring</short>
<descr>
<p>If current token type is <link id="toWString"/>, this method returns the contents of the string. That is, enclosing quotes are removed, embedded quotes are unescaped and control strings are converted to the appropriate sequence of characters.</p>
<p>If current token isn't a widestring, <var>TokenWideString</var> behaviour is the same as <link id="TParser.TokenString">TokenString</link>.</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.TokenString">TokenString</link>
<link id="TParser.Token"/>
<link id="toWString"/>
</seealso>
</element>

<element name="TParser.TokenSymbolIs">  <!-- Function -->
<short>Returns <var>True</var> if the token equals the given symbol.</short>
<descr>
<p><var>TokenSymbolIs</var> performs a case-insensitive comparison of current token value with <var>S</var>.</p>
<p>If current token isn't of type <link id="toSymbol"/>, or comparison fails, <var>False</var> is returned.</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TParser.CheckTokenSymbol"/>
<link id="TParser.Token"/>
</seealso>
</element>

<element name="TParser.FloatType">  <!-- Property -->
<short>The type of a float token.</short>
<descr>
<p>Floating point numbers can be postfixed with a character specifying the type of floating point value. When specified, this property holds the character postfixed to the number.</p>
<p>It can be one of the following values:</p>
<table>
<tr>
<td><var>s</var> or <var>S</var></td><td>Value is a single.</td>
</tr>
<tr>
<td><var>c</var> or <var>C</var></td><td>Value is a currency.</td>
</tr>
<tr>
<td><var>d</var> or <var>D</var></td><td>Value is a date.</td>
</tr>
</table>
<p>If <link id="TParser.Token">Token</link> isn't <link id="toFloat"/> or one of the above characters wasn't specified, <var>FloatType</var> is the null character (zero).</p>
</descr>
<seealso>
<link id="TParser.NextToken"/>
<link id="TParser.Token"/>
<link id="TParser.TokenFloat"/>
<link id="toFloat"/>
</seealso>
</element>

<element name="TParser.SourceLine">  <!-- Property -->
<short>Current source line number.</short>
<descr>
</descr>
<seealso>
<link id="TParser.SourcePos"/>
</seealso>
</element>

<element name="TParser.Token">  <!-- Property -->
<short>The type of the current token.</short>
<descr>
<p>This property holds the type of the current token. When <var>Token</var> isn't one of the special token types (whose value can be retrieved with specific methods) it is the character representing the current token.</p>
<p>Special token types:</p>
<table>
<tr>
<td><link id="toEOF"/></td><td><printshort id="toEOF"/></td>
</tr>
<tr>
<td><link id="toSymbol"/></td><td><printshort id="toSymbol"/></td>
</tr>
<tr>
<td><link id="toString"/></td><td><printshort id="toString"/></td>
</tr>
<tr>
<td><link id="toInteger"/></td><td><printshort id="toInteger"/></td>
</tr>
<tr>
<td><link id="toFloat"/></td><td><printshort id="toFloat"/></td>
</tr>
<tr>
<td><link id="toWString"/></td><td><printshort id="toWString"/></td>
</tr>
</table>
<p>To advance to the next token, use <link id="TParser.NextToken">NextToken</link> method.</p>
</descr>
<seealso>
<link id="TParser.CheckToken"/>
<link id="TParser.NextToken"/>
<link id="TParser.TokenComponentIdent"/>
<link id="TParser.TokenFloat"/>
<link id="TParser.TokenInt"/>
<link id="TParser.TokenString"/>
<link id="TParser.TokenWideString"/>
</seealso>
</element>

<!--
  *********************************************************************
  EThread
  *********************************************************************
-->

<element name="EThread">  <!-- Class -->
<short>Thread error exception.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadMethod">  <!-- Procedure type -->
<short>Procedure variable used when synchronizing threads.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority">  <!-- Enumeration type -->
<short>Enumeration specifying the priority at which a thread runs.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpIdle">  <!-- Enumeration value -->
<short>Thread only runs when other processes are idle.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpLowest">  <!-- Enumeration value -->
<short>Thread runs at the lowest priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpLower">  <!-- Enumeration value -->
<short>Thread runs at a lower priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpNormal">  <!-- Enumeration value -->
<short>Thread runs at normal process priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpHigher">  <!-- Enumeration value -->
<short>Thread runs at high priority</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpHighest">  <!-- Enumeration value -->
<short>Thread runs at highest possible priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThreadPriority.tpTimeCritical">  <!-- Enumeration value -->
<short>Thread runs at realtime priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TThread
  *********************************************************************
-->
<element name="TThread">  <!-- Class -->
<short>Abstract Thread class.</short>
<descr>
<p>
The <var>TThread</var> class encapsulates the native thread support of the
operating system. To create a thread, declare a descendant of the
<var>TThread</var> object and override the <link
id="TThread.Execute">Execute</link> method. In this method, the tthread's
code should be executed. To run a thread, create an instance of the tthread
descendant, and call it's execute method.
</p>
<p>
It is also possible to simply execute a method or static procedure in a thread using the 
<link id="TThread.ExecuteInThread"/> class method.
</p>
</descr>
<seealso>
<link id="EThread"/>
<link id="TThread.Execute"/>
<link id="TThread.ExecuteInThread"/>
</seealso>
</element>

<element name="TThread.DoTerminate">  <!-- Procedure -->
<short>Terminates the thread.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Execute" alwaysvisible="1">  <!-- Procedure -->
<short>Execute method. Must be overridden in a descendant thread.</short>
<descr>
<var>Execute</var> is a method that must be overridden in descendant classes
of the thread. It must contain the code that must execute in the thread. The
<var>Execute</var> method is responsible for checking <link id="Terminated"/>
at regular intervals: when it is set to <var>True</var> the execute method
must exit.
</descr>
<seealso>
<link id="Terminated"/>
</seealso>
</element>

<element name="TThread.Synchronize" alwaysvisible="1">  <!-- Procedure -->
<short>Synchronizes the thread by executing the method in the main thread.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.ReturnValue">  <!-- Property -->
<short>Return value of the thread when it stops executing.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Terminated">  <!-- Property -->
<short>Indicates whether the <link id="TThread.Terminate">Terminate</link>method was called by the user.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.FStackPointer">  <!-- Variable -->
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.FStackSize">  <!-- Variable -->
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.FCallExitProcess">  <!-- Variable -->
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Create">  <!-- Constructor -->
<short>Creates a new thread.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Destroy">  <!-- Destructor -->
<short>Destroys the thread object.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Resume">  <!-- Procedure -->
<short>Resumes the thread's execution. Deprecated, see <var>TThread.Start</var></short>
<descr>
</descr>
<seealso>
<link id="TThread.Start"/>
<link id="TThread.Suspend"/>
</seealso>
</element>

<element name="TThread.Start">  <!-- Procedure -->
<short>Starts a thread that was created in a suspended state.</short>
<descr>
The effect of this method is currently the same as calling <var>TThread.Resume</var> after creating a thread in a suspended state. This method was added for Delphi-compatibility, where it was introduced after <var>TThread.Suspend</var> and <var>TThread.Resume</var> were deprecated.
</descr>
<seealso>
<link id="TThread.Create"/>
</seealso>
</element>

<element name="TThread.Suspend">  <!-- Procedure -->
<short>Suspends the thread's execution.</short>
<descr>
On non-Windows platforms, a thread can only suspend itself. Other threads can wake up a suspended thread by calling <var>TThread.Start</var>.
</descr>
<seealso>
<link id="TThread.Resume"/>
<link id="TThread.Start"/>
</seealso>
</element>

<element name="TThread.Terminate">  <!-- Procedure -->
<short>Signals the thread it should terminate.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.WaitFor">  <!-- Function -->
<short>Waits for the thread to terminate and returns the exit status.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.FreeOnTerminate">  <!-- Property -->
<short>Indicates whether the thread should free itself when it stops executing.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Handle">  <!-- Property -->
<short>Returns the thread handle.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Priority">  <!-- Property -->
<short>Returns the thread priority.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.Suspended">  <!-- Property -->
<short>Indicates whether the thread is suspended.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.ThreadID">  <!-- Property -->
<short>Returns the thread ID.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TThread.OnTerminate">  <!-- Property -->
<short>Event called when the thread terminates.</short>
<descr>
<var>TThread.OnTerminate</var> is called when the thread terminates. The
event is always called in the context of the main thread, i.e. using <link id="TThread.Synchronize"/>
</descr>
<seealso>
<link id="TThread.Synchronize"/>
<link id="TThread.FreeOnTerminate"/>
</seealso>
</element>

<element name="TOperation">  <!-- Enumeration type -->
<short>Operation of which a component is notified.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TOperation.opInsert">  <!-- Enumeration value -->
<short>A new component is being inserted in the child component list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TOperation.opRemove">  <!-- Enumeration value -->
<short>A component is being removed from the child component list.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState">  <!-- Set type -->
<short>Indicates the state of the component during the streaming process.</short>
<descr>
<p>The following values are possible:</p>
<dl>
<dt>csLoading</dt>
<dd>
The component (and all child components) are being loaded from a stream. 
This means that a <link id="TReader"/> instance is reading properties from 
this and child components from a stream and is applying the values found in 
the stream to the properties. 
</dd>
<dt>csReading</dt>
<dd>
The properties of this component are being read from a stream. 
This means that a <link id="TReader"/> instance is reading properties from 
this component from a stream and is applying the values.
</dd>
<dt>csWriting</dt>
<dd>
The properties of this component are being written to a stream. 
This means that a <link id="TWriter"/> instance is writing properties from
this component to a stream.
</dd>
<dt>csDestroying</dt>
<dd>
The component is being destroyed.
</dd>
<dt>csDesigning</dt>  <!-- Enumeration value -->
<dd>
The component is being designed in an IDE.
</dd>
<dt>csAncestor</dt>
<dd>
The component has a design ancestor. This is used to record differences
between a component and it's design ancestor. For example a form <var>TForm2</var> inherited
from a form <var>TForm1</var>. <var>TForm1</var> and all its components are copied to
<var>TForm2</var>. <var>TForm2</var> and all its inherited components have
<var>csAncestor</var> set. Only differences between <var>TForm1</var> and
<var>TForm2</var> are stored in the stream of <var>TForm2</var>. 
The child components of a frame put onto a form have <var>csAncestor</var> too.
</dd>
<dt>csInline</dt>
<dd>
The component is a nested top level component. For example a frame on a
form. The children of the frame do not have <var>csInline</var>, unless they are
other frames.
</dd>
<dt>csDesignInstance</dt>
<dd>
The component is designed (<var>csDesigning</var>) and is a root component,
meaning it has no owner (<var>Owner=nil</var>).
</dd>
<dt>csFixups</dt>  <!-- Enumeration value -->
<dd>The component's references to other components are being fixed.
While reading a component from stream, it can happen that the stream
contains a component reference property with a name of a component 
that was not yet created and read from the stream. 
Such properties are saved, and the missing references are resolved when the
complete stream was read. This resolving step is called fixing up
references, and the <var>csFixups</var> flags is set during this step.
</dd>
<dt>csFreeNotification</dt> 
<dd>
This flag indicates that the component has free notifications registered with
<link id="TComponent.FreeNotification"/>
</dd>
</dl>
</descr>
</element>

<element name="TComponentState.csLoading">  <!-- Enumeration value -->
<short>The component is being loaded from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csReading">  <!-- Enumeration value -->
<short>Properties are being read from the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csWriting">  <!-- Enumeration value -->
<short>Properties are being written to the stream.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csDestroying">  <!-- Enumeration value -->
<short>The component is being destroyed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csDesigning">  <!-- Enumeration value -->
<short>The component is being designed in an IDE.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csAncestor">  <!-- Enumeration value -->
<short>The component is being streamed as part of a frame (?)</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csUpdating">  <!-- Enumeration value -->
<short>The component is being updated.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csFixups">  <!-- Enumeration value -->
<short>The component's references to other components are being fixed.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csFreeNotification">  <!-- Enumeration value -->
<short>Indicates whether the component has freenotifications</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csInline">  <!-- Enumeration value -->
<short>Component is part of a frame (?).</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentState.csDesignInstance">  <!-- Enumeration value -->
<short>??</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentStyle">  <!-- Set type -->
<short>Describes the style of the component.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentStyle.csInheritable">  <!-- Enumeration value -->
<short>The component can be on inherited forms.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponentStyle.csCheckPropAvail">  <!-- Enumeration value -->
<short>??</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TGetChildProc">  <!-- Procedure type -->
<short>Callback used when obtaining child components.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!--
  *********************************************************************
  TComponent
  *********************************************************************
-->

<element name="TComponent">  <!-- Class -->
<short>Base class for all components that need owner-owned functionality.</short>
<descr>
<p>
<var>TComponent</var> is the base class for any set of classes that needs
owner-owned functionality, and which needs support for property streaming.
All classes that should be handled by an IDE (Integrated Development 
Environment) must descend from <var>TComponent</var>, as it includes all
support for streaming all its published properties.
</p>
<p>
Components can 'own' other components. <var>TComponent</var> introduces
methods for enumerating the child components. It also allows to name the
owned components with a unique name. Furthermore, functionality for 
sending notifications when a component is removed from the list or
removed from memory alltogether is also introduced in <var>TComponent</var>
</p>
<p>
<var>TComponent</var> introduces a form of automatic memory management: When
a component is destroyed, all its child components will be destroyed first.
</p>
</descr>
</element>


<element name="TComponent.FComponentStyle">  <!-- Variable -->
<short>Contains the component's style.</short>
<descr>
<var>FComponentStyle</var> is the location where the <link
id="TComponent.ComponentStyle">ComponentStyle</link> property is read from.
</descr>
<seealso>
</seealso>
<link id="TComponent.ComponentStyle">ComponentStyle</link>
</element>

<element name="TComponent.ChangeName">  <!-- Procedure -->
<short>Actually sets the component name.</short>
<descr>
<p>
<var>ChangeName</var> is called by the <link
id="TComponent.SetName">SetName</link> procedure when the component name is
set and the name has been verified. It actually sets  the name of the 
component to <var>NewName</var>, and can be used to bypass the name checks which are done when the
<link id="TComponent.Name">Name</link> property is set.
</p>
<p>
Application programmers should never use <var>SetName</var> directly.
</p>
</descr>
<seealso>
<link id="TComponent.SetName">SetName</link>
<link id="TComponent.Name">Name</link>
</seealso>
</element>

<element name="TComponent.DefineProperties">  <!-- Procedure -->
<short>Defines fake top,left properties for handling in the IDE.</short>
<descr>
<var>DefineProperties</var> overrides the standard <link
id="TPersistent.DefineProperties"/> to store the top/left properties used to
display an icon for a non-visual component in an IDE.
</descr>
<seealso>
<link id="TPersistent.DefineProperties"/>
</seealso>
</element>

<element name="TComponent.GetChildren">  <!-- Procedure -->
<short>Must be overridden by descendants to return all child components that must be streamed.</short>
<descr>
<p>
<var>GetChildren</var> is called by the streaming system to determine which
child components should be streamed as well when the component is being 
streamed. 
By default, no child components are streamed, i.e. the <var>TComponent</var>
implementation is empty.
</p>
<p>
<var>TComponent</var> descendants should override this method. For each
child that needs to be streamed, <var>Proc</var> should be called with as
an argument the child component that must be streamed. The <var>Root</var>
argument contains the root component relative to which all streaming is
done.
</p>
</descr>
<seealso>
<link id="TComponent.WriteState"/>
</seealso>
</element>

<element name="TComponent.GetChildOwner">  <!-- Function -->
<short>Returns the owner of any children.</short>
<descr>
<p>
<var>GetChildOwner</var> returns the owner of the children that are read from the stream.
If the method returns <var>Nil</var> (the default) this means that streamed
child components are owned by the root component of the streaming process
(usually a Form or Datamodule)
</p>
<p>
Application programmers should not call <var>GetChildOwner</var> directly,
it is called by the streaming system when needed.
</p>
</descr>
<seealso>
<link id="TComponent.WriteState"/>
<link id="TComponent.ReadState"/>
<link id="TComponent.Owner"/>
<link id="TComponent.GetChildParent"/>
</seealso>
</element>

<element name="TComponent.GetChildParent">  <!-- Function -->
<short>Returns the parent of any children.</short>
<descr>
<p>
<var>GetChildParent</var> returns the parent component of the child
components being streamed. The parent property is a visual property, which
is not always meaningful. If there is no parent component, the owner 
of child components that are streamed is returned. If <var>Nil</var> is
returned, then the root component of the streaming operation is assumed.
The <var>TComponent</var> implementation of this method returns
<var>Self</var>. 
</p>
<p>
Application programmers should not call this method, it is called
automatically by the streaming mechanism.
</p>
</descr>
<seealso>
<link id="TComponent.GetChildOwner"/>
</seealso>
</element>

<element name="TComponent.GetNamePath">  <!-- Function -->
<short>Returns the name path of this component.</short>
<descr>
<p>
<var>GetNamePath</var> returns the name of the component as it will be 
shown in the object inspector. 
</p>
<p>
<var>TComponent</var> overrides <var>GetNamePath</var> so it returns the
<link id="TComponent.Name">Name</link> property of the component.
</p>
</descr>
<seealso>
<link id="TComponent.Name">Name</link>
<link id="TPersistent.GetNamePath"/>
</seealso>
</element>

<element name="TComponent.GetOwner">  <!-- Function -->
<short>Returns the owner of this component.</short>
<descr>
<var>GetOwner</var> returns the owner of this component as indicated by the 
<link id="TComponent.Owner">Owner</link> property. The
<var>GetOwner</var> call is introduced in <link id="TPersistent"/>
and is used by the streaming system to determine the 'owner' of a component.
</descr>
<seealso>
<link id="TPersistent.GetOwner"/>
<link id="TComponent.Owner"/>
</seealso>
</element>

<element name="TComponent.Loaded">  <!-- Procedure -->
<short>Called when the component has finished loading.</short>
<descr>
<p>
<var>Loaded</var> is called by the streaming system when a root
component was completely read from a stream and all properties and 
references to other objects have been resolved by the streaming 
system. Descendants of <var>TComponent</var> should override this method to
do some additional processing of properties after all published 
properties have been set from values obtained from the stream.
</p>
<p>
Application programmers should never call <var>Loaded</var> directly, this
is done automatically by the streaming system.
</p>
</descr>
<seealso>
<link id="TComponent.ReadState"/>
<link id="TComponent.ComponentState"/>
</seealso>
</element>

<element name="TComponent.Notification" alwaysvisible="1">  <!-- Procedure -->
<short>Called by components that are freed and which received a FreeNotification.</short>
<descr>
<p>
<var>Notification</var> is called whenever a child component is destroyed,
inserted or removed from the list of owned component. Components that
were requested to send a notification when they are freed 
((with <link id="TComponent.FreeNotification">FreeNotification</link>)
will also call <var>Notification</var> when they are freed.
</p>
<p>The <var>AComponent</var> parameter specifies which component sends the
notification, and <var>Operation</var> specifies whether the component is
being inserted into or removed from the child component list, or whether it
is being destroyed.
</p>
<p>
Descendants of <var>TComponent</var> can use <link
id="TComponent.FreeNotification">FreeNotification</link> to request
notification of the destruction of another object. By overriding the
<var>Notification</var> method, they can do special processing (typically,
set a reference to this component to <var>Nil</var>) 
when this component is destroyed. The <var>Notification</var> method is
called quite often in the streaming process, so speed should be a
consideration when overriding this method.
</p> 
</descr>
<seealso>
<link id="TOperation"/>
<link id="TComponent.FreeNotification"/>
<link id="TComponent.RemoveFreeNotification"/>
</seealso>
</element>

<element name="TComponent.ReadState">  <!-- Procedure -->
<short>Read the component's state from a stream.</short>
<descr>
<p>
<var>ReadState</var> reads the component's state from a stream through the
reader object <var>reader</var>. Values for all published properties of 
the component can be read from the stream. Normally there is no need to 
call <var>ReadState</var> directly. The streaming system calls 
<var>ReadState</var> itself. 
</p>
<p>
The <link id="TComponent"/> implementation of <var>ReadState</var> simply
calls <link id="TReader.ReadData"/> Descendant classes can, however, 
override  <var>ReadState</var>to provide additional processing of stream 
data.
</p>
</descr>
<seealso>
<link id="TComponent.WriteState">WriteState</link>
<link id="TStream.ReadComponent"/>
<link id="TReader.ReadData"/>
</seealso>
</element>

<element name="TComponent.SetAncestor">  <!-- Procedure -->
<short>Sets the <var>csAncestor</var> state of the component.</short>
<descr>
<p>
<var>SetAncestor</var> includes or excludes the <var>csAncestor</var> flag
in the <link id="TComponent.ComponentState">ComponentState</link> set property, 
depending on the boolean <var>Value</var>. The flag is set recursively for
all owned components as well.
</p>
<p>
This is normally only done during the streaming system, and should not be called 
directly by an application programmer.
</p>
</descr>
<seealso>
<link id="TComponent.ComponentState">ComponentState</link>
</seealso>
</element>

<element name="TComponent.SetDesigning">  <!-- Procedure -->
<short>Sets the <var>csDesigning</var> state of the component.</short>
<descr>
<p>
<var>SetDesigning</var> includes or excludes the <var>csDesigning</var> flag
in the <link id="TComponent.ComponentState">ComponentState</link> set property, 
depending on the boolean <var>Value</var>. The flag is set recursively for
all owned components as well.
</p>
<p>
This is normally only done during the streaming system, and should not be called 
directly by an application programmer.
</p>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponent.SetName">  <!-- Procedure -->
<short>Write handler for <link id="TComponent.Name">Name</link> property.</short>
<descr>
<var>SetName</var> is the write handler for the <link
id="TComponent.Name">Name</link> property. It checks whether the desired
name is valid (i.e is a valid identifier) and is unique among the children
of the owner component. If either conditions is not satisfied, an exception
is raised.
</descr>
<seealso>
<link id="TComponent.Name">Name</link>
<link id="TComponent.ValidateRename">ValidateRename</link>
</seealso>
</element>

<element name="TComponent.SetChildOrder">  <!-- Procedure -->
<short>Determines the order in which children are streamed/created.</short>
<descr>
This method does nothing. It can be used to change the order in which child
components are streamed and created. This can be used by descendant classes
to optimize or correct the order in which child components are streamed.
</descr>
<seealso>
<link id="TComponent.ReadState"/>
</seealso>
</element>

<element name="TComponent.SetParentComponent">  <!-- Procedure -->
<short>Set the parent component.</short>
<descr>
<var>SetParentComponent</var> does nothing, but is called by the streaming
system to set the parent component of the current component. This method
can be overridden by descendant components to set the parent component of
the current component.
</descr>
<seealso>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.Updating">  <!-- Procedure -->
<short>Sets the state to <var>csUpdating</var></short>
<descr>
<p>
<var>Updating</var> includes <var>csUpdating</var> in the <link
id="TComponent.ComponentState">ComponentState</link> property of the
component.
</p>
<p>
Normally, an application programmer should not call this method directly, it
is called automatically by the streaming system.
</p>
</descr>
<seealso>
<link id="TComponent.Updated">Updated</link>
<link id="TComponent.ComponentState">ComponentState</link>
</seealso>
</element>

<element name="TComponent.Updated">  <!-- Procedure -->
<short>Ends the <var>csUpdating</var> state.</short>
<descr>
<p>
<var>Updated</var> excludes <var>csUpdating</var> from the <link
id="TComponent.ComponentState">ComponentState</link> property of the
component.
</p>
<p>
Normally, an application programmer should not call this method directly, it
is called automatically by the streaming system.
</p>
</descr>
<seealso>
<link id="TComponent.Updating">Updating</link>
<link id="TComponent.ComponentState">ComponentState</link>
</seealso>
</element>

<element name="TComponent.UpdateRegistry">  <!-- Procedure -->
<short>For compatibilty only.</short>
<descr>
This method does nothing, and is provided for compatibility only.
</descr>
<seealso>
</seealso>
</element>

<element name="TComponent.ValidateRename">  <!-- Procedure -->
<short>Called when a name change must be validated</short>
<descr>
<var>ValidateRename</var> checks whether <var>NewName</var> is a valid 
replacement for <var>CurName</var> for component <var>AComponent</var>.
Two owned components of a component can not have the same name. 
If a child component with the same name is found, then an exception 
is raised.
</descr>
<seealso>
<link id="TComponent.SetName">SetName</link>
<link id="TComponent.Name">Name</link>
</seealso>
</element>

<element name="TComponent.ValidateContainer">  <!-- Procedure -->
<short>??</short>
<descr>
<var>ValidateContainer</var> is provided for compatibility only. 
It doesn't do anything in Free Pascal.
</descr>
</element>

<element name="TComponent.ValidateInsert">  <!-- Procedure -->
<short>Called when an insert must be validated.</short>
<descr>
<p>
<var>ValidateInsert</var> should be implemented by descendant components to
see whether the <var>AComponent</var> component may be inserted in the list
of owned components. 
</p>
<p>
This procedure does nothing in the <var>TComponent</var> implementation, it
should be overridden by descendant components.
</p>
</descr>

<seealso>
<link id="TComponent.Insert">Insert</link>
</seealso>
</element>

<element name="TComponent.WriteState">  <!-- Procedure -->
<short>Writes the component to a stream.</short>
<descr>
<p>
<var>WriteState</var> writes the component's current state to a stream 
through the <link id="TWriter">writer</link> object <var>writer</var>. 
Values for all published properties of the component can be written to 
the stream. Normally there is no need to call <var>WriteState</var> directly. 
The streaming system calls  <var>WriteState</var> itself. 
</p>
<p>
The <link id="TComponent"/> implementation of <var>WriteState</var> simply
calls <link id="TWriter.WriteData"/>. Descendant classes can, however, 
override  <var>WriteState</var>to provide additional processing of stream 
data.
</p>
</descr>
<seealso>
<link id="TComponent.ReadState">ReadState</link>
<link id="TStream.WriteComponent"/>
<link id="TWriter.WriteData"/>
</seealso>
</element>

<element name="TComponent.Create">  <!-- Constructor -->
<short>Creates a new instance of the component.</short>
<descr>
<var>Create</var> creates a new instance of a <var>TComponent</var> class.
If <var>AOwner</var> is not <var>Nil</var>, the new component attempts to 
insert itself in the list of owned components of the owner.
</descr>
<seealso>
<link id="TComponent.Insert">Insert</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.SetSubComponent"> 
<short>Sets the <var>csSubComponent</var> style.</short>
<descr>
<var>SetSubComponent</var> includes <var>csSubComponent</var> in the
<link id="TComponent.ComponentStyle">ComponentStyle</link> property
if <var>ASubComponent</var> is <var>True</var>, and 
excludes it again if <var>ASubComponent</var> is <var>False</var>.
</descr>
<seealso>
<link id="TComponent.ComponentStyle"/>
</seealso>
</element>

<element name="TComponent.Destroy">  <!-- Destructor -->
<short>Destroys the instance of the component.</short>
<descr>
<var>Destroy</var> sends a <var>opRemove</var> notification to all components 
in the free-notification list. After that, all owned components are
destroyed by calling <link id="TComponent.DestroyComponents">DestroyComponents</link> 
(and hence removed from the list of owned components). When this
is done, the component removes itself from its owner's child component list.
After that, the parent's destroy method is called.
</descr>
<seealso>
<link id="TComponent.Notification">Notification</link>
<link id="TComponent.Owner">Owner</link>
<link id="TComponent.DestroyComponents">DestroyComponents</link>
<link id="TComponent.Components">Components</link>
</seealso>
</element>

<element name="TComponent.DestroyComponents">  <!-- Procedure -->
<short>Destroy child components.</short>
<descr>
<p>
<var>DestroyComponents</var> calls the destructor of all owned components,
till no more components are left in the <link id="TComponent.Components">Components</link> array.
</p>
<p>
Calling the destructor of an owned component has as the effect that the
component will remove itself from the list of owned components, if nothing
has disrupted the sequence of destructors.
</p>
</descr>
<errors> 
If an overridden 'destroy' method does not call it's intherited 
destructor or raises an exception, it's <link id="TComponent.Destroy"/> 
destructor will not be called, which may result in an endless loop.
</errors>
<seealso>
<link id="TComponent.Destroy">Destroy</link>
<link id="TComponent.Components">Components</link>
</seealso>
</element>

<element name="TComponent.Destroying">  <!-- Procedure -->
<short>Called when the component is being destroyed</short>
<descr>
<p>
<var>Destroying</var> sets the <var>csDestroying</var> flag in the
component's <link id="TComponent.State">state</link> property, and does the
same for all owned components.
</p>
<p>
It is not necessary to call <var>Destroying</var> directly, the destructor <link
id="TComponent.Destroy">Destroy</link> does this automatically.
</p>
</descr>
<seealso>
<link id="TComponent.State">State</link>
<link id="TComponent.Destroy">Destroy</link>
</seealso>
</element>

<element name="TComponent.FindComponent">  <!-- Function -->
<short>Finds and returns the named component in the owned components.</short>
<descr>
<var>FindComponent</var> searches the component with name <var>AName</var>
in the list of owned components. If <var>AName</var> is empty, then
<var>Nil</var> is returned.
</descr>
<seealso>
<link id="TComponent.Components">Components</link>
<link id="TComponent.Name">Name</link>
</seealso>
</element>

<element name="TComponent.FreeNotification">  <!-- Procedure -->
<short>Ask the component to notify called when it is being destroyed.</short>
<descr>
<var>FreeNotification</var> inserts <var>AComponent</var> in the
freenotification list. When the component is destroyed, the <link
id="TComponent.Notification">Notification</link> method is called for all
components in the freenotification list.
</descr>
<seealso>
<link id="TComponent.Components">Components</link>
<link id="TComponent.Notification">Notification</link>
<link id="TComponent.RemoveFreeNotification"/>
</seealso>
</element>

<element name="TComponent.FreeOnRelease">  <!-- Procedure -->
<short>Part of the <var>IVCLComObject</var> interface.</short>
<descr>
Provided for Delphi compatibility, but is not yet implemented.
</descr>
</element>

<element name="TComponent.GetParentComponent">  <!-- Function -->
<short>Returns the parent component.</short>
<descr>
<var>GetParentComponent</var> can be implemented to return the parent
component of this component. The implementation of this method in
<var>TComponent</var> always returns <var>Nil</var>. Descendant classes must
override this method to return the visual parent of the component.
</descr>
<seealso>
<link id="TComponent.HasParent">HasParent</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.HasParent">  <!-- Function -->
<short>Does the component have a parent ?</short>
<descr>
<var>HasParent</var> can be implemented to return whether the parent of the
component exists. The implementation of this method in TComponent always
returns <var>False</var>, and should be overridden by descendant classes to
return <var>True</var> when a parent is available. If <var>HasParent</var>
returns <var>True</var>, then <link
id="TComponent.GetParentComponent">GetParentComponent</link> will return the
parent component.
</descr>
<seealso>
<link id="TComponent.HasParent">HasParent</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.InsertComponent">  <!-- Procedure -->
<short>Insert the given component in the list of owned components.</short>
<descr>
<var>InsertComponent</var> attempts to insert <var>AComponent</var> in the
list with owned components. It first calls <link
id="TComponent">ValidateComponent</link> to see whether the component can be
inserted. It then checks whether there are no name conflicts by calling
<link id="TComponent.ValidateRename">ValidateRename</link>. If neither of
these checks have raised an exception the component is inserted, and
notified of the insert.
</descr>
<seealso>
<link id="TComponent.RemoveComponent">RemoveComponent</link>
<link id="TComponent.Insert">Insert</link>
<link id="TComponent.ValidateContainer">ValidateContainer</link>
<link id="TComponent.ValidateRename">ValidateRename</link>
<link id="TComponent.Notification">Notification</link>
</seealso>
</element>

<element name="TComponent.RemoveComponent">  <!-- Procedure -->
<short>Remove the given component from the list of owned components.</short>
<descr>
<var>RemoveComponent</var> will send an <var>opRemove</var> notification to
<var>AComponent</var> and will then proceed to remove <var>AComponent</var> 
from the list of owned components. 
</descr>
<seealso>
<link id="TComponent.InsertComponent">InsertComponent</link>
<link id="TComponent.Remove">Remove</link>
<link id="TComponent.ValidateRename">ValidateRename</link>
<link id="TComponent.Notification">Notification</link>
</seealso>
</element>

<element name="TComponent.SafeCallException">  <!-- Function -->
<short>Part of the <var>IVCLComObject</var> Interface.</short>
<descr>
Provided for Delphi compatibility, but not implemented.
</descr>
<seealso>
</seealso>
</element>

<element name="TComponent.Components">  <!-- Property -->
<short>Indexed list (zero-based) of all owned components.</short>
<descr>
<var>Components</var> provides indexed access to the list of owned
components. <var>Index</var> can range from 0 to <link
id="TComponent.ComponentCount">ComponentCount-1</link>.
</descr>
<seealso>
<link id="TComponent.ComponentCount">ComponentCount</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.ComponentCount">  <!-- Property -->
<short>Count of owned components</short>
<descr>
<var>ComponentCount</var> returns the number of components that the current
component owns. It can be used to determine the valid index range in the
<link id="TComponent.Components">Component</link> array.
</descr>
<seealso>
<link id="TComponent.Components">Components</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.ComponentIndex">  <!-- Property -->
<short>Index of component in it's owner's list.</short>
<descr>
<var>ComponentIndex</var> is the index of the current component in its
owner's list of components. If the component has no owner, the value of this
property is -1.
</descr>
<seealso>
<link id="TComponent.Components">Components</link>
<link id="TComponent.ComponentCount">ComponentCount</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.ComponentState">  <!-- Property -->
<short>Current component's state.</short>
<descr>
<p>
<var>ComponentState</var> indicates the current state of the component. It
is a set of flags which indicate the various stages in the lifetime of a
component. The following values can occur in this set:
</p>
<table>
<caption>Component states</caption>
<th><td>Flag</td><td>Meaning</td></th>
<tr><td>csLoading</td><td>The component is being loaded from stream</td></tr>
<tr><td>csReading</td><td>Component properties are being read from stream.</td></tr>
<tr><td>csWriting</td><td>Component properties are weing written to stream.</td></tr>
<tr><td>csDestroying</td><td>The component or one of it's owners is being destoyed.</td></tr>
<tr><td>csAncestor</td><td>The component is being streamed as part of a frame</td></tr>
<tr><td>csUpdating</td><td>The component is being updated</td></tr>
<tr><td>csFixups</td><td>References to other components are being resolved</td></tr>
<tr><td>csFreeNotification</td><td>The component has freenotifications.</td></tr>
<tr><td>csInline</td><td>The component is being loaded as part of a frame</td></tr>
<tr><td>csDesignInstance</td><td>? not used.</td></tr>
</table>
<p>
The component state is set by various actions such as reading it from stream,
destroying it etc.
</p>
</descr>
<seealso>
<link id="TComponent.SetAncestor">SetAncestor</link>
<link id="TComponent.SetDesigning">SetDesigning</link>
<link id="TComponent.SetInline">SetInline</link>
<link id="TComponent.SetDesignInstance">SetDesignInstance</link>
<link id="TComponent.Updating">Updating</link>
<link id="TComponent.Updated">Updated</link>
<link id="TComponent.Loaded">Loaded</link>
</seealso>
</element>

<element name="TComponent.ComponentStyle">  <!-- Property -->
<short>Current component's style.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="TComponent.DesignInfo">  <!-- Property -->
<short>Information for IDE designer.</short>
<descr>
<var>DesignInformation</var> can be used by an IDE to store design
information in the component. It should not be used by an application
programmer. 
</descr>
<seealso>
<link id="TComponent.Tag">Tag</link>
</seealso>
</element>

<element name="TComponent.Owner">  <!-- Property -->
<short>Owner of this component.</short>
<descr>
<var>Owner</var> returns the owner of this component. The owner cannot be
set except by explicitly inserting the component in another component's
owned components list using that component's <link
id="TComponent.InsertComponent">InsertComponent</link> method, or by
removing the component from it's owner's owned component list using the
<link id="TComponent.RemoveComponent">RemoveComponent</link> method.
</descr>
<seealso>
<link id="TComponent.Components">Components</link>
<link id="TComponent.InsertComponent">InsertComponent</link>
<link id="TComponent.RemoveComponent">RemoveComponent</link>
</seealso>
</element>

<element name="TComponent.VCLComObject">  <!-- Property -->
<short>Not implemented.</short>
<descr>
<var>VCLComObject</var> is not yet implemented in Free Pascal.
</descr>
</element>

<element name="TComponent.Name">  <!-- Property -->
<short>Name of the component.</short>
<descr>
<p>
<var>Name</var> is the name of the component. This name should be a valid
identifier, i.e. must start with a letter or underscore, and can contain only letters,
numbers and the underscore character. When attempting to set the name of a
component, the name will be checked for validity. Furthermore, when a
component is owned by another component, the name must be either empty
or must be unique among the child component names.
</p>
<p>
By "letters", 7-bit letters are meant.
</p>
</descr>
<errors>
Attempting to set the name to an invalid value will result in an exception
being raised.
</errors>
<seealso>
<link id="TComponent.ValidateRename">ValidateRename</link>
<link id="TComponent.Owner">Owner</link>
</seealso>
</element>

<element name="TComponent.Tag">  <!-- Property -->
<short>Tag value of the component.</short>
<descr>
<var>Tag</var> can be used to store an integer value in the component. This
value is streamed together with all other published properties. It can be
used for instance to quickly identify a component in an event handler.
</descr>
<seealso>
<link id="TComponent.Name">Name</link>
</seealso>
</element>

<!--
  *********************************************************************
  TBasicAction
  *********************************************************************
-->

<element name="TBasicAction">
<short>Abstract base class for all Actions.</short>
<descr>
<p>
<var>TBasicAction</var> implements a basic action class from which all
actions are derived. It introduces all basic methods of an action, and
implements functionality to maintain a list of clients, i.e. components that
are connected with this action.
</p>
<p>
Do not create instances of <var>TBasicAction</var>. Instead, create a
descendant class and create an instance of this class instead.
</p>
</descr>
<seealso>
<link id="TBasicActionLink"/>
<link id="TComponent"/>
</seealso>
</element>


<element name="TBasicAction.FClients">
<short>List with components linked to this action.
</short>
<descr>
<var>FClients</var> is a list of <link id="TBasicActionLink"/> classes which
represent links to various components that are connected to this action.
The elements in this list should not be manipulated directly, but should be
managed with the 
<link id="TBasicAction.RegisterChanges">RegisterChanges</link> and 
<link id="TBasicAction.UnRegisterChanges">UnRegisterChanges</link> methods.
</descr>
<seealso>
<link id="TBasicAction.RegisterChanges">RegisterChanges</link>
<link id="TBasicAction.UnRegisterChanges">UnRegisterChanges</link>
<link id="TBasicActionLink"/>
</seealso>
</element>

<element name="TBasicAction.Change">
<short>Calls the <link id="TBasicAction.OnChange">OnChange</link> handler.</short>
<descr>
<p>
<var>Change</var> calls the <link id="TBasicAction.OnChange">OnChange</link>
handler if one is assigned.
</p>
<p>
Application programmers should not call <var>Change</var> directly.
It is called automatically if a property of an action component changes.
</p>
<p>
Descendant classes of <var>TBasicAction</var> should call explicitly call
<var>Change</var> if one of their properties that affect client controls
changes its value.
</p>
</descr>
</element>

<element name="TBasicAction.SetOnExecute">
<short>Assigns an <link id="TBasicAction.OnExecute">OnExecute</link> event
handler</short>
<descr>
<var>SetOnExecute</var> sets the 
<link id="TBasicAction.OnExecute">OnExecute</link> handler of the component.
It also propagates this event to all client controls, and finally triggers
the <link id="TBasicAction.OnChange">OnChange</link> event.
</descr>
<seealso>
<link id="TBasicAction.OnExecute">OnExecute</link>
<link id="TBasicAction.OnChange">OnChange</link>
</seealso>
</element>

<element name="TBasicAction.OnChange">
<short>Occurs when one of the action's properties changes.
</short>
<descr>
<p>
<var>OnChange</var> is the event that is triggered when one of the
action's properties changes. This event should be used by client 
controls or descendant classes to respond to these changes in the properties
of the action.
</p>
<p>
Application programmers should never use the <var>OnChange</var> event
directly.
</p>
</descr>
</element>

<element name="TBasicAction.Create">
<short>Creates a new instance of a <link id="TBasicAction"/> class.
</short>
<descr>
<p>
<var>Create</var> calls the inherited constructor, and then initializes the 
list of clients controls (or action lists).
</p>
<p>
Under normal circumstances it should not be necessary to create a
<var>TBasicAction</var> descendant manually, actions are created in an IDE.
</p>
</descr>
<seealso>
<link id="TBasicAction.Destroy">Destroy</link>
<link id="TBasicAction.AssignClient">AssignClient</link>
</seealso>
</element>

<element name="TBasicAction.Destroy">
<short>Destroys the action.</short>
<descr>
<p>
<var>Destroy</var> cleans up the list of client controls and then calls the
inherited destructor.
</p>
<p>
An application programmer should not call <var>Destroy</var> directly;
Instead <var>Free</var> should be called, if it needs to be called at all.
Normally the controlling class (e.g. a TActionList) will destroy the action.
</p>
</descr>
</element>

<element name="TBasicAction.HandlesTarget">
<short>Determines whether <var>Target</var> can be handled by this action
</short>
<descr>
<p>
<var>HandlesTarget</var> returns <var>True</var> if <var>Target</var> is 
a valid client for this action and if so, if it is in a suitable state to
execute the action. An application programmer should never need to call
<var>HandlesTarget</var> directly, it will be called by the action itself
when needed.
</p>
<p>
In <var>TBasicAction</var> this method is empty; descendant classes should
override this method to implement appropriate checks.
</p>
</descr>
<seealso>
<link id="TBasicAction.UpdateTarget">UpdateTarget</link>
<link id="TBasicAction.ExecuteTarget">ExecuteTarget</link>
</seealso>
</element>

<element name="TBasicAction.UpdateTarget">
<short>Notify client controls when the action updates itself.</short>
<descr>
<p>
<var>UpdateTarget</var> should update the client control specified by
<var>Target</var> when the action updates itself. 
In <var>TBasicAction</var>, the implementation of <var>UpdateTarget</var> 
is empty. Descendant classes should override and implement 
<var>UpdateTarget</var> to actually update the <var>Target</var> object.
</p>
<p>
An application programmer should never need to call
<var>HandlesTarget</var> directly, it will be called by the action itself
when needed.
</p>
</descr>
<seealso>
<link id="TBasicAction.HandlesTarget">HandlesTarget</link>
<link id="TBasicAction.ExecuteTarget">ExecuteTarget</link>
</seealso>
</element>

<element name="TBasicAction.ExecuteTarget">
<short>Executes the action on the <var>Target</var> object</short>
<descr>
<p>
<var>ExecuteTarget</var> performs the action on the <var>Target</var>
object. In <var>TBasicAction</var> this method does nothing. Descendant
classes should implement the action to be performed. For instance an action
to post data in a dataset could call the <var>Post</var> method of the
dataset.
</p>
<p>
An application programmer should never call <var>ExecuteTarget</var>
directly.
</p>
</descr>
<seealso>
<link id="TBasicAction.HandlesTarget">HandlesTarget</link>
<link id="TBasicAction.ExecuteTarget">UpdateTarget</link>
<link id="TBasicAction.Execute">Execute</link>
</seealso>
</element>

<element name="TBasicAction.Execute">
<short>Triggers the <link id="TBasicAction.OnExecute">OnExecute</link> event</short>
<descr>
<var>Execute</var> triggers the <var>OnExecute</var> event, if one is
assigned. It returns <var>True</var> if the event handler was called,
<var>False</var> otherwise.
</descr>
</element>

<element name="TBasicAction.RegisterChanges">
<short>Registers a new client with the action.</short>
<descr>
<var>RegisterChanges</var> adds <var>Value</var> to the list of clients. 
</descr>
<seealso>
<link id="TBasicAction.UnregisterChanges">UnregisterChanges</link>
</seealso>
</element>

<element name="TBasicAction.UnregisterChanges">
<short>Unregisters a client from the list of clients</short>
<descr>
<var>UnregisterChanges</var> removes <var>Value</var> from the list of clients.
This is called for instance when the action is destroyed, or when the client
is assigned a new action.
</descr>
<seealso>
<link id="TBasicAction.UnregisterChanges">UnregisterChanges</link>
<link id="TBasicAction.Destroy">Destroy</link>
</seealso>
</element>

<element name="TBasicAction.Update">
<short>Triggers the <link id="TBasicAction.OnUpdate">OnUpdate</link> event</short>
<descr>
<p>
<var>Update</var> triggers the <var>OnUpdate</var> event, if one is
assigned. It returns <var>True</var> if the event was triggered, or
<var>False</var> if no event was assigned.
</p>
<p>
Application programmers should never run <var>Update</var> directly. The
<var>Update</var> method is called automatically by the action mechanism;
Normally this is in the Idle time of an application. An application
programmer should assign the <link id="TBasicAction.OnUpdate">OnUpdate</link>
event, and perform any checks in that handler.
</p>
</descr>
<seealso>
<link id="TBasicAction.OnUpdate">OnUpdate</link>
<link id="TBasicAction.Execute">Execute</link>
<link id="TBAsicAction.UpdateTarget">UpdateTarget</link>
</seealso>
</element>

<element name="TBasicAction.ActionComponent">
<short>Returns the component that initiated the action.</short>
<descr>
<var>ActionComponent</var> is set to the component that caused the action to
execute, e.g. a toolbutton or a menu item. 
The property is set just before the action executes, and is reset to nil 
after the action was executed.
</descr>
<seealso>
<link id="TBasicAction.Execute">Execute</link>
<link id="TBasicAction.OnExecute">OnExecute</link>
</seealso>
</element>

<element name="TBasicAction.OnExecute">
<short>Event triggered when the action executes.</short>
<descr>
<p>
<var>OnExecute</var> is the event triggered when the action is activated
(executed). The event is triggered e.g. when the user clicks e.g. on a menu
item or a button associated to the action. The application programmer 
should provide a <var>OnExecute</var> event handler to execute whatever code
is necessary when the button is pressed or the menu item is chosen.
</p>
<p>
Note that assigning an <var>OnExecute</var> handler will result in the
<link id="TBasicAction.Execute">Execute</link> method returning a
<var>True</var> value. Predefined actions (such as dataset actions)
will check the result of <var>Execute</var> and will not perform their 
normal task if the <var>OnExecute</var> handler was called.
</p>
</descr>
<seealso>
<link id="TBasicAction.Execute">Execute</link>
<link id="TBasicAction.OnUpdate">OnUpdate</link>
</seealso>
</element>

<element name="TBasicAction.OnUpdate">
<short>Event trigged when the application is idle.</short>
<descr>
<var>OnUpdate</var> is the event triggered when the application is idle, and
the action is being updated. The <var>OnUpdate</var> event can be used to
set the state of the action, for instance disable it if the action cannot be
executed at this point in time.
</descr>
<seealso>
<link id="TBasicAction.Update">Update</link>
<link id="TBasicAction.OnExecute">OnExecute</link>
</seealso>
</element>

<!--
  *********************************************************************
  TBasicActionLink
  *********************************************************************
-->

<element name="TBasicActionLink">
<short>Link between actions and action clients (e.g. controls)</short>
<descr>
<p>
<var>TBasicActionLink</var> links an Action to its clients. With each client
for an action, a <var>TBasicActionLink</var> class is instantiated to handle
the communication between the action and the client. It passes events
between the action and its clients, and thus presents the action with a
uniform interface to the clients.
</p>
<p>An application programmer should never use a <var>TBasicActionLink</var>
instance directly; They are created automatically when an action is
associated with a component. Component programmers should create specialized
descendants of <var>TBasicActionLink</var> which communicate changes in the
action to the component.
</p>
</descr>
<seealso>
<link id="TBasicAction"/>
</seealso>
</element>

<element name="TBasicActionLink.FAction">
<short>The action with which this link is associated</short>
<descr>
<var>FAction</var> contains a reference to the action with which this link
is associated. It should never be manipulated directly. It will be set
automatically by the <link id="TBasicActionLink.SetAction">SetAction</link> write method
for the <link id="TBasicActionLink.Action">Action</link> property.
</descr>
<seealso>
<link id="TBasicActionLink.SetAction">SetAction</link>
<link id="TBasicActionLink.Action">Action</link>
</seealso>
</element>

<element name="TBasicActionLink.AssignClient">
<short>Assigns a control (client) to the action link.</short>
<descr>
<var>AssignClient</var> assigns a control to the actionlink and hence to the
action. Descendant classes can override <var>AssignClient</var> to check
whether the new client is a suitable client for this action.
</descr>
<seealso>
<link id="TBasicActionLink.Action">Action</link>
</seealso>
</element>

<element name="TBasicActionLink.Change">
<short>Executed whenever the Action is changed.</short>
<descr>
<p>
<var>Change</var> is executed whenever the action changes. 
It executes the <link id="TBasicActionLink.OnChange">OnChange</link>
handler, if one is assigned.
</p>
<p>
Component programmers may decide to override the <var>Change</var>
procedure in descendant classes to perform aditional actions when 
the properties of the action changes.
</p>
</descr>
<seealso>
<link id="TBasicActionLink.OnChange">OnChange</link>
<link id="TBasicAction.Change"/>
</seealso>
</element>

<element name="TBasicActionLink.IsOnExecuteLinked">
<short>Returns whether the client has it's OnExecute property linked.</short>
<descr>
<var>IsOnExecuteLinked</var> always returns true in <var>TBasicActionLink</var>. 
Descendant classes can override this method to provide a different result.
</descr>
<link id="TBasicActionLink.OnExecute">OnExecute</link>
</element>

<element name="TBasicActionLink.SetAction">
<short>Sets the action with which the actionlink is associated.</short>
<descr>
<var>SetAction</var> is the write handler for the <link
id="TBasicActionLink.Action">Action</link> property. It sets the
<var>Action</var> property to it's new value, after unregistering itself 
with the old action, if there was one.
</descr>
<seealso>
<link id="TBasicActionLink.Action">Action</link>
<link id="TBasicAction"/>
</seealso>
</element>

<element name="TBasicActionLink.SetOnExecute">
<short>Assigns the <link id="TBasicAction.OnExecute">OnExecute</link> handler
to the client</short>
<descr>
<var>SetOnExecute</var> must be overridden by descendant classes to pass the
<var>OnExecute</var> handler of the associated action to the client control.
It will attach the <var>OnExecute</var> handler to whatever handler is
appropriate for the client control.
</descr>
<seealso>
<link id="TBasicAction.OnExecute">OnExecute</link>
<link id="TBasicAction"/>
</seealso>
</element>

<element name="TBasicActionLink.Create">
<short>Creates a new instance of the TBasicActionLink class</short>
<descr>
<p>
<var>Create</var> creates a new instance of a <var>TBasicActionLink</var>
and assigns <var>AClient</var> as the client of the link.
</p>
<p>
Application programmers should never instantiate <var>TBasicActionLink</var>
classes directly. An instance is created automatically when an action is
assigned to a control (client).
</p>
<p>
Component programmers can override the create constructor to initialize
further properties. 
</p>
</descr>
<seealso>
<link id="TBasicActionLink.Destroy">Destroy</link>
</seealso>
</element>

<element name="TBasicActionLink.Destroy">
<short>Destroys the TBasicActionLink instance.</short>
<descr>
<p>
<var>Destroy</var> unregisters the <var>TBasicActionLink</var> with the
action, and then calls the inherited destructor.
</p>
<p>
Application programmers should never call <var>Destroy</var> directly. If a
link should be destroyed at all, the <var>Free</var> method should be called
instead.
</p>
</descr>
<seealso>
<link id="TBasicActionLink.Create">Create</link>
</seealso>
</element>

<element name="TBasicActionLink.Execute">
<short>Calls the action's Execute method.</short>
<descr>
<p>
<var>Execute</var> sets the <link
id="TBasicAction.ActionComponent">ActionComponent</link> 
property of the associated <link id="TBasicActionLink.Action">Action</link> to 
<var>AComponent</var> and then calls the Action's  <link
id="TBasicAction.Execute">execute</link> method. After the action has 
executed, the <var>ActionComponent</var> property is cleared again.
</p>
<p>
The return value of the function is the return value of the Action's execute
method.
</p>
<p>
Application programmers should never call <var>Execute</var> directly. This
method will be called automatically when the associated control is
activated. (e.g. a button is clicked on)
</p>
<p>
Component programmers should call <var>Execute</var> whenever the action
should be activated.
</p>
</descr>
<seealso>
<link id="TBasicActionLink.Action">Action</link>
<link id="TBasicAction.ActionComponent"/>
<link id="TBasicAction.Execute"/>
<link id="TBasicAction.onExecute"/>
</seealso>
</element>

<element name="TBasicActionLink.Update">
<short>Calls the action's Update method</short>
<descr>
<p>
<var>Update</var> calls the associated Action's <link
id="TBasicAction.Update">Update</link> methoda.
</p>
<p>
Component programmers can override the <var>Update</var> method to provide
additional processing when the <var>Update</var> method occurs.
</p>
</descr>
</element>

<element name="TBasicActionLink.Action">
<short>The action to which the link was assigned.</short>
<descr>
<var>Action</var> represents the <link id="TBasicAction">Action</link> which
was assigned to the client. Setting this property will unregister the client
at the old action (if one existed) and registers the client at the new
action.
</descr>
<seealso>
<link id="TBasicAction"/>
</seealso>
</element>

<element name="TBasicActionLink.OnChange">
<short>Event handler triggered when the action's properties change</short>
<descr>
<p>
<var>OnChange</var> is the event triggered when the action's properties
change.
</p>
<p>
Application programmers should never need to assign this event. Component
programmers can assign this event to have a client control reflect any
changes in an Action's properties.
</p>
</descr>
<seealso>
<link id="TBasicActionLink.Change">Change</link>
<link id="TBasicAction.Change"/>
</seealso>
</element>

<!--
  *********************************************************************
  Various calls
  *********************************************************************
-->


<element name="TActiveXRegType">  <!-- Enumeration type -->
<short>Used when registering ActveX component types.</short>
<descr>
This type is provided for compatibility only, and is currently not used in
Free Pascal.
</descr>
<seealso>
</seealso>
</element>

<element name="TActiveXRegType.axrComponentOnly">  <!-- Enumeration value -->
<short></short>
</element>

<element name="TActiveXRegType.axrIncludeDescendants">  <!-- Enumeration value -->
<short></short>
</element>

<element name="RegisterComponentsProc">  <!-- Variable -->
<short>Callback procedure used when handling component registration.</short>
<descr>
<var>RegisterComponentsProc</var> can be set by an IDE to be notified when
new components are being registered. Application programmers should never
have to set <var>RegisterComponentsProc</var>
</descr>
<seealso>
<link id="RegisterNoIconProc"/>
<link id="RegisterComponents"/>
</seealso>
</element>

<element name="RegisterNoIconProc">  <!-- Variable -->
<short>Callback procedure used when handling iconless component registration.</short>
<descr>
<var>RegisterNoIconProc</var> can be set by an IDE to be notified when
new components are being registered, and which do not need an Icon in the
component palette. Application programmers should never
have to set <var>RegisterComponentsProc</var>
</descr>
<seealso>
</seealso>
</element>

<element name="Point">  <!-- Function -->
<short>Returns a <var>TPoint</var> record with the given coordinates.</short>
<descr>
<var>Point</var> returns a <link id="TPoint"/> record with the given
coordinates <var>AX</var> and <var>AY</var> filled in.
</descr>
<seealso>
<link id="TPoint"/>
<link id="SmallPoint"/>
<link id="Rect"/>
<link id="Bounds"/>
</seealso>
</element>

<element name="SmallPoint">  <!-- Function -->
<short>Returns a <var>TSmallPoint</var> record with the given coordinates.</short>
<descr>
<var>SmallPoint</var> returns a <link id="TSmallPoint"/> record with the given
coordinates <var>AX</var> and <var>AY</var> filled in.
</descr>
<seealso>
<link id="TSmallPoint"/>
<link id="Point"/>
<link id="Rect"/>
<link id="Bounds"/>
</seealso>
</element>

<element name="Rect">  <!-- Function -->
<short>Returns a <var>TRect</var> record with the given coordinates.</short>
<descr>
<p>
<var>Rect</var> returns a <link id="TRect"/> record with the given
top-left <var>(ALeft,ATop)</var> and bottom-right <var>(ABottom,ARight)</var>
corners filled in.
</p>
<p>
No checking is done to see whether the coordinates are valid.
</p>
</descr>
<seealso>
<link id="TRect"/>
<link id="Point"/>
<link id="SmallPoint"/>
<link id="Bounds"/>
</seealso>
</element>

<element name="Bounds">  <!-- Function -->
<short>Returns a <var>TRect</var> structure with the bounding rect of the
given location and size.</short>
<descr>
<var>Bounds</var> returns a <link id="TRect"/> record with the given
origin <var>(ALeft,ATop)</var> and dimensions <var>(AWidth,AHeight)</var> 
filled in. The bottom-right corner is calculated by adding <var>AWidth</var>
to <var>ALeft</var> and <var>AHeight</var> to <var>ATop</var>. As a result,
a rectangle with width/height set to 0 is exactly 1 pixel.
</descr>
<seealso>
<link id="Rect"/>
</seealso>
</element>

<element name="RegisterClass">  <!-- Procedure -->
<short>Registers a class with the streaming system.</short>
<descr>
<var>RegisterClass</var> registers the class <var>AClass</var> in the
streaming system. After the class has been registered, it can be read from
a stream when a reference to this class is encountered.
</descr>
<seealso>
<link id="RegisterClasses"/>
<link id="RegisterClassAlias"/>
<link id="RegisterComponents"/>
<link id="UnregisterClass"/>
</seealso>
</element>

<element name="RegisterClasses">  <!-- Procedure -->
<short>Registers multiple classes with the streaming system.</short>
<descr>
<var>RegisterClasses</var> registers the specified classes <var>AClass</var> in the
streaming system. After the classes have been registered, they can be read from
a stream when a reference to this class is encountered.
</descr>
<seealso>
<link id="RegisterClass"/>
<link id="RegisterClassAlias"/>
<link id="RegisterComponents"/>
<link id="UnregisterClass"/>
</seealso>
</element>

<element name="RegisterClassAlias">  <!-- Procedure -->
<short>Registers a class alias with the streaming system.</short>
<descr>
<var>RegisterClassAlias</var> registers a class alias in the streaming
system. If a reference to a class <var>Alias</var> is encountered in a
stream, then an instance of the class <var>AClass</var> will be created 
instead by the streaming code.
</descr>
<seealso>
<link id="RegisterClass"/>
<link id="RegisterClasses"/>
<link id="RegisterComponents"/>
<link id="UnregisterClass"/>
</seealso>
</element>

<element name="UnRegisterClass">  <!-- Procedure -->
<short>Unregisters a class from the streaming system.</short>
<descr>
<var>UnregisterClass</var> removes the class <var>AClass</var> from the
class definitions in the streaming system.
</descr>
<seealso>
<link id="UnRegisterClasses"/>
<link id="UnRegisterModuleClasses"/>
<link id="RegisterClass"/>
</seealso>
</element>

<element name="UnRegisterClasses">  <!-- Procedure -->
<short>Unregisters multiple classes from the streaming system.</short>
<descr>
<var>UnregisterClasses</var> removes the classes in <var>AClasses</var> from the
class definitions in the streaming system.
</descr>
<link id="UnRegisterClass"/>
<link id="UnRegisterModuleClasses"/>
<link id="RegisterClasses"/>
<seealso>
</seealso>
</element>

<element name="UnRegisterModuleClasses">  <!-- Procedure -->
<short>Unregisters classes registered by module.</short>
<descr>
<var>UnRegisterModuleClasses</var> unregisters all classes which reside in 
the module <var>Module</var>. For each registered class, the definition
pointer is checked to see whether it resides in the module, and if it does,
the definition is removed.
</descr>
<seealso>
<link id="UnRegisterClass"/>
<link id="UnRegisterClasses"/>
<link id="RegisterClasses"/>
</seealso>
</element>

<element name="FindClass">  <!-- Function -->
<short>Returns the class pointer of a class with given name.</short>
<descr>
<p>
<var>FindClass</var> searches for the class named <var>ClassName</var>
in the list of registered classes and returns a class pointer to the
definition. If no class with the given name could be found, an exception is
raised.
</p>
<p>The <link id="GetClass"/> function does not raise an exception when it
does not find the class, but returns a <var>Nil</var> pointer instead.
</p>
</descr>
<seealso>
<link id="RegisterClass"/>
<link id="GetClass"/>
</seealso>
</element>

<element name="GetClass">  <!-- Function -->
<short>Returns the class pointer of a class with given name.</short>
<descr>
<p>
<var>GetClass</var> searches for the class named <var>ClassName</var>
in the list of registered classes and returns a class pointer to the
definition. If no class with the given name could be found, <var>Nil</var>
is returned.
</p>
<p>The <link id="FindClass"/> function will raise an exception if the 
does not find the class.
</p>
</descr>
<seealso>
<link id="RegisterClass"/>
<link id="GetClass"/>
</seealso>
</element>

<element name="RegisterComponents">  <!-- Procedure -->
<short>Registers components for the component palette.</short>
<descr>
<p>
<var>RegisterComponents</var> registers the component on the appropriate
component page. The component pages can be used by an IDE to display the
known components so an application programmer may pick and use the
components in his programs.
</p>
<p>
Registercomponents inserts the component class in the correct component
page. If the <var>RegisterComponentsProc</var> procedure is set, this is
called as well. Note that this behaviour is different from Delphi's
behaviour where an exception will be raised if the procedural variable is
not set.
</p>
</descr>
<seealso>
<link id="RegisterClass"/>
<link id="RegisterNoIcon"/>
</seealso>
</element>

<element name="RegisterNoIcon">  <!-- Procedure -->
<short>Registers components that have no icon on the component palette.</short>
<descr>
<var>RegisterNoIcon</var> performs the same function as <link
id="RegisterComponents"/> except that it calls <link
id="RegisterNoIconProc"/>
instead of <link id="RegisterComponentsProc"/>
</descr>
<seealso>
<link id="RegisterNoIconProc"/>
<link id="RegisterComponents"/>
</seealso>
</element>

<element name="RegisterNonActiveX">  <!-- Procedure -->
<short>Register non-activex component.</short>
<descr>
Not yet implemented in Free Pascal
</descr>
<seealso>
</seealso>
</element>

<element name="TIdentMapEntry">  <!-- Record type -->
<short>Record used when associating names with integer values.</short>
<descr>
<var>TIdentMapEntry</var> is used internally by the <link id="IdentToInt"/>
and <link id="IntToIdent"/> calls to store the mapping between the
identifiers and the integers they represent.
</descr>
<seealso>
<link id="IntToIdent"/>
<link id="IdentToInt"/>
</seealso>
</element>

<element name="TIdentMapEntry.Value">  <!-- Variable -->
<short>Integer value</short>
</element>

<element name="TIdentMapEntry.Name">  <!-- Variable -->
<short>Name of the integer value.</short>
</element>

<element name="TIdentToInt">  <!-- Function type -->
<short>Callback for converting identifiers to integers.</short>
<descr>
<p>
<var>TIdentToInt</var> is a callback used to look up identifiers 
(<var>Ident</var>) and return an integer value corresponding to this
identifier (<var>Int</var>). The callback should return <var>True</var> if a
value corresponding to integer <var>Ident</var> was found, <var>False</var>
if not.
</p>
<p>
A callback of type <var>TIdentToInt</var> should be specified when an
integer is registered using the <link id="RegisterIntegerConsts"/> call.
</p>
</descr>
<seealso>
<link id="RegisterIntegerConsts"/>
<link id="TIntToIdent"/>
</seealso>
</element>

<element name="TIntToIdent">  <!-- Function type -->
<short>Callback for converting integers to identifiers.</short>
<descr>
<p>
<var>TIdentToInt</var> is a callback used to look up integers 
(<var>Ident</var>) and return an identifier (<var>Ident</var>) 
that can be used to represent this integer value in an IDE.
The callback should return <var>True</var> if a value corresponding 
to integer <var>Ident</var> was found, <var>False</var> if not.
</p>
<p>
A callback of type <var>TIntToIdent</var> should be specified when an
integer is registered using the <link id="RegisterIntegerConsts"/> call.
</p>
</descr>
<seealso>
<link id="RegisterIntegerConsts"/>
<link id="TIdentToInt"/>
</seealso>
</element>

<element name="TFindGlobalComponent">  <!-- Function type -->
<short>Callback type to search for a component.</short>
<descr>
<p>
<var>TFindGlobalComponent</var> is a callback used to find a component in a
global scope. It is used when the streaming system needs to find a component
which is not part of the component which is currently being streamed. It
should return the component with name <var>Name</var>, or <var>Nil</var> if
none is found.
</p>
<p>
The variable <link id="FindGlobalComponent"/> is a callback of type
<var>TFindGlobalComponent</var>. It can be set by the IDE when an unknown
reference is found, to offer the designer to redirect the link to a new
component.
</p>
</descr>
<seealso>
<link id="FindGlobalComponent"/>
</seealso>
</element>

<element name="MainThreadID">  <!-- Variable -->
<short>ID of main thread. Unused at this point.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="FindGlobalComponent">  <!-- Variable -->
<short>Callback used when a component must be found.</short>
<descr>
<p>
<var>FindGlobalComponent</var> is a callback of type
<link id="TFindGlobalComponent"/>. It can be set by the IDE when an unknown
reference is found, to offer the user to redirect the link to a new
component.
</p>
<p>
It is a callback used to find a component in a
global scope. It is used when the streaming system needs to find a component
which is not part of the component which is currently being streamed. It
should return the component with name <var>Name</var>, or <var>Nil</var> if
none is found.
</p>
</descr>
<seealso>
<link id="TFindGlobalComponent"/>
</seealso>
</element>

<element name="RegisterIntegerConsts">  <!-- Procedure -->
<short>Registers some integer-to-identifier mappings.</short>
<descr>
<p>
<var>RegisterIntegerConsts</var> registers a pair of callbacks to be used
when an integer of type <var>IntegerType</var> must be mapped to an
identifier (using <var>IntToIdentFn</var>) or when an identifier must be
mapper to an integer (using <var>IdentToIntFn</var>). 
</p>
<p>
Component programmers can use <var>RegisterIntegerConsts</var> to associate
a series of identifier strings with integer values for a property. A
necessary condition is that the property should have a separate type
declared using the <var>type integer</var> syntax. If a type of integer is
defined in this way, an IDE can show symbolic names for the values of these 
properties.
</p>
<p>
The <var>IntegerType</var> should be a pointer to the type information of
the integer type. The <var>IntToIdentFn</var> and <var>IdentToIntFn</var>
are two callbacks that will be used when converting between the identifier
and integer value and vice versa. The functions <link id="IdentToInt"/>
and <link id="IntToIdent"/> can be used to implement these callback
functions.
</p>
</descr>
<seealso>
<link id="TIdentToInt"/>
<link id="TIntToIdent"/>
<link id="IdentToInt"/>
<link id="IntToIdent"/>
</seealso>
</element>

<element name="IdentToInt">  <!-- Function -->
<short>Looks up an integer value in a integer-to-identifier map list.</short>
<descr>
<var>IdentToInt</var> searches <var>Map</var> for an entry whose
<var>Name</var> field matches <var>Ident</var> and returns the corresponding
integer value in <var>Int</var>. If a match was found, the function returns
<var>True</var>, otherwise, <var>False</var> is returned.
</descr>
<seealso>
<link id="TIdentToInt"/>
<link id="TIntToIdent"/>
<link id="IntToIdent"/>
<link id="TIdentMapEntry"/>
</seealso>
</element>

<element name="IntToIdent">  <!-- Function -->
<short>Looks up an identifier for an integer value in a identifier-to-integer map list.</short>
<descr>
<var>IdentToInt</var> searches <var>Map</var> for an entry whose
<var>Value</var> field matches <var>Int</var> and returns the corresponding
identifier in <var>Ident</var>. If a match was found, the function returns
<var>True</var>, otherwise, <var>False</var> is returned.
</descr>
<seealso>
<link id="TIdentToInt"/>
<link id="TintToIdent"/>
<link id="IdentToInt"/>
<link id="TIdentMapEntry"/>
</seealso>
</element>

<element name="InitInheritedComponent">  <!-- Function -->
<short>Initializes a component descending from <var>RootAncestor</var></short>
<descr>
<p>
<var>InitInheritedComponent</var> should be called from a constructor to
read properties of the component <var>Instance</var> from the streaming
system. The <var>RootAncestor</var> class is the root class from which
<var>Instance</var> is a descendant. This must be one of
<var>TDatamodule</var>, <var>TCustomForm</var> or <var>TFrame</var>.
</p>
<p>
The function returns <var>True</var> if the properties were successfully
read from a stream or <var>False</var> if some error occurred.
</p>
</descr>
<seealso>
<link id="ReadComponentRes"/>
<link id="ReadComponentResEx"/>
<link id="ReadComponentResFile"/>
</seealso>
</element>

<element name="InitComponentRes">  <!-- Function -->
<short>Provided for Delphi compatibility only</short>
<descr>
This function is provided for Delphi compatibility. 
It always returns <var>false</var>.
</descr>
<seealso>
<link id="ReadComponentRes"/>
</seealso>
</element>

<element name="ReadComponentRes">  <!-- Function -->
<short>Read component properties from a resource in the current module</short>
<descr>
<var>ReadComponentRes</var> will read the component's properties from the
resource <var>ResName</var> in the current module (always program module).
It returns Nil if the resource was not found. It returns <var>Instance</var>
if the resource was found and successfully applied to the component.
</descr>
<errors>
The function may raise an exception if the stream contains wrong data.
</errors>
<seealso>
<link id="ReadComponentResEx"/>
</seealso>
</element>

<element name="ReadComponentResEx">  <!-- Function -->
<short>Read component properties from a resource in the specified module</short>
<descr>
<var>ReadComponentRes</var> will locate the resource <var>ResName</var> in
instance <var>HInstance</var> (the current program, normally).
It returns <var>Nil</var> if the resource was not found. 
It returns an instantiated component with all properties found in the
stream, applied. This requires that the component is registered using
registerclass.
</descr>
<errors>  
The function may raise an exception if the stream contains wrong data.
</errors> 
<seealso> 
<link id="ReadComponentRes"/>
</seealso>
</element>

<element name="ReadComponentResFile">  <!-- Function -->
<short>Read component properties from a specified resource file</short>
<descr>
<var>ReadComponentResFile</var> starts reading properties for
<var>Instance</var> from the file <var>FileName</var>. It creates a
filestream from <var>FileName</var> and then calls the <link
id="TStream.ReadComponentRes"/> method to read the state of the component from the
stream.
</descr>
<seealso>
<link id="TStream.ReadComponentRes"/>
<link id="WriteComponentResFile"/>
</seealso>
</element>

<element name="WriteComponentResFile">  <!-- Procedure -->
<short>Write component properties to a specified resource file</short>
<descr>
<var>WriteComponentResFile</var> starts writing properties of
<var>Instance</var> to the file <var>FileName</var>. It creates a
filestream from <var>FileName</var> and then calls <link
id="TStream.WriteComponentRes"/> method to write the state of 
the component to the stream.
</descr>
<seealso>
<link id="TStream.WriteComponentRes"/>
<link id="ReadComponentResFile"/>
</seealso>
</element>

<element name="GlobalFixupReferences">  <!-- Procedure -->
<short>Called to resolve unresolved references after forms are loaded.</short>
<descr>
<var>GlobalFixupReferences</var> runs over the list of unresolved references
and tries to resolve them. This routine should under normal circumstances
not be called in an application programmer's code. It is called
automatically by the streaming system after a component has been
instantiated and its properties read from a stream. It will attempt to
resolve references to other global components. 
</descr>
<seealso>
<link id="GetFixupReferenceNames"/>
<link id="GetFixupInstanceNames"/>
</seealso>
</element>

<element name="GetFixupReferenceNames">  <!-- Procedure -->
<short>Returns the names of elements that need to be resolved for the
<var>root</var> component.</short>
<descr>
<var>GetFixupReferenceNames</var> examines the list of unresolved references
and returns the names of properties that must be resolved for the
component <var>Root</var> in the list <var>Names</var>. The list is not
cleared prior to filling it.
</descr>
<seealso>
<link id="GetFixupInstanceNames"/>
<link id="GlobalFixupReferences"/>
</seealso>
</element>

<element name="GetFixupInstanceNames">  <!-- Procedure -->
<short>Returns the names of elements that need to be resolved for the
<var>root</var> component, whose reference contains <var>ReferenceRootName</var></short>
<descr>
<var>GetFixupInstanceNames</var> examines the list of unresolved references
and returns the names of classes that contain unresolved references to the
<var>Root</var> component in the list <var>Names</var>. The list is not
cleared prior to filling it.
</descr>
<seealso>
<link id="GetFixupReferenceNames"/>
<link id="GlobalFixupReferences"/>
</seealso>
</element>

<element name="RedirectFixupReferences">  <!-- Procedure -->
<short>Redirects references under the <var>root</var> object from
<var>OldRootName</var> to <var>NewRootName</var></short>
<descr>
<p>
<var>RedirectFixupReferences</var> examines the list of unresolved
references and replaces references to a root object named
<var>OldRootName</var> with references to root object 
<var>NewRootName</var>.
</p>
<p>
An application programmer should never need to call 
<var>RedirectFixupReferences</var>.
This function can be used by an IDE to support redirection of broken
component links.
</p>
</descr>
<seealso>
<link id="RemoveFixupReferences"/>
</seealso>
</element>

<element name="RemoveFixupReferences">  <!-- Procedure -->
<short>Removes references to rootname from the fixup list.</short>
<descr>
<p>
<var>RemoveFixupReferences</var> examines the list of unresolved
references and removes references to a root object pointing at
<var>Root</var> or a root component named <var>RootName</var>.
</p>
<p>
An application programmer should never need to call 
<var>RemoveFixupReferences</var>.
This function can be used by an IDE to support removal of broken
component links.
</p>
</descr>
<seealso>
<link id="RedirectFixupReferences"/>
</seealso>
</element>

<element name="RemoveFixups">  <!-- Procedure -->
<short>Removes <var>Instance</var> from the fixup list.</short>
<descr>
<var>RemoveFixups</var> removes all entries for component
<var>Instance</var> from the list of unresolved references.a
</descr>
<seealso>
<link id="RedirectFixupReferences"/>
<link id="RemoveFixupReferences"/>
</seealso>
</element>

<element name="FindNestedComponent">  <!-- Function -->
<short>Finds the component with name path starting at the indicated root
component.</short>
<descr>
<var>FindNestedComponent</var> will descend through the list of owned
components (starting at <var>Root</var>) and will return the component whose
name path matches <var>NamePath</var>. As a path separator the characters .
(dot), - (dash) and > (greater than) can be used
</descr>
<seealso>
<link id="GlobalFixupReferences"/>
</seealso>
</element>

<element name="BeginGlobalLoading">  <!-- Procedure -->
<short>Not yet implemented</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="NotifyGlobalLoading">  <!-- Procedure -->
<short>Not yet implemented.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="EndGlobalLoading">  <!-- Procedure -->
<short>Not yet implemented.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="CollectionsEqual">  <!-- Function -->
<short>Returns <var>True</var> if two collections are equal.</short>
<descr>
<var>CollectionsEqual</var> is not yet implemented. It simply returns
<var>False</var>
</descr>
</element>

<element name="ObjectBinaryToText">  <!-- Procedure -->
<short>Converts an object stream from a binary to a text format.</short>
<descr>
<var>ObjectBinaryToText</var> reads an object stream in binary format from
<var>Input</var> and writes the object stream in text format to
<var>Output</var>. No components are instantiated during the process, 
this is a pure conversion routine.
</descr>
<seealso>
<link id="ObjectTextToBinary"/>
</seealso>
</element>

<element name="ObjectTextToBinary">  <!-- Procedure -->
<short>Converts an object stream from a text to a binary format.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<element name="ObjectResourceToText">  <!-- Procedure -->
<short>Converts an object stream from a (windows) resource to a text format.</short>
<descr>
<var>ObjectResourceToText</var> reads the resource header from the
<var>Input</var> stream and then passes the streams to
<link id="ObjectBinaryToText"/>
</descr>
<seealso>
<link id="ObjectBinaryToText"/>
<link id="ObjectTextToResource"/>
</seealso>
</element>

<element name="ObjectTextToResource">  <!-- Procedure -->
<short>Converts an object stream from a text to a (windows) resource  format.</short>
<descr>
<p>
<var>ObjectTextToResource</var> reads an object stream in text format from
<var>Input</var> and writes a resource stream to <var>Output</var>.
</p>
<p>
Note that for the current implementation of this method in Free Pascal, 
the output stream should support positioning. (e.g. it should not be a pipe)
</p> 
</descr>
<seealso>
<link id="ObjectBinaryToText"/>
<link id="ObjectResourceToText"/>
</seealso>
</element>

<element name="LineStart">  <!-- Function -->
<short>Finds the start of a line in <var>Buffer</var> before
<var>BufPos</var>.</short>
<descr>
<var>LineStart</var> reversely scans <var>Buffer</var> starting at
<var>BufPos</var> for a linefeed character. It returns a pointer at the
linefeed character.
</descr>
</element>

<element name="TPointerList">
<short>Type for an Array of pointers.</short>
</element>

<element name="PPointerList">
<short>Pointer to an array of pointers.</short>
</element>

<element name="THelpContext">
<short>Range type to specify help contexts.</short>
</element>

<element name="THelptype">
<short>Enumeration type specifying the kind of help requested.</short>
</element>

<element name="PStringItemList">
<short>Pointer to a <link id="TStringItemList"/>.</short>
</element>

<element name="TBasicActionClass">
<short><link id="TBasicAction"/> class reference.</short>
</element>

<element name="TBAsicActionLinkClass">
<short><link id="TBasicActionLink"/> class reference.</short>
</element>

<element name="TListNotification">
<short>Kind of list notification event.</short>
</element>


<element name="TListSortCompare">
<short>Callback type for the list sort algorithm.</short>
</element>


<element name="TSeekOrigin">
<short>Specifies the origin of the <link id="TStream.Seek"/> method.</short>
</element>

<element name="TSeekOrigin.soBeginning">
<short>Offset is interpreted relative to the start of the stream.</short>
</element>

<element name="TSeekOrigin.SoEnd">
<short>Offset is interpreted relative to the end of the stream.</short>
</element>

<element name="TSeekOrigin.soCurrent">
<short>Offset is interpreted relative to the current position in the stream.</short>
</element>

<element name="TShortCut">
<short>Enumeration type to identify shortcut key combinations.</short>
</element>

<element name="TStringListSortCompare">
<short>Callback type used in stringlist compares.</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="sysutils">
<short>System routines</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="types">
<short>System types</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="typinfo">
<short>RTTI information</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="rtlconsts">
<short>Resource strings with messages</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TShiftStateEnum">
<short>Keyboard/Mouse shift state enumerator</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssShift">
<short>Shift key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssAlt">
<short>Alt key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssCtrl">
<short>Ctrl key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssLeft">
<short>Left mouse button pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssRight">
<short>Right mouse button pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssMiddle">
<short>Middle mouse button pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssDouble">
<short>Double mouse click.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssMeta">
<short>Meta key pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssSuper">
<short>Super key pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssHyper">
<short>Hyper key pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssAltGr">
<short>Alt-GR key pressed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssCaps">
<short>Caps lock key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssNum">
<short>Num lock key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssScroll">
<short>Scroll lock key pressed</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssTriple">
<short>Triple mouse click</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TShiftStateEnum.ssQuad">
<short>Quadruple mouse click</short>
</element>

<element name="TShiftStateEnum.ssExtra1">
<short>Extra key 1</short>
</element>5A

<element name="TShiftStateEnum.ssExtra2">
<short>Extra key 2</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="THelpType.htKeyword">
<short>Help type: Keyword help</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="THelpType.htContext">
<short>Help type: Context ID help.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListNotification.lnAdded">
<short>List change notification: Element added to the list.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListNotification.lnExtracted">
<short>List change notification: Element extracted from the list.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListNotification.lnDeleted">
<short>List change notification: Element deleted from the list.</short>
</element>

<!-- function Visibility: public -->
<element name="TList.Extract">
<short>Remove the first occurrence of a pointer from the list.</short>
<descr>
<var>Extract</var> searched for an occurrence of <var>item</var>, and if a
match is found, the match is deleted from the list. If no match is found,
nothing is deleted. If <var>Item</var> was found, the result is
<var>Item</var>. If <var>Item</var> was not found, the result is
<var>Nil</var>. A <var>lnExtracted</var> notification event is triggered if
an element is extracted from the list. 
</descr>
<seealso>
<link id="TList.Delete"/>
<link id="TList.IndexOf"/>
<link id="TList.Remove"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TList.Assign">
<short>Copy the contents of other lists.</short>
<descr>
<var>Assign</var> can be used to merge or assign lists It is an extended
version of the usual <var>TPersistent.Assign</var> mechanism. The arguments
<var>ListA</var> and <var>ListB</var> are used as sources of pointers to 
add or remove elements from the current list, depending on the operation 
<var>AOperation</var>. The available operations are documented in the 
<link id="TListAssignOp"/> type.
</descr>
<seealso>
<link id="TList.Clear"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="TRecall">
<short>Helper class for storing published properties</short>
<descr>
<p>
<var>TRecall</var> is a helper class used to copy published 
properties of a class (the reference object) in another class
(the storage object). The reference object and storage object must be
assignable to each other. 
</p>
<p>
The <var>TRecall</var> can be used to store the state of a persistent class,
and restore it at a later time.
</p>
<p>When a <var>TRecall</var> object is created, it gets passed a reference
instance and a storage instance. It immediately stores the properties of
the reference object in the storage object. 
</p>
<p>
The <link id="TRecall.Store">Store</link> method can be called throughout
the lifetime of the reference object to update the stored properties.
</p>
<p>When the <var>TRecall</var> instance is destroyed then the properties are
copied from the storage object to the reference object. The storage object
is freed automatically.
</p>
<p>
If the properties should not be copied back from the storage to the
reference object, the <link id="TRecall.Forget">Forget</link> can be called.
</p>
</descr>
<seealso>
<link id="TRecall.Create"/>
<link id="TRecall.Destroy"/>
<link id="TRecall.Forget"/>
<link id="TRecall.Store"/>
<link id="TPersistent.Assign"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TRecall.Create">
<short>Creates a new instance of <var>TRecall</var>.</short>
<descr>
<var>Create</var> creates a new instance of <var>TRecall</var> and
initializes the Reference and Storage instances. It calls <link
id="TRecall.Store">Store</link> to assign the reference object properties to
the storage instance.
</descr>
<seealso>
<link id="TRecall.Store"/>
<link id="TRecall.Destroy"/>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TRecall.Destroy">
<short>Copies the stored properties to the reference object and destroys the
<var>TRecall</var> instance.</short>
<descr>
<var>Destroy</var> assigns the storage instance to the reference instance,
if the latter is still valid. After this, it frees the storage and calls the
inherited destroy.
</descr>
<errors>
<var>Destroy</var> does not check whether the <link
id="TRecall.Reference">reference</link> instance is still valid. If the
reference pointer was invalidated, call <link id="TRecall.Forget"/> to clear
the reference instance.
</errors>
<seealso>
<link id="TRecall.Store"/>
<link id="TRecall.Forget"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TRecall.Store">
<short>Assigns the reference instance to the storage instance.</short>
<descr>
<p>
<var>Store</var> assigns the reference instance to the storage instance.
This will only work if the two classes can be assigned to each other.
</p>
<p>
This method can be used to refresh the storage.
</p>
</descr>
<errors>
<var>Store</var> does not check whether the <link
id="TRecall.Reference">reference</link> instance is still valid. If the
reference pointer was invalidated, call <link id="TRecall.Forget"/> to clear
the reference instance.
</errors>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TRecall.Forget">
<short>Clear the reference property.</short>
<descr>
<p>
<var>Forget</var> sets the <link id="TRecall.Reference">Reference</link> property to
<var>Nil</var>. When the <var>TRecall</var> instance is destroyed, the
reference instance will not be restored. 
</p>
<p>
Note that after a call to <var>Forget</var>, a call to <link
id="TRecall.Store">Store</link> has no effect.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TRecall.Reference"/>
<link id="TRecall.Store"/>
<link id="TRecall.Destroy"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TRecall.Reference">
<short>The reference object.</short>
<descr>
<var>Reference</var> is the instance of the reference object. Do not free
the reference directly. 
Call <link id="TRecall.Forget">Forget</link> to clear the reference and then
free the reference object.
</descr>
<seealso>
<link id="TRecall.Forget"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCollectionNotification">
<short>Collection change notifcation enumeration.</short>
<descr>
<var>TCollectionNotification</var> is used in the <link id="TCollection"/>
class to send notifications about changes to the collection.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollectionNotification.cnAdded">
<short>An item is added to the collection.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollectionNotification.cnExtracting">
<short>An item is extracted from the collection.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCollectionNotification.cnDeleting">
<short>An item is deleted from the collection.</short>
</element>

<!-- function Visibility: public -->
<element name="TCollection.Owner">
<short>Owner of the collection.</short>
<descr>
<var>Owner</var> returns a reference to the owner of the collection. This
property is required by the object inspector to be able to show the
collection.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TCollection.Delete">
<short>Delete an item from the collection.</short>
<descr>
<var>Delete</var> deletes the item at (zero based) position 
<var>Index</var> from the collection. This will result in a
<var>cnDeleted</var> notification.
</descr>
<errors>
If an invalid index is specified, an <var>EListError</var> exception is raised.
</errors>
<seealso>
<link id="TCollection.Items"/>
<link id="TCollection.Insert"/>
<link id="TCollection.Clear"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TCollection.Insert">
<short>Insert an item in the collection.</short>
<descr>
<p>
<var>Insert</var> creates a new item instance and inserts it in 
the collection at position <var>Index</var>, and returns the new instance.
</p>
<p>
In contrast, <link id="TCollection.Add"/> adds a new item at the end.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TCollection.Add"/>
<link id="TCollection.Delete"/>
<link id="TCollection.Items"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="TOwnedCollection">
<short><link id="#rtl.classes.TCollection">TCollection</link> descendant
which maintains owner information.</short>
<descr>
<var>TOwnedCollection</var> automatically maintains owner information, so it
can be displayed in an IDE. Collections that should be displayed in an
IDE should descend from <var>TOwnedCollection</var> or must implement a
<var>GetOwner</var> function.
</descr>
<seealso>
<link id="TCollection"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TOwnedCollection.Create">
<short>Create a new <var>TOwnerCollection</var> instance.</short>
<descr>
<var>Create</var> creates a new instance of <var>TOwnedCollection</var> and
stores the <var>AOwner</var> references. It will the value returned in the <link
id="TCollection.Owner"/> property of the collection. The
<var>ItemClass</var> class reference is passed on to the inherited
constructor, and will be used to create new instances in the <link
id="TCollection.Insert">Insert</link> and <link
id="TCollection.Add">Add</link> methods.
</descr>
<seealso>
<link id="TCollection.Create"/>
<link id="TCollection.Owner"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="TOwnerStream">
<short>Stream which uses a second stream as a source</short>
<descr>
<var>TOwnerStream</var> can be used when creating stream chains 
such as when using encryption and compression streams. It keeps a reference
to the source stream and will automatically free the source stream when
ready (if the <link id="TOwnerStream.SourceOwner">SourceOwner</link>
property is set to <var>True</var>).
</descr>
<seealso>
<link id="TStream"/>
<link id="TOwnerStream.Source"/>
<link id="TOwnerStream.SourceOwner"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TOwnerStream.Create">
<short>Create a new instance of <var>TOwnerStream</var>.</short>
<descr>
<var>Create</var> instantiates a new instance of <var>TOwnerStream</var> and
stores the reference to <var>AStream</var>. If <var>SourceOwner</var> is
<var>True</var>, the soure stream will also be freed when the instance is
destroyed.
</descr>
<seealso>
<link id="TOwnerStream.Destroy"/>
<link id="TOwnerStream.Source"/>
<link id="TOwnerStream.SourceOwner"/>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TOwnerStream.Destroy">
<short>Destroys the <var>TOwnerStream</var> instance and the source stream.</short>
<descr>
<var>Destroy</var> frees the source stream if the <var>SourceOwner</var>
property is <var>True</var>.
</descr>
<errors>
</errors>
<seealso>
<link id="TOwnerStream.Create"/>
<link id="TOwnerStream.Source"/>
<link id="TOwnerStream.SourceOwner"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TOwnerStream.Source">
<short>Reference to the source stream.</short>
<descr>
<p>
<var>Source</var> is the source stream. It should be used by descendant
streams to access the source stream to read from or write to.
</p>
<p>
Do not free the <var>Source</var> reference directly if
<var>SourceOwner</var> is <var>True</var>. In that case the owner
stream instance will free the source stream itself.
</p>
</descr>
<seealso>
<link id="TOwnerStream.Create"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TOwnerStream.SourceOwner">
<short>Indicates whether the ownerstream owns it's source</short>
<descr>
<var>SourceOwner</var> indicates whether the <var>TOwnerStream</var> owns
it's <var>Source</var> stream or not. If this property is <var>True</var>
then the <var>Source</var> stream is freed when the <var>TOwnerStream</var>
instance is freed.
</descr>
<seealso>
<link id="TOwnerStream.Source"/>
<link id="TOwnerStream.Destroy"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="THandleStream.Seek">
<short>Overrides the Seek method.</short>
<descr>
<var>seek</var> uses the <link id="#rtl.SysUtils.FileSeek">FileSeek</link>
method to position the stream on the desired position. Note that handle
stream descendants (notably pipes) can override the method to prevent the
seek.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TCustomMemoryStream.GetSize">
<short>return the size of the stream.</short>
<descr>
<var>GetSize</var> returns the size of the reseved memory. It should not be
used directly.
</descr>
<seealso>
<link id="TStream.Size"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TValueType.vaUTF8String">
<short>UTF8 encoded unicode string.</short>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.NextValue">
<short>Return the type of the next value.</short>
<descr>
<p>
<var>NextValue</var> returns the type of the next value in a binary stream,
but does not read the value.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadValue">
<short>Read the next value in the stream</short>
<descr>
<p>
<var>NextValue</var> reads the next value in a binary stream and returns 
the type of the read value.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.BeginRootComponent">
<short>Start reading the root component.</short>
<descr>
<p>
<var>BeginRootComponent</var> starts reading the root component in a binary
stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.BeginComponent">
<short>Start reading a component.</short>
<descr>
<p>
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.BeginProperty">
<short>Start reading a property.</short>
<descr>
<p>
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.ReadBinary">
<short>Start reading a binary value.</short>
<descr>
<p>
<var>ReadBinary</var> reads a binary valye from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream  of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadFloat">
<short>Read a float value</short>
<descr>
<p>
<var>ReadFloat</var> reads a float value from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadSingle">
<short>Read a single-size float value</short>
<descr>
<p>
<var>ReadSingle</var> reads a single-sized float value from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadDate">
<short>Read a date.</short>
<descr>
<p>
<var>ReadDate</var> reads a date value from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadIdent">
<short>Read an identifier</short>
<descr>
<p>
<var>ReadIdent</var> reads an identifier from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadInt8">
<short>Read an 8-bits integer.</short>
<descr>
<p>
<var>Read8Int</var> reads an 8-bits signed integer from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadInt16">
<short>Read a 16-bits integer.</short>
<descr>
<p>
<var>Read16Int</var> reads a 16-bits signed integer from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadInt32">
<short>Read a 32-bits integer.</short>
<descr>
<p>
<var>Read32Int</var> reads a 32-bits signed integer from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadInt64">
<short>Read a 64-bits integer.</short>
<descr>
<p>
<var>Read64Int</var> reads a 64-bits signed integer from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadSet">
<short>Read a set</short>
<descr>
<p>
<var>ReadSet</var> reads a set from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadStr">
<short>Read a short string</short>
<descr>
<p>
<var>ReadStr</var> reads a short string from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadString">
<short>Read a string</short>
<descr>
<p>
<var>ReadStr</var> reads a string of type <var>StringType</var> from a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.SkipComponent">
<short>Skip a component's data</short>
<descr>
<p>
<var>SkipComponent</var> skips the data of a component in a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>.
</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.SkipValue">
<short>Skip a value's data</short>
<descr>
<p>
<var>SkipComponent</var> skips the data of the next value in a binary stream.
</p>
<p>
This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TSetMethodPropertyEvent">
<short>Callback for the <link id="TReader.OnSetMethodProperty"/> event.</short>
<descr>
<var>TSetMethodPropertyEvent</var> is the prototype for the <link
id="TReader.OnSetMethodProperty"/> event. <var>Reader</var> is the sender of
the event, <var>Instance</var> is the instance that is being streamed.
<var>PropInfo</var> is a pointer to the RTTI information for the property
being read, and <var>TheMethodName</var> is the name of the method that 
the property should be set to. <var>Handled</var> should be set to
<var>True</var> if the handler set the property succesfully. 
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="TPropertyNotFoundEvent">
<short>Callback for the <link id="TReader.OnPropertyNotFound"/> event.</short>
<descr>
<var>TPropertyNotFoundEvent</var> is the prototype for the <link
id="TReader.OnPropertyNotFound"/> event. <var>Reader</var> is the sender of
the event, <var>Instance</var> is the instance that is being streamed.
<var>PropInfo</var> is a pointer to the RTTI information for the property
being read. <var>Handled</var> should be set to <var>True</var> if
the handler redirected the unknown property succesfully, and <var>Skip</var>
should be set to <var>True</var> if the value should be skipped.
<var>IsPath</var> determines whether the property refers to a sub-property.
</descr>
<seealso>
<link id="TReader.OnPropertyNotFound"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TReadWriteStringPropertyEvent">
<short>Callback for the <link id="TReader.OnReadStringProperty"/> event handler</short>
<descr>
<var>TReadWriteStringPropertyEvent</var> is the prototype for the <link
id="TReader.OnReadStringProperty"/> event handler.  <var>Reader</var> is the
sender of
the event, <var>Instance</var> is the instance that is being streamed.
<var>PropInfo</var> is a pointer to the RTTI information for the property
being read. <var>Content</var> is the string as it was read from the stream.
</descr>
<seealso>
<link id="TReader.OnReadStringProperty"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TReader.OnPropertyNotFound">
<short>Handler for treating missing properties.</short>
<descr>
<p>
<var>OnPropertyNotFound</var> can be used to take appropriate action when a
property is read from a stream and no such property is found in the RTTI
information of the Instance that is being read from the stream. It can be
set at runtime, or at designtime by an IDE.
</p>
<p>
For more information about the meaning of the various arguments to the event
handler, see <link id="TPropertyNotFoundEvent"/>.
</p>
</descr>
<seealso>
<link id="TPropertyNotFoundEvent"/>
<link id="TReader.OnSetMethodProperty"/>
<link id="TReader.OnReadStringProperty"/>

</seealso>
</element>

<!-- property Visibility: public -->
<element name="TReader.OnSetMethodProperty">
<short>Handler for setting method properties.</short>
<descr>
<var>OnSetMethodProperty</var> can be set to handle the setting of method
properties. This handler can be used by an IDE to prevent methods from
actually being assigned when an object is being streamed in the designer.
</descr>
<seealso>
<link id="TReader.OnReadStringProperty"/>
<link id="TReader.OnPropertyNotFound"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TReader.OnReadStringProperty">
<short>Handler for translating strings when read from the stream.</short>
<descr>
<var>OnReadStringProperty</var> is called whenever a string property is read
from the stream. It can be used e.g. by a translation mechanism to translate the
strings on the fly, when a form is loaded. See <link
id="TReadWriteStringPropertyEvent"/> for a description of the various
parameters.
</descr>
<seealso>
<link id="TReader.OnPropertyNotFound"/>
<link id="TReader.OnSetMethodProperty"/>
<link id="TReadWriteStringPropertyEvent"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TWriteMethodPropertyEvent">
<short>Callback for the <link id="TWriter.OnWriteMethodProperty"/> event.</short>
<descr>
<var>TWriteMethodPropertyEvent</var> is the prototype for the <link
id="TWriter.OnWriteMethodProperty"/> event. <var>Writer</var> is the sender of
the event, <var>Instance</var> is the instance that is being streamed.
<var>PropInfo</var> is a pointer to the RTTI information for the property
being written, and <var>MethodValue</var> is the value of the method that
the property was set to. <var>DefMethodCodeValue</var> is set to the default
value of the property (Nil or the parent value).
<var>Handled</var> should be set to <var>True</var> if the handler set the property succesfully.
</descr>
<seealso>
<link id="TWriter.OnWriteMethodProperty"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TWriter.OnWriteMethodProperty">
<short>Handler from writing method properties.</short>
<descr>
<var>OnWriteMethodProperty</var> can be set by an IDE or some streaming
mechanism which handles dummy values for method properties; It can be used
to write a real value to the stream which will be interpreted correctly when
the stream is read. See <link id="TWriteMethodPropertyEvent"/> for a description of the arguments.
</descr>
<seealso>
<link id="TWriteMethodPropertyEvent"/>
<link id="TReader.OnSetMethodProperty"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TWriter.OnWriteStringProperty">
<short>Event handler for translating strings written to stream.</short>
<descr>
<var>OnWriteStringProperty</var> is called whenever a string property is
written to the stream. It can be used e.g. by a translation mechanism to 
translate the strings on the fly, when a form is written. See <link
id="TReadWriteStringPropertyEvent"/> for a description of the various
parameters.
</descr>
<seealso>
<link id="TReader.OnPropertyNotFound"/>
<link id="TReader.OnSetMethodProperty"/>
<link id="TReadWriteStringPropertyEvent"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="EThreadDestroyCalled">
<short>Exception raised when a thread is destroyed illegally.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TSynchronizeProcVar">
<short>Synchronize callback type</short>
</element>

<!-- property Visibility: public -->
<element name="TThread.FatalException">
<short>Exception that occurred during thread execution</short>
<descr>
<var>FatalException</var> contains the exception that occurred during the
thread's execution.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TComponent.BeforeDestruction">
<short>Overrides standard BeforeDestruction.</short>
<descr>
<var>BeforeDestruction</var> is overridden by <var>TComponent</var> to set
the <var>csDestroying</var> flag in <link id="TComponent.ComponentState"/>
</descr>
<seealso>
<link id="TComponent.ComponentState"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponent.ExecuteAction">
<short>Standard action execution method.</short>
<descr>
<var>ExecuteAction</var> checks whether <var>Action</var> handles the
current component, and if yes, calls the <var>ExecuteAction</var> method,
passing itself as a parameter. The function returns <var>True</var> if the
action handles the current component.
</descr>
<seealso>
<link id="TBasicAction"/>
<link id="TBasicAction.ExecuteAction"/>
<link id="TBasicAction.HandlesTarget"/>
<link id="TComponent.UpdateAction"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TComponent.RemoveFreeNotification">
<short>Remove a component from the Free Notification list.</short>
<descr>
<var>RemoveFreeNotification</var> removes <var>AComponent</var> from the
freenotification list. 
</descr>
<seealso>
<link id="TComponent.FreeNotification"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponent.UpdateAction">
<short>Updates the state of an action.</short>
<descr>
<var>UpdateAction</var> checks whether <var>Action</var> handles the
current component, and if yes, calls the <var>UpdateTarget</var> method,
passing itself as a parameter. The function returns <var>True</var> if the
action handles the current component.
</descr>
<seealso>
<link id="TBasicAction"/>
<link id="TBasicAction.UpdateTarget"/>
<link id="TBasicAction.HandlesTarget"/>
<link id="TBasicAction.ExecuteAction"/>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="TDataModule">
<short>Container for non-visual components.</short>
<descr>
<p>
<var>TDataModule</var> is a container for non-visual objects which can be
used in an IDE to group non-visual objects which can be used by various
other containers (forms) in a project. Notably, data access components are
typically stored on a datamodule. Web components and services can also be 
implemented as descendants of datamodules.
</p>
<p>
<var>TDataModule</var> introduces some events which make it easier to
program, and provides the needed streaming capabilities for persistent
storage.
</p>
<p>
An IDE will typically allow to create a descendant of <var>TDataModule</var>
which contains non-visual components in it's published property list.
</p>
</descr>
<seealso>
<link id="TDataModule.OnCreate"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TDataModule.Create">
<short>Create a new instance of a <var>TDataModule</var>.</short>
<descr>
<var>Create</var> creates a new instance of the <var>TDatamodule</var>
and calls <link id="TDatamodule.CreateNew"/>. After that it reads the 
published properties from a stream using <link id="InitInheritedComponent"/>
if a descendant class is instantiated. If the <link id="TDataModule.OldCreateOrder">OldCreateOrder</link>
property is <var>True</var>, the <link id="TDataModule.OnCreate"/> event is called.
</descr>
<errors>
An exception can be raised during the streaming operation.
</errors>
<seealso>
<link id="TDataModule.CreateNew"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TDataModule.CreateNew">
<short></short>
<descr>
<var>CreateNew</var> creates a new instance of the class, but bypasses the
streaming mechanism. The <var>CreateMode</var> parameter (by default zero)
is not used in <var>TDataModule</var>. If the <link id="AddDataModule"/>
handler is set, then it is called, with the newly created instance as an
argument.
</descr>
<seealso>
<link id="TDataModule.Create"/>
<link id="AddDataModule"/>
<link id="TDataModule.OnCreate"/>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TDataModule.Destroy">
<short>Destroys the <var>TDataModule</var> instance.</short>
<descr>
<p>
<var>Destroy</var> destroys the <var>TDataModule</var> instance. If the
<link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is
<var>True</var> the <link id="TDataModule.OnDestroy">OnDestroy</link> event
handler is called prior to destroying the data module.
</p>
<p>
Before calling the inherited destroy, the <link id="RemoveDataModule"/>
handler is called if it is set, and <var>Self</var> is passed as a
parameter.
</p>
</descr>
<errors>
An event can be raised during the <var>OnDestroy</var> event handler.
</errors>
<seealso>
<link id="TDataModule.OnDestroy"/>
<link id="RemoveDataModule"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TDataModule.AfterConstruction">
<short>Overrides standard <link id="#rtl.system.TObject">TObject</link> behaviour.</short>
<descr>
<var>AfterConstruction</var> calls the <link
id="TDataModule.OnCreate">OnCreate</link> handler if the <link
id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is
<var>False</var>.
</descr>
<seealso>
<link id="TDataModule.OldCreateOrder"/>
<link id="TDataModule.OnCreate"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TDataModule.BeforeDestruction">
<short></short>
<descr>
<var>BeforeDestruction</var> calls the <link id="TDataModule.OnCreate">OnDestroy</link> 
handler if the <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is
<var>False</var>.
</descr>
<seealso>
<link id="TDataModule.OldCreateOrder"/>
<link id="TDataModule.OnDestroy"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TDataModule.DesignOffset">
<short>Position property needed for manipulation in an IDE.</short>
<descr>
<var>DesignOffset</var> is the position of the datamodule when displayed in
an IDE. It is streamed to the form file, and should not be used at run-time.
</descr>
<seealso>
<link id="TDataModule.DesignSize"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TDataModule.DesignSize">
<short>Size property needed for manipulation in an IDE.</short>
<descr>
<var>DesignSize</var> is the size of the datamodule when displayed in
an IDE. It is streamed to the form file, and should not be used at run-time.
</descr>
<seealso>
<link id="TDataModule.DesignOffset"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TDataModule.OnCreate">
<short>Event handler, called when the datamodule is created.</short>
<descr>
The <var>OnCreate</var> event is triggered when the datamodule is created
and streamed. The exact moment of triggering is dependent on the value of
the <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property.
</descr>
<seealso>
<link id="TDataModule.Create"/>
<link id="TDataModule.CreateNew"/>
<link id="TDataModule.OldCreateOrder"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TDataModule.OnDestroy">
<short>Event handler, called when the datamodule is destroyed.</short>
<descr>
The <var>OnDestroy</var> event is triggered when the datamodule is destroyed
The exact moment of triggering is dependent on the value of the 
<link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property.
</descr>
<seealso>
<link id="TDataModule.Destroy"/>
<link id="TDataModule.OnCreate"/>
<link id="TDataModule.Create"/>
<link id="TDataModule.CreateNew"/>
<link id="TDataModule.OldCreateOrder"/>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TDataModule.OldCreateOrder">
<short>Determines when <var>OnCreate</var> and <var>OnDestroy</var> are
triggered.</short>
<descr>
<p>
<var>OldCreateOrder</var> determines when exactly the <link
id="TDataModule.OnCreate">OnCreate</link> and <link
id="TDataModule.OnDestroy">OnDestroy</link> event handlers are called.
</p>
<p>
If set to <var>True</var>, then the <var>OnCreate</var> event handler is called
after the data module was streamed. If it is set to <var>False</var>, then
the handler is called prior to the streaming process.
</p>
<p>
If set to <var>True</var>, then the <var>OnDestroy</var> event handler is called
before the data module is removed from the streaming system. If it is set to <var>False</var>, then
the handler is called after the data module was removed from the streaming process.
</p>
</descr>
<seealso>
<link id="TDataModule.OnDestroy"/>
<link id="TDataModule.OnCreate"/>
<link id="TDataModule.Destroy"/>
<link id="TDataModule.Create"/>
<link id="TDataModule.CreateNew"/>
<link id="TDataModule.OldCreateOrder"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AddDataModule">
<short>Handler called when a new <link id="#rtl.classes.TDataModule">TDataModule</link> instance is created.</short>
<descr>
<var>AddDataModule</var> can be set by an IDE or a streaming mechanism to
receive notification when a new instance of a <link id="TDataModule"/>
descendant is created.
</descr>
<seealso>
<link id="RemoveDataModule"/>
<link id="TDataModule"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="RemoveDataModule">
<short>Handler called when a <link id="#rtl.classes.TDataModule">TDataModule</link> instance is freed.</short>
<descr>
<var>RemoveDataModule</var> can be set by an IDE or a streaming mechanism to
receive notification when an instance of a <link id="TDataModule"/>
descendant is freed.
</descr>
<seealso>
<link id="AddDataModule"/>
<link id="TDataModule"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="ApplicationHandleException">
<short>Handler for exceptions when a <link
id="#rtl.classes.TDataModule">TDataModule</link> streaming error occurs.</short>
<descr>
<var>ApplicationHandleException</var> can be set by an application object to
handle any exceptions that may occur when a <link id="TDataModule"/> is
created.
</descr>
<seealso>
<link id="TDataModule"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="ApplicationShowException">
<short>Unused.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="CheckSynchronize">
<short>Check whether there are any synchronize calls in the synchronize queue.</short>
<descr>
<p>
<var>CheckSynchronize</var> should be called regularly by the main application
thread to handle any <link id="TThread.Synchronize"/> calls that may be waiting for
execution by the main thread. If any such calls are waiting for execution by
the main thread, they are executed at once, in the order that they were
scheduled.
</p>
<p>
The function returns <var>True</var> if any <var>Synchronize</var> method was executed.
</p>
<p>
<var>TimeOut</var> is the maximum amount of time (in milliseconds) that the
<var>CheckSynchronize</var> routine will wait for synchronisation requests
to appear in the queue.
</p>
<p>
Calling this routine more often will ensure that synchronize requests are
handled faster.
</p>
<p>
This routine may not be called from any thread other than the main thread,
as it will execute the waiting requests.
</p>
<p>
Threads may call the <link id="WakeMainThread"/> to signal the main thread
that the synchronisation queue contains items, and thus speed up the
execution of the synchronize calls. 
</p>
</descr>
<seealso>
<link id="TThread.Synchronize"/>
<link id="WakeMainThread"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="WakeMainThread">
<short>Handler which is called if a thread wants to synchronize with the main application thread.</short>
<descr>
<p>
<var>WakeMainThread</var> is a handler, which, when set, is called by the <link id="TThread.Synchronize"/>
routine to signal the main thread that a synchronization routine is waiting
in the queue. 
</p>
<p>
This handler is by default empty. An actual implementation depends on the
main program logic (usually an event loop) and must be provided by the event loop
logic: the event loop will normally call <link id="CheckSynchronize"/> at
regular intervals. The <var>WakeMainThread</var> can make sure this happens
as soon as possible.
</p>
<p>
While this handle should alert the main program thread that a thread is waiting for
synchronization, the call is executed by the thread, and should therefore
NOT synchronize the thread, but should somehow signal the main thread that a
thread is waiting for synchronization. For example, by sending a message.
</p>
</descr>
<seealso>
<link id="CheckSynchronize"/>
<link id="TThread.Synchronize"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="StartClassGroup">
<short>Start new class group.</short>
<descr>
<p>
<var>StartClassGroup</var> starts a new class group and adds <var>AClass</var> to
it.
</p>
<p>
The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
</descr>
<seealso>
<link id="GroupDescendantsWith"/>
<link id="ActivateClassGroup"/>
<link id="ClassGroupOf"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="GroupDescendantsWith">
<short>Add class to the group of another class.</short>
<descr>
<p>
<var>GroupDescendantsWith</var> adds <var>AClass</var> to the group that
<var>AClassGroup</var> belongs to. If <var>AClassGroup</var> belongs to more
than 1 group, then it is added to the group which contains the nearest
ancestor.
</p>
<p>
The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="StartClassGroup"/>
<link id="ActivateClassGroup"/>
<link id="ClassGroupOf"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ActivateClassGroup">
<short>Activates a class group</short>
<descr>
<p>
<var>ActivateClassGroup</var> activates the group of classes to which
<var>AClass</var> belongs. The function returns the class that was last used
to activate the class group.
</p>
<p>
The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
</descr>
<errors>
If <var>AClass</var> does not belong to a class group, an exception is
raised.
</errors>
<seealso>
<link id="StartClassGroup"/>
<link id="GroupDescendantsWith"/>
<link id="ClassGroupOf"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ClassGroupOf">
<short>Returns the class group to which an instance or class belongs</short>
<descr>
<var>ClassGroupOf</var> returns the class group to which <var>AClass</var>
or <var>Instance</var> belongs.
</descr>
<errors>
The result is <var>Nil</var> if no matching class group is found.
</errors>
<seealso>
<link id="StartClassGroup"/>
<link id="ActivateClassGroup"/>
<link id="GroupDescendantsWith"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TInitComponentHandler">
<short>Callback type for <link id="#rtl.classes.RegisterInitComponentHandler">RegisterInitComponentHandler</link></short>
<descr>
<var>TInitComponentHandler</var> is a callback type. It is used in the
<link id="InitInheritedComponent"/> call to initialize a component.
Callbacks of this type are registered with the <link id="RegisterInitComponentHandler"/> call.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="RegisterFindGlobalComponentProc">
<short>Register a component searching handler</short>
<descr>
<var>RegisterFindGlobalComponentProc</var> registers a global component
search callback <var>AFindGlobalComponent</var>. 
When <link id="FindGlobalComponent"/> is called, 
then this callback will be used to search for the component.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="FindGlobalComponent"/>
<link id="UnRegisterFindGlobalComponentProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UnregisterFindGlobalComponentProc">
<short>Remove a previously registered component searching handler.</short>
<descr>
<var>UnRegisterFindGlobalComponentProc</var> unregisters the previously
registered global component search callback <var>AFindGlobalComponent</var>. 
After this call, when <link id="FindGlobalComponent"/> is called, then this 
callback will be no longer be used to search for the component.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="FindGlobalComponent"/>
<link id="RegisterFindGlobalComponentProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RegisterInitComponentHandler">
<short>Register a component initialization handler</short>
<descr>
<var>RegisterInitComponentHandler</var> registers a component initialization
handler <var>Handler</var> for the component <var>ComponentClass</var>. This
handler will be used to initialize descendants of
<var>ComponentClass</var> in the <link id="InitInheritedComponent"/> call. 
</descr>
<seealso>
<link id="InitInheritedComponent"/>
<link id="TInitComponentHandler"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="BinToHex">
<short>Convert a binary buffer to a hexadecimal string</short>
<descr>
<p>
<var>BinToHex</var> converts the byte values in <var>BinValue</var> 
to a string consisting of 2-charachter hexadecimal strings in
<var>HexValue</var>.
<var>BufSize</var> specifies the length of <var>BinValue</var>, which means
that <var>HexValue</var> must have size <var>2*BufSize</var>.
</p>
<p>
For example a buffer containing the byte values 255 and 0 will be converted to
FF00.
</p>
</descr>
<errors>
No length checking is done, so if an invalid size is specified, an exception
may follow.
</errors>
<seealso>
<link id="HexToBin"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="HexToBin">
<short>Convert a hexadecimal string to a binary buffer</short>
<descr>
<var>HexToBin</var> scans the hexadecimal string representation in
<var>HexValue</var> and transforms every 2 character hexadecimal 
number to a byte and stores it in <var>BinValue</var>. The buffer size is
the size of the binary buffer. Scanning will stop if the size of the binary
buffer is reached or when an invalid character is encountered. The return
value is the number of stored bytes.
</descr>
<errors>
No length checking is done, so if an invalid size is specified, an exception
may follow.
</errors>
<seealso>
<link id="BinToHex"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TSmallPoint.x">
<short>X coordinate</short>
</element>

<!-- variable Visibility: default -->
<element name="TSmallPoint.y">
<short>Y coordinate</short>
</element>

<!-- range type Visibility: default -->
<element name="TLeftRight">
<short>Subrange type based on <link id="#rtl.classes.TAlignment">TAlignment</link></short>
<descr>
<var>TLeftRight</var> is a subrange type based on the <link id="TAlignment"/> enumerated type.
It contains only the left and right alignment constants.
</descr>
<seealso>
<link id="TAlignment"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TBiDiMode">
<short>BIDI description</short>
<descr>
<var>TBiDiMode</var> describes bi-directional support for displaying texts.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBiDiMode.bdLeftToRight">
<short>Texts read from left to right.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBiDiMode.bdRightToLeft">
<short>Texts read from right to left.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBiDiMode.bdRightToLeftNoAlign">
<short>Texts read from right to left, but not right-aligned</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TBiDiMode.bdRightToLeftReadingOnly">
<short>Texts read from right to left</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TListCallback">
<short>Method callback type for <link id="#rtl.classes.TFPList.ForEachCall">TFPList.ForEachCall</link></short>
<descr>
<var>TListCallback</var> is the method callback prototype for the function that is passed to the
<link id="TFPList.ForEachCall"/> call. The <var>data</var> argument will be filled with 
all the pointers in the list (one per call) and the <var>arg</var> argument is the 
<var>Arg</var> argument passed to the <var>ForEachCall</var> call.
</descr>
<seealso>
<link id="TFPList.ForEachCall"/>
<link id="TListStaticCallback"/>
</seealso>
</element>

<element name="TListCallback.data">
<short>Data pointer from the list.</short>
</element>

<element name="TListCallback.arg">
<short>Parameter passed to the <var>ForEachCall</var> call.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TListStaticCallback">
<short>Static method callback type  for <link id="#rtl.classes.TFPList.ForEachCall">TFPList.ForEachCall</link></short>
<descr>
<var>TListCallback</var> is the procedurald callback prototype for the function that is passed to the
<link id="TFPList.ForEachCall"/> call. The <var>data</var> argument will be filled with 
all the pointers in the list (one per call) and the <var>arg</var> argument is the 
<var>Arg</var> argument passed to the <var>ForEachCall</var> call.
</descr>
<seealso>
<link id="TFPList.ForEachCall"/>
<link id="TListCallback"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TFPList.ForEachCall">
<short>Call a procedure or method for each pointer in the list.</short>
<descr>
<var>ForEachCall</var> iterates over all pointers in the list and calls 
<var>proc2call</var>, passing it the pointer and the additional <var>arg</var> data pointer.
<var>Proc2Call</var> can be a method or a static procedure.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TListStaticCallback"/>
<link id="TListCallback"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThreadList.Duplicates">
<short>Describes what to do with duplicates</short>
<descr>
<var>Duplicates</var> describes what the threadlist should do when a duplicate pointer is added to the list.
It is identical in behaviour to the <link id="TStringList.Duplicates">Duplicates</link> property of <link id="TStringList"/>.
</descr>
<seealso>
<link id="TDuplicates"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TInterfacedPersistent
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TInterfacedPersistent">
<short><var>TPersistent</var> descendant which implements the <var>IInterface</var> interface</short>
<descr>
<var>TInterfacedPersistent</var> is a direct descendant of <link id="TPersistent"/> which  implements 
the <link id="#rtl.system.IInterface"/> interface. In particular, it implements the <var>QueryInterface</var> 
as a public method.
</descr>
<seealso>
<link id="#rtl.system.IInterface">IInterface</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfacedPersistent.QueryInterface">
<short>Implementation of <var>IInterface.QueryInterface</var></short>
<descr>
<var>QueryInterface</var> simply calls <var>GetInterface</var> using the specified <var>IID</var>, and returns the 
correct values.
</descr>
<seealso>
<link id="#rtl.system.tobject.GetInterface">TObject.GetInterface</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfacedPersistent.AfterConstruction">
<short>Overrides the standard <var>AfterConstruction</var> method.</short>
<descr>
<var>AfterConstruction</var> is overridden to do some extra interface
housekeeping: a reference to the <var>IInterface</var> interface of the owning class is obtained (if it exists).
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="IStringsAdapter.ReferenceStrings">
<short>Add a reference to the indicated strings.</short>
</element>

<!-- procedure Visibility: default -->
<element name="IStringsAdapter.ReleaseStrings">
<short>Release the reference to the strings.</short>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IStreamPersist
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="IStreamPersist">
<short>Persistence streaming interface.</short>
<descr>
<var>IStreamPersist</var> defines an interface for object persistence streaming to a stream.
Any class implementing this interface is expected to be able to save or load it's state from
or to a stream.
</descr>
<seealso>
<link id="TPersistent"/>
<link id="TComponent"/>
<link id="TStream"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IStreamPersist.LoadFromStream">
<short>Load persistent data from stream.</short>
<descr>
<var>LoadFromStream</var> is the method called when the object should load it's state from the stream <var>stream</var>.
It should be able to read the data which was written using the <var>SavetoStream</var> method.
</descr>
<seealso>
<link id="TPersistent"/>
<link id="TComponent"/>
<link id="TStream"/>
<link id="IStreamPersist.SaveToStream"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IStreamPersist.SaveToStream">
<short>Save persistent data to stream.</short>
<descr>
<var>SaveFromStream</var> is the method called when the object should load it's state from the stream <var>stream</var>.
The data written by this method should be readable by the <var>LoadFromStream</var> method.
</descr>
<seealso>
<link id="TPersistent"/>
<link id="TComponent"/>
<link id="TStream"/>
<link id="IStreamPersist.LoadFromStream"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TAbstractObjectReader.ReadCurrency">
<short>Read a currency value from the stream.</short>
<descr>
<var>ReadCurrency</var> is called when a currency-typed value should be read from the stream.
This abstract method should be overidden by descendant classes, and should return the currency 
value read from the stream.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteCurrency"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TAbstractObjectReader.ReadWideString">
<short>Read a widestring value from the stream.</short>
<descr>
<var>ReadWideString</var> is called when a widestring-typed value should be read from the stream.
This abstract method should be overidden by descendant classes.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteWideString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadCurrency">
<short>Read a currency value from the stream.</short>
<descr>
<var>var>ReadCurrency</var> reads a currency-typed value from a binary stream.
It is the implementation of the method introduced in <link id="TAbstractObjectReader"/>.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadCurrency"/>
<link id="TBinaryObjectWriter.WriteCurrency"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadWideString">
<short>Read a widestring value from the stream.</short>
<descr>
<var>var>ReadWideString</var> reads a widestring-typed value from a binary stream.
It is the implementation of the method introduced in <link id="TAbstractObjectReader"/>.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadWideString"/>
<link id="TBinaryObjectWriter.WriteWideString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadCurrency">
<short>Read a currency value from the stream.</short>
<descr>
<var>ReadCurrency</var> reads a currency typed value from the stream and returns the result.
This method does nothing except call the driver method of the driver being used.
</descr>
<seealso>
<link id="TWriter.WriteCurrency"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadWideString">
<short>Read a WideString value from the stream.</short>
<descr>
<var>ReadWidestring</var> reads a widestring typed value from the stream and returns the result.
This method does nothing except call the driver method of the driver being used.
</descr>
<seealso>
<link id="TWriter.WriteWideString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteCurrency">
<short>Write a currency value to the stream</short>
<descr>
<var>WriteCurrency</var> is called when a currency-typed value should be written to the stream.
This abstract method should be overidden by descendant classes.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadCurrency"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteWideString">
<short>Write a widestring value to the stream</short>
<descr>
<var>WriteCurrency</var> is called when a currency-typed value should be written to the stream.
This abstract method should be overidden by descendant classes.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadWideString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteCurrency">
<short>Write a currency-valued type to a stream</short>
<descr>
<var>WriteCurrency</var> writes a currency-typed value to a binary stream.
It is the implementation of the method introduced in <link id="TAbstractObjectWriter"/>.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteCurrency"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteWideString">
<short>Write a widestring-valued type to a stream</short>
<descr>
<var>WriteWidestring</var> writes a widestring-typed value to a binary stream.
It is the implementation of the method introduced in <link id="TAbstractObjectWriter"/>.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteWidestring"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteCurrency">
<short>Write a currency value to the stream</short>
<descr>
<var>WriteCurrency</var> writes a currency typed value to the stream.
This method does nothing except call the driver method of the driver being used.
</descr>
<seealso>
<link id="TReader.ReadCurrency"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteWideString">
<short>Write a widestring value to the stream</short>
<descr>
<var>WriteWidestring</var> writes a currency typed value to the stream.
This method does nothing except call the driver method of the driver being used.
</descr>
<seealso>
<link id="TReader.ReadWideString"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TComponentStyle.csSubComponent">
<short>Subcomponent - streamed as part of the owning component</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TComponentStyle.csTransient">
<short>Transient component</short>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IDesignerNotify
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="IDesignerNotify">
<short>Designer notification interface</short>
<descr>
<var>IDesignerNotify</var> is an interface that can be used to communicate
changes to a designer mechanism. It offers functionality for detecting changes, 
and notifications when the component is destroyed.
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IDesignerNotify.Modified">
<short>Notify that the component is modified.</short>
<descr>
<var>Modified</var> can be used to notify a designer of changes, indicating that 
components should be streamed.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="IDesignerNotify.Notification">
<short>Notification of owner changes</short>
<descr>
<var>Notification</var> is the interface counterpart of <link id="TComponent.Notification"/>
which is used to communicate adds to the components.
</descr>
<seealso>
<link id="TComponent.Notification"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IInterfaceList
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="IInterfaceList">
<short>Interface for maintaining a list of interfaces.</short>
<descr>
<p>
<var>IInterfaceList</var> is an interface for maintaining a list of
interfaces, strongly resembling the standard <link id="TList"/> class.
It offers the same list of public methods as <var>TList</var>, with 
the exception that it uses interfaces instead of pointers.
</p>
<p>
All interfaces in the list should descend from <var>IUnknown</var>.
</p>
<p>
More detailed descriptions of how the various methods behave can be found in the <var>TList</var> reference.
</p>
</descr>
<seealso>
<link id="TList"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.Get">
<short>Retrieve an interface pointer from the list.</short>
<descr>
<var>Get</var> returns the interface pointer at position <var>i</var> in the list. 
It serves as the <var>Read</var> method for the 
<link id="IInterfaceList.Items">Items</link> property.
</descr>
<seealso>
<link id="IInterfaceList.Items"/>
<link id="TList.Items"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.GetCapacity">
<short>Return the capacity of the list.</short>
<descr>
<var>GetCapacity</var> returns the current capacity of the list.
It serves as the <var>Read</var> method for the
<link id="IInterfaceList.Capacity">Capacity</link> property.
</descr>
<seealso>
<link id="IInterfaceList.Capacity"/>
<link id="TList.Capacity"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.GetCount">
<short>Return the current number of elements in the list.</short>
<descr>
It serves as the <var>Read</var> method for the
<link id="IInterfaceList.Count">Count</link> property.
</descr>
<seealso>
<link id="IInterfaceList.Count"/>
<link id="TList.Count"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Put">
<short>Write an item to the list</short>
<descr>
<var>Put</var> writes the interface <var>Item</var> at position <var>I</var> in the list.
It servers as the <var>Write</var> method for the <link id="IInterfaceList.Items">Items</link> 
property.
</descr>
<seealso>
<link id="IInterfaceList.Items"/>
<link id="TList.Items"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.SetCapacity">
<short>Set the capacity of the list</short>
<descr>
<var>SetCapacity</var> sets the capacity of the list to <var>NewCapacity</var>. 
It serves as the <var>Write</var> method for the <link id="IInterfaceList.Capacity">Capacity</link>
property.
</descr>
<seealso>
<link id="IInterfaceList.Capacity"/>
<link id="TList.Capacity"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.SetCount">
<short>Set the number of items in the list</short>
<descr>
<var>SetCount</var> sets the count of the list to <var>NewCount</var>.
It serves as the <var>Write</var> method for the <link id="IInterfaceList.Capacity">Capacity</link>
</descr>
<seealso>
<link id="IInterfaceList.Count"/>
<link id="TList.Count"/>

</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Clear">
<short>Clear the list</short>
<descr>
<var>Clear</var> removes all interfaces from the list. All interfaces in the list will be cleared
(i.e. their reference count will decrease with 1)
</descr>
<seealso>
<link id="TList.Clear"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Delete">
<short>Remove an interface from the list</short>
<descr>
<var>Delete</var> removes the interface at position <var>Index</var> from the list.
It does this by explicitly clearing the interface and then removing the slot.
</descr>
<seealso>
<link id="TList.Clear"/>
<link id="IInterfaceList.Add"/>
<link id="IInterfaceList.Delete"/>
<link id="IInterfaceList.Insert"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Exchange">
<short>Exchange 2 interfaces in the list</short>
<descr>
<var>Exchange</var> exchanges 2 interfaces in the list at locations <var>index1</var> and <var>Index2</var>.
</descr>
<seealso>
<link id="TList.Exchange"/>
<link id="IInterfaceList.Add"/>
<link id="IInterfaceList.Delete"/>
<link id="IInterfaceList.Insert"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.First">
<short>Return the first non-empty interface in the list.</short>
<descr>
<var>First</var> returns the first non-empty interface in the list.
</descr>
<seealso>
<link id="TList.First"/>
<link id="IInterfaceList.IndexOf"/>
<link id="IInterfaceList.Last"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.IndexOf">
<short>Return the index of an interface.</short>
<descr>
<var>IndexOf</var> returns the location in the list of the interface <var>Item</var>. 
If there is no such interface in the list, then -1 is returned.
</descr>
<seealso>
<link id="TList.IndexOf"/>
<link id="IInterfaceList.First"/>
<link id="IInterfaceList.Last"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.Add">
<short>Add an interface to the list</short>
<descr>
<var>Add</var> adds the interface <var>Item</var> to the list, 
and returns the position at which it has been added.
</descr>
<seealso>
<link id="TList.Add"/>
<link id="IInterfaceList.Insert"/>
<link id="IInterfaceList.Delete"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Insert">
<short>Insert an interface in the list.</short>
<descr>
<var>Insert</var> inserts the interface <var>Item</var> in the list, at position <var>I</var>, shifting all items one position.
</descr>
<seealso>
<link id="TList.Insert"/>
<link id="IInterfaceList.Add"/>
<link id="IInterfaceList.Delete"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.Last">
<short>Returns the last non-nil interface in the list.</short>
<descr>
<var>Last</var> returns the last non-empty interface in the list.
</descr>
<seealso>
<link id="TList.Last"/>
<link id="IInterfaceList.First"/>
<link id="IInterfaceList.IndexOf"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceList.Remove">
<short>Remove an interface from the list</short>
<descr>
<var>Remove</var> searches for the first occurrence of <var>Item</var> in the list and deletes it.
</descr>
<seealso>
<link id="TList.Remove"/>
<link id="IInterfaceList.Delete"/>
<link id="IInterfaceList.IndexOf"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Lock">
<short>Lock the list</short>
<descr>
<var>Lock</var> locks the list. 
After a call to lock, the object list can only be accessed by the current
thread, untill <link id="IInterfaceList.Unlock">UnLock</link> is called.
</descr>
<seealso>
<link id="TInterfaceList.Lock"/>
<link id="IInterfaceList.Unlock"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IInterfaceList.Unlock">
<short>Unlock the list.</short>
<descr>
<var>Unlock</var> unlocks a locked list. After a call to <var>UnLock</var>,
other threads are again able to access the list.
</descr>
<seealso>
<link id="TInterfaceList.UnLock"/>
<link id="IInterfaceList.Lock"/>
</seealso>
</element>

<!-- property Visibility: default -->
<element name="IInterfaceList.Capacity">
<short>Capacity of the list</short>
<descr>
<var>Capacity</var> is the maximum number of elements the list can hold without needing to reallocate memory for the list.
It can be set to improve speed when adding a lot of items to the list.
</descr>
<seealso>
<link id="TList.Capacity"/>
<link id="IInterfaceList.Count"/>
</seealso>
</element>

<!-- property Visibility: default -->
<element name="IInterfaceList.Count">
<short>Current number of elements in the list.</short>
<descr>
<var>Count</var> is the current number of elements in the list. Setting it to a larger number will allocate empty slots. 
Setting it to a smaller number will clear any interfaces that fall outside the new border.
</descr>
<seealso>
<link id="IInterfaceList.Capacity"/>
<link id="TList.Count"/>
</seealso>
</element>

<!-- property Visibility: default -->
<element name="IInterfaceList.Items">
<short>Provides Index-based, sequential, access to the interfaces in the list.</short>
<descr>
<var>Items</var> is the default property of the interface list and provides index-based array access to the 
interfaces in the list. Allowed values for <var>Index</var> include 0 to <var>Count-1</var>
</descr>
<seealso>
<link id="IInterfaceList.Count"/>
<link id="TList.Items"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TInterfaceList
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TInterfaceList">
<short>Standard implementation of the <link id="#rtl.classes.IInterfaceList">IInterfaceList</link> interface.</short>
<descr>
<p>
<var>TInterfaceList</var> is a standard implementation of the <link
id="IInterfaceList"/> interface. It uses a <link id="TThreadList"/> instance to
store the list of interfaces.
</p>
<p>

</p>
</descr>
<seealso>
<link id="IInterfaceList"/>
<link id="TList"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TInterfaceList.Create">
<short>Create a new instance of <var>TInterfaceList</var></short>
<descr>
<var>Create</var> creates a new instance of the <var>TInterfaceList</var>
class. It sets up the internal structures needed to store the list of
interfaces.
</descr>
<seealso>
<link id="TInterfaceList.Destroy">Destroy</link>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TInterfaceList.Destroy">
<short>Destroys the list of interfaces</short>
<descr>
<p>
<var>Destroy</var> first calls <link id="TInterfaceList.Clear">Clear</link>
and then frees the <var>TInterfaceList</var> instance from memory.
</p>
<p>
Note that the <var>Clear</var> method decreases the reference count of all 
interfaces.
</p>
</descr>
<seealso>
<link id="TInterfaceList.Create">Create</link>
<link id="TInterfaceList.Clear">Clear</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Clear">
<short>Removes all interfaces from the list.</short>
<descr>
<var>Clear</var> is the implementation of the <link
id="IInterfaceList.Clear"/> method. 
It removes all interfaces from the list. It does this by
setting each element in the list to <var>Nil</var>, in this way the
reference count of each interface in the list is descreased.
</descr>
<seealso>
<link id="IInterfaceList.Clear"/>
<link id="TInterfaceList.Add">Add</link>
<link id="TInterfaceList.Destroy">Destroy</link>
<link id="TList.Clear"/>
<link id="TFPList.Clear"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Delete">
<short>Delete an interface from the list.</short>
<descr>
<var>Delete</var> is the implementation of the <link
id="IInterfaceList.Delete"/> method. It clears the slot first and then removes
the element from the list.
</descr>
<seealso>
<link id="IInterfaceList.Delete"/>
<link id="TInterfaceList.Remove"/>
<link id="TInterfaceList.Add"/>
<link id="TList.Delete"/>
<link id="TFPList.Delete"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Exchange">
<short>Exchange 2 interfaces in the list</short>
<descr>
<var>Exchange</var> is the implementation of the <link
id="IInterfaceList.Exchange"/> method. It exchanges the position of 
2 interfaces in the list.
</descr>
<seealso>
<link id="IInterfaceList.Exchange"/>
<link id="TInterfaceList.Delete"/>
<link id="TInterfaceList.Add"/>
<link id="TList.Exchange"/>
<link id="TFPList.Exchange"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.First">
<short>Returns the first non-<var>Nil</var> element in the list.</short>
<descr>
<var>First</var> is the implementation of the <link
id="IInterfaceList.First"/> method. It returns the first non-<var>Nil</var>
element from the list.
</descr>
<seealso>
<link id="IInterfaceList.First"/>
<link id="TList.First"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.IndexOf">
<short>Returns the index of an interface.</short>
<descr>
<var>IndexOf</var> is the implementation of the <link
id="IInterfaceList.IndexOf"/> method. It returns the zero-based index in the
list of the indicated interface, or -1 if the index is not in the list.
</descr>
<seealso>
<link id="IInterfaceList.IndexOf"/>
<link id="TList.IndexOf"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.Add">
<short>Add an interface to the list</short>
<descr>
<var>Add</var> is the implementation of the <link id="IInterfaceList.Add"/> method. It
adds an interface to the list, and returns the location of the new element
in the list. This operation will increment the reference
count of the interface.
</descr>
<seealso>
<link id="IInterfaceList.Add"/>
<link id="TInterfaceList.Delete"/>
<link id="TInterfaceList.Insert"/>
<link id="TList.Add"/>
<link id="TFPList.Add"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Insert">
<short>Insert an interface to the list</short>
<descr>
<var>Insert</var> is the implementation of the <link
id="IInterfaceList.Insert"/> method. It inserts an 
interface in the list at the indicated position. 
This operation will increment the reference count of the interface.
</descr>
<seealso>
<link id="IInterfaceList.Insert"/>
<link id="TInterfaceList.Delete"/>
<link id="TInterfaceList.Add"/>
<link id="TList.Insert"/>
<link id="TFPList.Insert"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.Last">
<short>Returns the last non-<var>Nil</var> element in the list.</short>
<descr>
<var>Last</var> is the implementation of the <link id="IInterfaceList.Last"/> method. 
It returns the last non-<var>Nil</var> element from the list.
</descr>
<seealso>
<link id="IInterfaceList.Last"/>
<link id="TInterfaceList.First"/>
<link id="TList.Last"/>
<link id="TFPList.Last"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.Remove">
<short>Remove an interface from the list</short>
<descr>
<var>Remove</var> is the implementation of the <link
id="IInterfaceList.Remove"/> method. It removes the first occurrence of the
interface from the list.
</descr>
<seealso>
<link id="IInterfaceList.Remove"/>
<link id="TInterfaceList.Delete"/>
<link id="TInterfaceList.IndexOf"/>
<link id="TList.Remove"/>
<link id="TFPList.Remove"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Lock">
<short>Lock the list</short>
<descr>
<var>Lock</var> locks the list. It is the implementation of the <link
id="IInterfaceList.Lock"/> method. It limits access to the list to the
current thread.
</descr>
<seealso>
<link id="IInterfaceList.Lock"/>
<link id="TInterfaceList.UnLock"/>
<link id="TThreadList.LockList"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TInterfaceList.Unlock">
<short>UnLocks a locked list</short>
<descr>
<var>UnLock</var> unlocks the list. It is the implementation of the <link
id="IInterfaceList.UnLock"/> method. After a call to unlock, the current
thread releases the list for manipulation by other threads.
</descr>
<seealso>
<link id="IInterfaceList.UnLock"/>
<link id="TInterfaceList.Lock"/>
<link id="TThreadList.UnLockList"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.Expand">
<short>Expands the list</short>
<descr>
<var>Expand</var> calls the expand method from the internally used list. It returns itself.
</descr>
<seealso>
<link id="TList.Expand"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceList.Capacity">
<short>The current capacity of the list.</short>
<descr>
<var>Capacity</var> is the number of elements that the list can contain
without needing to allocate more memory.
</descr>
<seealso>
<link id="IInterfaceList.Capacity"/>
<link id="TInterfaceList.Count"/>
<link id="TList.Capacity"/>
<link id="TFPList.Capacity"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceList.Count">
<short>The current number of elements in the list.</short>
<descr>
<var>Count</var> is the number of elements in the list. This can include
<var>Nil</var> elements. Note that the elements are zero-based, and thus 
are indexed from 0 to <var>Count-1</var>.
</descr>
<seealso>
<link id="IInterfaceList.Count"/>
<link id="TInterfaceList.Items"/>
<link id="TInterfaceList.Capacity"/>
<link id="TList.Count"/>
<link id="TFPList.Count"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceList.Items">
<short>Array-based access to the list's items.</short>
<descr>
<var>Items</var> provides indexed access to the elements in the list. Note
that the elements are zero-based, and thus are indexed from 0 to
<var>Count-1</var>. The items are read-write. It is not possible to add
elements to the list by accessing an element with index larger or equal to
<link id="TInterfaceList.Count">Count</link>.
</descr>
<seealso>
<link id="IInterfaceList.Items"/>
<link id="TInterfaceList.Count"/>
<link id="TList.Items"/>
<link id="TFPList.Items"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="PointsEqual">
<short>Check whether two <var>TPoint</var> variables are equal.</short>
<descr>
<var>PointsEqual</var> compares the <var>P1</var> and <var>P2</var> points
(of type <link id="TPoint"/> or <link id="TSmallPoint"/>) and returns
<var>True</var> if the <var>X</var> and <var>Y</var> coordinates of the 
points are equal, or <var>False</var> otherwise.
</descr>
<seealso>
<link id="TPoint"/>
<link id="TSmallPoint"/>
<link id="InvalidPoint"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InvalidPoint">
<short>Check whether a point is invalid.</short>
<descr>
<var>InvalidPoint</var> returns <var>True</var> if the <var>X</var> and
<var>Y</var> coordinates (of the <var>TPoint</var> or <var>TSmallPoint</var>
records, if one of these versions is used) are -1.
</descr>
<seealso>
<link id="TPoint"/>
<link id="TSmallPoint"/>
<link id="PointsEqual"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="GlobalNameSpace">
<short>Global namespace</short>
<descr>
An interface protecting the global namespace. Used when reading/writing to
the global namespace list during streaming of forms.
</descr>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ExtractStrings">
<short>Split a string in different words.</short>
<descr>
<var>ExtractStrings</var> splits <var>Content</var> (a null-terminated string)
into words, and adds the words to the <var>Strings</var> stringlist. The
words are separated by <var>Separators</var> and any characters in
<var>whitespace</var> are stripped from the strings. The space and CR/LF characters
are always considered whitespace.
</descr>
<errors>
No length checking is performed on <var>Content</var>. If no
null-termination character is present, an access violation may occur.
Likewise, if <var>Strings</var> is not valid, an access violation may occur.
</errors>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectReader.Read">
<short>Read raw data from stream</short>
<descr>
<var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in production code as
it will totally mess up the streaming.
</descr>
<seealso>
<link id="TBinaryObjectReader.Read"/>
<link id="TReader.Read"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.Read">
<short>Read raw data from stream</short>
<descr>
<var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in production code as
it will totally mess up the streaming.
</descr>
<seealso>
<link id="TAbstractObjectReader.Read"/>
<link id="TReader.Read"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TReader.Read">
<short>Read raw data from stream</short>
<descr>
<var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in new production code 
as it will totally mess up the streaming.
</descr>
<seealso>
<link id="TAbstractObjectReader.Read"/>
<link id="TBinaryObjectReader.Read"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadWideChar">
<short>Read widechar from the stream</short>
<descr>
<var>TReader.ReadWideChar</var> reads a widechar from the stream. This
actually reads a widestring and returns the first character.
</descr>
<seealso>
<link id="TReader.ReadWideString"/>
<link id="TWriter.WriteWideChar"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.Write">
<short>Write raw data to stream</short>
<descr>
<var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
<seealso>
<link id="TBinaryObjectWriter.Write"/>
<link id="TWriter.Write"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.Write">
<short>Write raw data to stream</short>
<descr>
<var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
<seealso>
<link id="TAbstractObjectWriter.Write"/>
<link id="TWriter.Write"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.Write">
<short>Write raw data to stream</short>
<descr>
<var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
<seealso>
<link id="TBinaryObjectWriter.Write"/>
<link id="TAbstractObjectWriter.Write"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteWideChar">
<short>Write widechar to stream</short>
<descr>
<var>WriteWideChar</var> writes a widechar to the stream. This
actually writes a widestring of length 1.
</descr>
<seealso>
<link id="TReader.ReadWideChar"/>
<link id="TWriter.WriteWideString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TThread.AfterConstruction">
<short>Code to be executed after construction but before execute.</short>
<descr>
<var>AfterConstruction</var> is overridden in <var>TThread</var>, it starts
the thread if it was created in a suspended state. When overriding this
method, the inherited method must be called.
</descr>
</element>




<!-- enumeration type Visibility: default -->
<element name="TListAssignOp">
<short>List assign operation</short>
<descr>
This type determines what operation <link id="TList.Assign"/> or <link
id="TFPList.assign"/> performs.
</descr>
<seealso>
<link id="TList.Assign"/>
<link id="TFPList.assign"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laCopy">
<short>Clear list and copy all strings from second list.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laAnd">
<short>Remove all elements not first second list</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laOr">
<short>Add all elements from second (and optional third) list, eliminate duplicates</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laXor">
<short>Remove elements in second lists, Add all elements from second list not in first list</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laSrcUnique">
<short>Just keep all elements that exist only in source list</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TListAssignOp.laDestUnique">
<short>Keep all elements that exists only in list2</short>
</element>

<!-- procedure Visibility: public -->
<element name="TFPList.AddList">
<short>Add all pointers from another list</short>
<descr>
<var>AddList</var> adds all pointers from <var>AList</var> to the list.
If a pointer is already present, it is added a second time.
</descr>
<seealso>
<link id="TFPList.Assign"/>
<link id="TList.AddList"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TList.AddList">
<short>Add all pointers from another list</short>
<descr>
<var>AddList</var> adds all pointers from <var>AList</var> to the list.
If a pointer is already present, it is added a second time.
</descr>
<seealso>
<link id="TList.Assign"/>
<link id="TFPList.AddList"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStrings.ExtractName">
<short>Extract the name part of a string</short>
<descr>
<var>ExtractName</var> returns the name part (the part before the <link
id="TStrings.NameValueSeparator">NameValueSeparator</link> character) of the
string. If the character is not present, an empty string is returned. The
resulting string is not trimmed, it can end or start with spaces.
</descr>
<seealso>
<link id="TStrings.NameValueSeparator">NameValueSeparator</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStrings.TextLineBreakStyle">
<short>Determines which line breaks to use in the <link
id="#rtl.classes.TStrings.Text">Text</link> property</short>
<descr>
<p>
<var>TextLineBreakStyle</var> determines which linebreak style is used when
constructing the Text property: the same rules are used as in the writing to
text files:
</p>
<dl>
<dt>tlbsLF</dt><dd>Lines are separated with a linefeed character #10.</dd>
<dt>tlbsCRLF</dt><dd>Lines are separated with a carriage-return/linefeed character
pair: #13#10.</dd>
<dt>tlbsCR</dt><dd>Lines are separated with a carriage-return character #13.</dd>
</dl>
<p>
It has no effect when setting the text property.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TStrings.Text">Text</link>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TStreamOwnership">
<short>Determines the ownership of a TStreamAdapter</short>
<descr>
The ownership of a streamadapter determines what happens with the stream
on which a <link id="TStreamAdapter"/> acts, when the adapter is freed.
</descr>
<seealso>
<link id="TStreamAdapter"/>
<link id="#rtl.types.IStream"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStreamOwnership.soReference">
<short>Stream is referenced only, it is not freed by the adapter</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStreamOwnership.soOwned">
<short>Stream is owned: it will be freed when the adapter is freed.</short>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TStreamAdapter
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TStreamAdapter">
<short>Implements IStream for <link id="#rtl.classes.TSTream">TStream</link> descendants</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!--
   constructor Create(Stream: TStream; Ownership: TStreamOwnership = soReference);
   destructor Destroy; override;
   function Read(pv: Pointer; cb: DWORD; pcbRead: PDWORD): HResult;  virtual; stdcall;
   function Write(pv: Pointer; cb: DWORD; pcbWritten: PDWORD): HResult;  virtual; stdcall;
   function Seek(dlibMove: Largeint; dwOrigin: Longint; out libNewPosition: Largeint): HResult; virtual; stdcall;
   function SetSize(libNewSize: Largeint): HResult; virtual; stdcall;
   function CopyTo(stm: IStream; cb: Largeint; out cbRead:
   Largeint; out cbWritten: Largeint): HResult; virtual; stdcall;
   function Commit(grfCommitFlags: Longint): HResult; virtual; stdcall;
   function Revert: HResult; virtual; stdcall;
   function LockRegion(libOffset: Largeint; cb: Largeint; dwLockType: Longint): HResult; virtual; stdcall;
   function UnlockRegion(libOffset: Largeint; cb: Largeint; dwLockType: Longint): HResult; virtual; stdcall;
   function Stat(out statstg: TStatStg; grfStatFlag: Longint):  HResult; virtual; stdcall;
   function Clone(out stm: IStream): HResult; virtual; stdcall;
   property Stream: TStream read FStream;
   property StreamOwnership: TStreamOwnership read  FOwnership write FOwnership;
-->                    
<!-- constructor Visibility: public -->
<element name="TStreamAdapter.Create">
<short>Create a new instance of <var>TStreamAdapter</var></short>
<descr>
<p>
<var>Create</var> creates a new instance of <var>TStreamAdaptor</var>. It
initializes <link id="TStreamAdapter.Stream"/> with <var>Stream</var> and initializes <link
id="TStreamAdapter.StreamOwnerShip">StreamOwnerShip</link> with
<var>Ownership</var>.
</p>
<p>
<var>TStreamAdapter</var> is an abstract class: descendants must be created
that implement the actual functionality.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="TStreamAdapter.StreamOwnerShip">StreamOwnerShip</link>
<link id="TStreamAdapter.Stream"/>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TStreamAdapter.Destroy">
<short>Free the <var>TStreamAdapter</var> instance</short>
<descr>
Explicitly free the <var>TStreamAdapter</var> instance. Normally, this is
done automatically if a reference to the <var>IStream</var> interface is freed.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Read">
<short>Read from the stream.</short>
<descr>
<var>Read</var> implements <link id="#rtl.types.ISequentialStream.Read"/> by reading from the stream
specified at creation.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.ISequentialStream.Read"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Write">
<short>Write to the stream</short>
<descr>
<var>Write</var> implements <link id="#rtl.types.ISequentialStream.Write"/> by writing to the
stream specified at creation.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.ISequentialStream.Write"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Seek">
<short>Set the stream position</short>
<descr>
<var>Seek</var> implements <link id="#rtl.types.IStream.Seek"/> by setting the
position of the stream specified at creation.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Seek"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.SetSize">
<short>Set the stream size</short>
<descr>
<var>SetSize</var> implements <link id="#rtl.types.IStream.Setsize"/> by setting the
size of the stream specified at creation.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Setsize"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.CopyTo">
<short>Copy data to destination stream</short>
<descr>
<var>CopyTo</var> implements <link id="#rtl.types.IStream.CopyTo"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Commit">
<short>Commit data to the stream</short>
<descr>
<var>Commit</var> implements <link id="#rtl.types.IStream.Commit"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Commit"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Revert">
<short>Revert operations on the stream</short>
<descr>
<var>Revert</var> implements <link id="#rtl.types.IStream.Revert"/>.
</descr>
<errors>
This function must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Revert"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.LockRegion">
<short>Lock a region of the stream</short>
<descr>
<var>LockRegion</var> implements <link id="#rtl.types.IStream.LockRegion"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.LockRegion"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.UnlockRegion">
<short>Unlock a region of the stream</short>
<descr>
<var>UnLockRegion</var> implements <link id="#rtl.types.IStream.UnLockRegion"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.UnLockRegion"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Stat">
<short>Return statistical data about the stream</short>
<descr>
<var>Stat</var> implements <link id="#rtl.types.IStream.Stat"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Stat"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStreamAdapter.Clone">
<short>Clone the stream</short>
<descr>
<var>Clone</var> implements <link id="#rtl.types.IStream.Clone"/>.
</descr>
<errors>
This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
<seealso>
<link id="#rtl.types.IStream.Clone"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStreamAdapter.Stream">
<short>Stream on which adaptor works</short>
<descr>
This is the stream on which the adaptor works. It was specified at
rreation.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TStreamAdapter.StreamOwnership">
<short>Determines what happens with the stream when the adaptor is freed</short>
<descr>
<var>StreamOwnership</var> determines what happens when the adaptor
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TWriter.PropertyPath">
<short>Path to the property that is currently being written</short>
<descr>
<var>PropertyPath</var> is set to the property name of the class currently
being written to stream. This is only done when <link id="TPersistent"/>
descendant class properties are written.
</descr>
<seealso>
</seealso>
</element>

<!-- object Visibility: default -->
<element name="IInterfaceComponentReference">
<short>Interface for checking component references</short>
<descr>
<var>IInterfaceComponentReference</var> is an interface to return the
component that implements a given interface. 
It is implemented by <link id="TComponent"/>.
</descr>
<seealso>
<link id="TComponent"/>.
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IInterfaceComponentReference.GetComponent">
<short>Return component instance</short>
<descr>
<var>GetComponent</var> returns the component instance.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TComponent"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponent.IsImplementorOf">
<short>Checks if the current component is the implementor of the interface</short>
<descr>
<var>IsImplementorOf</var> returns <var>True</var> if the current component
implements the given interface. The interface should descend from
<link id="IInterfaceComponentReference"/> and the <var>GetComponent</var>
method should return the current instance.
</descr>
<seealso>
<link id="IInterfaceComponentReference"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TComponent.ReferenceInterface">
<short>Interface implementation of Notification</short>
<descr>
<var>ReferenceInterface</var> can be used to notify an interface of
a component operation: it is the equivalent of the <link
id="TComponent.Notification"/> method of <var>TComponent</var> for
interfaces. If the interface implements <link
id="IInterfaceComponentReference"/>, then the component that implements the
interface is notified of the given operation <var>Op</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TComponent.Notification"/>
<link id="IInterfaceComponentReference"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="FindIntToIdent">
<short>Return the integer to string converter for an integer type</short>
<descr>
<var>FindIntToIdent</var> returns the handler that handles the conversion of
an integer to a string representation that can be used in component
streaming, when <link id="IntToIdent"/> is called.
</descr>
<errors>
Nil is returned if no handler is registered for the given type.
</errors>
<seealso>
<link id="IntToIdent"/>
<link id="TIntToIdent"/>
<link id="FindIdentToInt"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="FindIdentToInt">
<short>Return the string to integer converter for an integer type</short>
<descr>
<var>FindIdentToInt</var> returns the handler that handles the conversion of
a string representation to an integer that can be used in component
streaming, when <link id="IdentToInt"/> is called.
</descr>
<errors>
Nil is returned if no handler is registered for the given type.
</errors>
<seealso>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TCollectionSortCompare">
<short>Callback to sort collection items</short>
<descr>
<p>
<var>TCollectionSortCompare</var> is the prototype for a callback used in
the <link id="TCollection.Sort"/> method. The procedure should compare
<var>Item1</var> and <var>Item2</var> and return an integer:
</p>
<dl>
<dt>Result &lt; 0</dt><dd>if <var>Item1</var> comes before <var>Item2</var></dd>
<dt>Result = 0</dt><dd>if <var>Item1</var> is at the same level as <var>Item2</var></dd>
<dt>Result &gt; 0</dt><dd>if <var>Item1</var> comes after <var>Item2</var></dd>
</dl>
</descr>
<seealso>
<link id="TCollection.Sort"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TCollection.Sort">
<short>Sort the items in the collection</short>
<descr>
<p>
<var>Sort</var> sorts the items in the collection, and uses the <var>Compare</var>
procedure to compare 2 items in the collection. It is more efficient do use
this method than to perform the sort manually, because the list items are
manipulated directly.
</p>
<p>
For more information on how the <var>Compare</var> function should behave,
see the <link id="TCollectionSortCompare"/> type.
</p>
</descr>
<seealso>
<link id="TCollectionSortCompare"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStrings.StrictDelimiter">
<short>Should only the delimiter character be considered a delimiter</short>
<descr>
<p>
<var>StrictDelimiter</var> can be used to indicate that only the delimiter
character should be considered a delimiter when setting <link
id="TStrings.DelimitedText">DelimitedText</link>: under normal circumstances,
quotes and spaces are considered specially (see the <link id="TStrings.CommaText"/>
property for more information).</p>
<p>When <var>StrictDelimiter</var> is set to
<var>True</var> then only the <link id="TStrings.Delimiter">Delimiter</link>
character is considered when splitting the text in items: no quoting
whatsoever is performed when writing the
<var>DelimitedText</var> property. 
However, when reading the <var>DelimitedText</var> property, quoted strings are 
taken into account (so a quoted string can contain a delimiter that is treated 
as text instead of a delimiter).
</p>
</descr>
<seealso>
<link id="TStrings.DelimitedText">DelimitedText</link>
<link id="TStrings.CommaText">CommaText</link>
<link id="TStrings.Delimiter">Delimiter</link>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TValueType.vaUString">
<short>UnicodeString value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TValueType.vaQWord">
<short>QWord (64-bit word) value</short>
</element>

<!-- function Visibility: public -->
<element name="TAbstractObjectReader.ReadUnicodeString">
<short>Read a unicode string value</short>
<descr>
<p>
<var>ReadUnicodeString</var> should read a UnicodeString value from the
stream. (indicated by the <var>vaUString</var> value type).
</p>
<p>
Descendant classes should override this method to actually read a
UnicodeString value.
</p>
</descr>
<seealso>
<link id="TBinaryObjectWriter.WriteUnicodeString"/>
<link id="TAbstractObjectReader.ReadWideString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TBinaryObjectReader.ReadUnicodeString">
<short>Read a unicode string value</short>
<descr>
<var>ReadUnicodeString</var> is overridden by <var>TBinaryObjectReader</var>to 
read a UnicodeString value from the binary stream.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadUnicodeString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadUnicodeChar">
<short>Read unicode character</short>
<descr>
<var>ReadUnicodeChar</var> reads a single unicode character from the stream.
It does this by reading a <var>UnicodeString</var> string from the stream
and returning the first character.
</descr>
<errors>
If the string has a length different from 1, an <var>EReadError</var>
exception will occur.
</errors>
<seealso>
<link id="TReader.ReadUnicodeString"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadVariant">
<short>Read a variant from the stream</short>
<descr>
<var>ReadVariant</var> reads the next value from the stream and returns it
as a variant. No variant array can be read from the stream, only single
values.
</descr>
<errors>
If no variant manager is installed, the function will raise an
<var>EReadError</var> exception. If the next value is not a simple 
value, again an  <var>EReadError</var> exception is raised.
exception is 
</errors>
<seealso>
<link id="TBinaryObjectWriter.WriteVariant"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadUnicodeString">
<short>Read a UnicodeString value from the stream</short>
<descr>
<var>ReadUnicodeString</var> reads a <var>UnicodeString</var> string from
the stream. The stream can contain a string from any type, it will be
converted to UniCodeString.
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadUnicodeString"/>
<link id="TWriter.WriteUnicodeString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteUInt64">
<short>Write an unsigned 64-bit integer</short>
<descr>
<var>WriteUInt64</var> must be overridden by descendant classes to write
a 64-bit unsigned <var>Value</var> (valuetype <var>vaQWord</var>) to the stream.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TBinaryObjectWriter.WriteUInt64"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteVariant">
<short>Write a variant to the stream</short>
<descr>
<var>WriteVariant</var> must be overridden by descendant classes to write a
simple variant type to the stream. <var>WriteVariant</var> does not write
arrays types or complex types.
</descr>
<seealso>
<link id="TBinaryObjectWriter.WriteVariant"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteUnicodeString">
<short>Write a unicode string to the stream.</short>
<descr>
<var>WriteUnicodeString</var> must be overridden by descendant classes to
write a unicodestring (valuetype <var>vaUString</var>) value to the stream. 
</descr>
<seealso>
<link id="TBinaryObjectWriter.WriteUnicodeString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteUInt64">
<short>Write an unsigned 64-bit integer</short>
<descr>
<var>WriteUInt64</var> is overridden by <var>TBinaryObjectWriter</var> to write 
an unsigned 64-bit integer (QWord) to the stream. It tries to use the smallest 
possible storage for the value that is passed. 
(largest valuetype will be <var>vaQWord</var>). 
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteUInt64"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteUnicodeString">
<short>Write a unicode string to the stream.</short>
<descr>
<var>WriteUnicodeString</var> is overridden <var>TBinaryObjectWriter</var>
to write a unicodestring (valuetype <var>vaUString</var>) value to the stream.
It simply writes the character length and then all widecharacters.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteUnicodeString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteVariant">
<short>Write a variant to the stream</short>
<descr>
<var>WriteVariant</var> is overridden by <var>TBinaryObjectWriter</var> to write a
simple variant type to the stream. <var>WriteVariant</var> does not write
arrays types or complex types. Only null, integer (ordinal) float and string types are
written.
</descr>
<errors>
If a non-supported type is written, then an <var>EWriteError</var> exception is.
</errors>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteUnicodeString">
<short>Write a unicode string to the stream.</short>
<descr>
<var>WriteUnicodeString</var> writes <var>Value</var>, a UnicodeString string to the
stream.  It simply passes the string on to the <var>WriteUnicodeString</var>
method of the writer driver class.
</descr>
<seealso>
<link id="TBinaryObjectWriter.WriteUnicodeString"/>
<link id="TReader.ReadUnicodeString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteVariant">
<short>Write a variant to the stream</short>
<descr>
<var>WriteVariant</var> writes <var>Value</var>, a simple variant, o the
stream.  It simply passes the string on to the <var>WriteVariant</var>
method of the writer driver class.
</descr>
<seealso>
<link id="TBinaryObjectWriter.WriteVariant"/>
<link id="TReader.ReadVariant"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TFPListEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TFPListEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TFPList</var> class.</short>
<descr>
<var>TFPListEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TFPList"/> class, so the <var>TFPList</var>
 class can be used in a <var>for ... in</var> loop. It is returned by the
 <link id="TFPList.GetEnumerator"/> method of <var>TFPList</var>.
</descr>
<seealso>
<link id="TFPList"/>
<link id="TFPList.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TFPListEnumerator.Create">
<short>Initialize a new instance of <var>TFPListEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TFPListEnumerator</var>
and keeps a reference to the list <var>AList</var> that will be enumerated.
</descr>
<seealso>
<link id="TFPList"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPListEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current pointer in the enumerator.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TFPListEnumerator.MoveNext">MoveNext</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPListEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the list.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next item in the list, and
returns <var>True</var> if this succeeded, or <var>False</var> if the
pointer is past the last element in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TFPListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TFPListEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TFPListEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TFPListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TFPList.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TFPList</var>. It  creates a <link id="TFPListEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface.
</descr>
<seealso>
<link id="TFPListEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TListEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TListEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TList</var> class.</short>
<descr>
<var>TListEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TList"/> class, so the <var>TList</var>
 class can be used in a <var>for ... in</var> loop. It is returned by the
 <link id="TList.GetEnumerator"/> method of <var>TList</var>.
</descr>
<seealso>
<link id="TList"/>
<link id="TList.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TListEnumerator.Create">
<short>Initialize a new instance of <var>TListEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TListEnumerator</var>
and keeps a reference to the list <var>AList</var> that will be enumerated.
</descr>
<seealso>
<link id="TList"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TListEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current pointer in the enumerator.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TListEnumerator.MoveNext">MoveNext</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TListEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the list.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next item in the list, and
returns <var>True</var> if this succeeded, or <var>False</var> if the
pointer is past the last element in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TListEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TListEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TList.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TList</var>. It  creates a <link id="TListEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface.
</descr>
<seealso>
<link id="TListEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>


<!--
  ********************************************************************
    #rtl.Classes.TCollectionEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TCollectionEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TCollection</var> class.</short>
<descr>
<var>TCollectionEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TCollection"/> class, so the <var>TCollection</var>
 class can be used in a <var>for ... in</var> loop. It is returned by the
 <link id="TCollection.GetEnumerator"/> method of <var>TCollection</var>.
</descr>
<seealso>
<link id="TCollection"/>
<link id="TCollection.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TCollectionEnumerator.Create">
<short>Initialize a new instance of <var>TCollectionEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TCollectionEnumerator</var>
and keeps a reference to the collection <var>ACollection</var> that will be enumerated.
</descr>
<seealso>
<link id="TCollection"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TCollectionEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current <link id="TCollectionItem"/>
instance in the enumerator.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TCollectionEnumerator.MoveNext">MoveNext</link>
<link id="TCollectionItem"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TCollectionEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the collection.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next item in the collection, and
returns <var>True</var> if this succeeded, or <var>False</var> if the
pointer is past the last element in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TCollectionEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TCollectionEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TCollectionEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TCollectionEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TCollection.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TCollection</var>. It  creates a <link id="TCollectionEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface.
</descr>
<seealso>
<link id="TCollectionEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TCollection.Exchange">
<short>Exchange 2 items in the collection</short>
<descr>
<var>Exchange</var> exchanges the items at indexes <var>Index1</var> and <var>Index2</var>
in the collection. 
</descr>
<errors>
If one of the two indexes is invalid (less than zero or larger than the
number of items) an <var>EListError</var> exception is raised.
</errors>
<seealso>
<link id="TCollection.Items">Items</link>
<link id="TCollectionItem.Index"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TStringsEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TStringsEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TStrings</var> class.</short>
<descr>
<var>TStringsEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TStrings"/> class, so the <var>TStrings</var>
 class can be used in a <var>for ... in</var> loop. It is returned by the
 <link id="TStrings.GetEnumerator"/> method of <var>TStrings</var>.
</descr>
<seealso>
<link id="TStrings"/>
<link id="TStrings.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TStringsEnumerator.Create">
<short>Initialize a new instance of <var>TStringsEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TStringsEnumerator</var>
and keeps a reference to the stringlist <var>AStrings</var> that will be enumerated.
</descr>
<seealso>
<link id="TStrings"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStringsEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current string item in the enumerator.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TStringsEnumerator.MoveNext">MoveNext</link>
<link id="TStringItem"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStringsEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the list.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next item in the stringlist, and
returns <var>True</var> if this succeeded, or <var>False</var> if the
pointer is past the last element in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TStringsEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStringsEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TStringsEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TStringsEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStrings.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TStrings</var>. It  creates a <link id="TStringsEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface.
</descr>
<seealso>
<link id="TStringsEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TStream.ReadQWord">
<short>Read a QWord value from the stream and return its value</short>
<descr>
<var>ReadQWord</var> reads a <var>QWord</var> value (8 bytes) from the stream and
returns it's value.
</descr>
<errors>
If not enough bytes are available on the stream, an <link id="EStreamError"/>  exception will be
raised.
</errors>
<seealso>
<link id="TStream.Read"/>
<link id="TStream.WriteByte"/>
<link id="TStream.ReadWord"/>
<link id="TStream.ReadDWord"/>
<link id="TStream.ReadAnsiString"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TStream.WriteQWord">
<short>Write a QWord value to the stream</short>
<descr>
<var>WriteQWord</var> writes the word <var>W</var> (i.e. 8 bytes) to the
stream. This is a utility function which simply calls the <link
id="TStream.Write">Write</link> function.

The word can be read from the stream using the <link
id="TStream.ReadQWord">ReadQWord</link> function.
</descr>
<errors>
If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
<seealso>
<link id="TStream.Write"/>
<link id="TStream.ReadByte"/>
<link id="TStream.WriteWord"/>
<link id="TStream.WriteDWord"/>
<link id="TStream.WriteAnsiString"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TProxyStream
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TProxyStream">
<short>Proxy stream for the <var>IStream</var> interface</short>
<descr>
<var>TProxyStream</var> is a proxy class for the <link id="#rtl.types.IStream"/>
interface. It implements all stream methods by relaying them to the
<var>IStream</var> interface.
</descr>
<seealso>
<link id="#rtl.types.IStream"/>
<link id="TStreamAdapter"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TProxyStream.Create">
<short>Create a new instance of the <var>TProxyStream</var> class.</short>
<descr>
<var>Create</var> initializes a new instance of the <var>TProxyStream</var>
class. It saves <var>var</var> stream for use in the other methods.
</descr>
<seealso>
<link id="#rtl.types.IStream"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TProxyStream.Read" link="TStream.Read"/>
<element name="TProxyStream.Write" link="TStream.Write"/>
<element name="TProxyStream.Seek" link="TStream.Seek"/>

<element name="TProxyStream.Check">
<short>Check errors</short>
<descr>
<var>Check</var> will check the result of the <var>IStream</var> interface.
This method must be overridden by descendant classes to return
interface-specific errors.
</descr>
<seealso>
<link id="#rtl.types.IStream"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TReader.ReadSet">
<short>Read a set value from the stream</short>
<descr>
<var>ReadSet</var> reads a set of elements with type <var>EnumType</var> and
returns them as an integer where each element is encoded in a bit of the
integer. Thus, at most an enumerated type with 32 elements can be read with
this function.
</descr>
<errors>
No checking is performed on the validity of <var>EnumType</var>. It is
assumed to be a valid <var>PTypeInfo</var> pointer.
</errors>
<seealso>
<link id="TWriter.WriteSet"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteSet">
<short>Write a set value to the stream</short>
<descr>
<var>WriteSet</var> writes a set <var>Value</var> consisting of elements with type <var>EnumType</var>.
The set must be encoded as an integer where each element is encoded in a bit of the
integer. Thus, at most an enumerated type with 32 elements can be written with
this method.
</descr>
<errors>
No checking is performed on the validity of <var>EnumType</var>. It is
assumed to be a valid <var>PTypeInfo</var> pointer.
</errors>
<seealso>
<link id="TReader.ReadSet"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TComponentEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TComponentEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TComponent</var> class.</short>
<descr>
<var>TComponentEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TComponent"/> class, so the <var>TComponent</var>
 class can be used in a <var>for ... in</var> loop over the <link
 id="TComponent.Components"/> child components of the
 component. It is returned by the
 <link id="TComponent.GetEnumerator"/> method of <var>TComponent</var>.
</descr>
<seealso>
<link id="TComponent"/>
<link id="TComponent.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TComponentEnumerator.Create">
<short>Initialize a new instance of <var>TComponentEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TComponentEnumerator</var>
and keeps a reference to the component <var>AComponent</var> that will be enumerated.
</descr>
<seealso>
<link id="TComponent"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponentEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current <link id="TComponent"/> child
component instance in the enumerator.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TComponentEnumerator.MoveNext">MoveNext</link>
<link id="TComponent.Components"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponentEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the
children of the component.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next child in the components
child components, and returns <var>True</var> if this succeeded, or 
<var>False</var> if the pointer is past the last child in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TComponentEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TComponentEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TComponentEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TComponentEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TComponent.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TComponent</var>. It  creates a <link id="TComponentEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface. The enumerator enumerates all child components of the component
instance.
</descr>
<seealso>
<link id="TComponentEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TInterfaceListEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TInterfaceListEnumerator">
<short>Implements <var>IEnumerator</var> for the <var>TInterfaceList</var> class.</short>
<descr>
<var>TInterfaceListEnumerator</var> implements the <link id="#rtl.system.IEnumerator"/>
 interface for the <link id="TInterfaceList"/> class, so the <var>TInterfaceList</var>
 class can be used in a <var>for ... in</var> loop over the <link
 id="TInterfaceList.Components"/> child components of the
 component. It is returned by the
 <link id="TInterfaceList.GetEnumerator"/> method of <var>TInterfaceList</var>.
</descr>
<seealso>
<link id="TInterfaceList"/>
<link id="TInterfaceList.GetEnumerator"/>
<link id="#rtl.system.IEnumerator"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TInterfaceListEnumerator.Create">
<short>Initialize a new instance of <var>TInterfaceListEnumerator</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TInterfaceListEnumerator</var>
and keeps a reference to the component <var>AComponent</var> that will be enumerated.
</descr>
<seealso>
<link id="TInterfaceList"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceListEnumerator.GetCurrent">
<short>Return the current pointer in the list</short>
<descr>
<var>GetCurrent</var> returns the current interface in the <link id="TInterfaceList"/>
list.
</descr>
<errors>
No checking is done on the validity of the current position.
</errors>
<seealso>
<link id="TInterfaceListEnumerator.MoveNext">MoveNext</link>
<link id="TInterfaceList.Components"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceListEnumerator.MoveNext">
<short>Move the position of the enumerator to the next position in the
children of the component.</short>
<descr>
<var>MoveNext</var> puts the pointer on the next interface in the list,
and returns <var>True</var> if this succeeded, or 
<var>False</var> if the pointer is past the last interface in the list.
</descr>
<errors>
Note that if <var>False</var> is returned, calling <var>GetCurrent</var>
will result in an exception.
</errors>
<seealso>
<link id="TInterfaceListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceListEnumerator.Current">
<short>Current pointer in the list</short>
<descr>
<var>Current</var> redefines <link id="TInterfaceListEnumerator.GetCurrent">GetCurrent</link>
as a property.
</descr>
<seealso>
<link id="TInterfaceListEnumerator.GetCurrent">GetCurrent</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TInterfaceList.GetEnumerator">
<short>Create an <var>IEnumerator</var> instance</short>
<descr>
<var>GetEnumerator</var> is the implementation of the <link id="#rtl.system.IEnumerable">IEnumerable</link> 
interface for <var>TInterfaceList</var>. It  creates a <link id="TInterfaceListEnumerator"/> instance
and returns it's <link id="#rtl.system.IEnumerator">IEnumerator</link>
interface. The enumerator enumerates all interfaces in the list.
</descr>
<seealso>
<link id="TInterfaceListEnumerator"/>
<link id="#rtl.system.IEnumerator">IEnumerator</link>
<link id="#rtl.system.IEnumerable">IEnumerable</link> 
</seealso>
</element>


<!-- "class of" type Visibility: default -->
<element name="TDataModuleClass">
<short>Class pointer for <var>TDataModule</var></short>
<descr>
<var>TDataModuleClass</var> defines the class pointer for <link
id="TDataModule"/>.
</descr>
<seealso>
<link id="TDataModule"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TObjectTextEncoding">
<short>Encoding of the object text file</short>
<descr>
<var>TObjectTextEncoding</var> is an enumerated type which denotes the
encoding of non ascii characters in an object stream file. It is needed for
correct encoding when reading string values in the text stream.
</descr>
<seealso>
<link id="ObjectTextToBinary"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TObjectTextEncoding.oteDFM">
<short>Characters are in DFM (Delphi) format: widechar encoded.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TObjectTextEncoding.oteLFM">
<short>Characters are in LFM format: UTF-8 encoded.</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TExceptionClass">
<short>Class of <link id="#rtl.sysutils.Exception">Exception</link></short>
<descr>
<var>TExceptionClass</var> is the class pointer for the <link
id="#rtl.sysutils.Exception">Exception</link> class, defined in the <link
id="#rtl.sysutils">SysUtils</link> unit.
</descr>
<seealso>
<link id="#rtl.sysutils.Exception">Exception</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStringList.OwnsObjects">
<short>Determines whether the stringlist owns it's objects or not.</short>
<descr>
<var>OwnsObjects</var> can be set to <var>true</var> to let the stringlist
instance own the objects in the list: if an element is removed from the
list, the associated object (if there is any) will be freed as well. The
same is true if the list is cleared or destroyed.
</descr>
<seealso>
<link id="TStrings.Objects"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IVCLComObject
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IVCLComObject">
<short>Com automation Object interface</short>
<descr>
<var>IVCLComObject</var> is used by TComponent to implement the <var>IUnknown</var> 
interface used by COM automation servers. Partially, it is the translation to pascal 
of the <var>IDispatch</var> interface definition by Microsoft. If
<var>TComponent</var> needs to return an <var>IUnknown</var> interface, it
creates a <var>IVCLComObject</var> interface instead.
</descr>
<seealso>
<link id="TComponent.VCLComObject"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IVCLComObject.GetTypeInfoCount">
<short>The IDispatch:GetTypeInfoCount call for automation servers</short>
<descr>
<var>GetTypeInfoCount</var> must return in <var>Count</var> either 0 or 1 to
indicate that it provides type information (1) or not (0).
</descr>
<errors>
On error, a nonzero (different from S_OK) return value must be returned.
</errors>
<seealso>
<link id="IVCLComObject.GetTypeInfo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IVCLComObject.GetTypeInfo">
<short>The IDispatch:GetTypeInfo call for automation servers</short>
<descr>
<var>GetTypeInfo</var> must return the <var>Index</var>-th entry in the type
information of the component in <var>TypeInfo</var>. The <var>LocaleID</var>
argument can be used to indicate the locale of the caller, as different type
information can be returned depending on the locale.
</descr>
<errors>
On error, a nonzero (different from S_OK) return value must be returned.
</errors>
<seealso>
<link id="IVCLComObject.GetTypeInfoCount"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IVCLComObject.GetIDsOfNames">
<short>The <var>IDispatch:GetIDsOfNames</var> call for automation servers.</short>
<descr>
<var>GetIDsOfNames</var> must return in <var>DispIDs</var> the dispatch Ids for the
<var>NameCount</var> names of the methods listed in <var>Names</var>. The
<var>LocaleID</var> indicates the locale of the caller.
</descr>
<errors>
On error, a nonzero (different from S_OK) return value must be returned.
</errors>
<seealso>
<link id="IVCLComObject.Invoke"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IVCLComObject.Invoke">
<short>The <var>IDispatch:Invoke</var>  call for automation servers.</short>
<descr>
<p>
<var>Invoke</var> must invoke the method designated by <var>DispID</var>.
<var>IID</var> can be ignored. <var>LocaleID</var> is used by the caller to
indicate the locale it is using. The <var>Flags</var> argument describes the
context in which <var>Invoke</var> is called: a method, or property
getter/setter. The <var>Params</var> argument contains the parameters to the
call. The result should be in <var>VarResult</var>. On error,
<var>ExcepInfo</var> and <var>ArgError</var> should be filled. 
</p>
<p>The function should return 0 (<var>S_OK</var>) if all went well.</p>
</descr>
<seealso>
<link id="IVCLComObject.GetIDsOfNames"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IVCLComObject.SafeCallException">
<short>This method can be invoked if an exception occurs during <var>Invoke</var></short>
<descr>
<var>SafeCallException</var> is called to handle an exception during
invocation of the <var>Invoke</var> method. The <var>TObject</var>
implementation of this method returns <var>E_UNEXPECTED</var>.
</descr>
<seealso>
<link id="IVCLComObject.Invoke"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IVCLComObject.FreeOnRelease">
<short>Is called by TComponent.FreeOnRelease</short>
<descr>
<var>FreeOnRelease</var> is called by <link id="TComponent.FreeOnRelease"/>
for the <var>IVCLComObject</var> interface implemented by
<var>TComponent</var>.
</descr>
<seealso>
<link id="TComponent.FreeOnRelease"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TComponent.ComObject">
<short>Interface reference implemented by the component</short>
<descr>
<var>ComObject</var> returns the COM interface represented by the component.
If the component does not represent a COM interface, reading this property
will raise an <link id="EComponentError"/>.
</descr>
<seealso>
<link id="EComponentError"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="CreateVCLComObjectProc">
<short>Called to create an instance of <var>IVCLComObject</var></short>
<descr>
<var>CreateVCLComObjectProc</var> is called by <var>TComponent</var> if it
needs to create a <var>IVCLComObject</var> interface for itself (when the
<var>ComObject</var> property is read). It passes itself as the <var>Component</var> parameter.
</descr>
<seealso>
<link id="IVCLComObject"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="SGUIDObserved">
<short>Observed interface GUID as a string</short>
</element>

<!-- constant Visibility: default -->
<element name="SGUIDObserver">
<short>Observer interface GUID as a string</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TFPObservedOperation">
<short>Operation which is reported to an observer</short>
<descr>
<var>TFPObservedOperation</var> enumerates the possible operations that can be reported to an observer.
Which of these operations is reported depends on the implementation of the observed object.
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserver"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPObservedOperation.ooChange">
<short>The observed object has changed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPObservedOperation.ooFree">
<short>The observed object is being freed.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPObservedOperation.ooAddItem">
<short>An item is added to the observed object (generally a list).</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPObservedOperation.ooDeleteItem">
<short>An item is deleted from the observed object (generally a list).</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPObservedOperation.ooCustom">
<short>Custom event.</short>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IFPObserved
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IFPObserved">
<short>Interface implemented by an object that can be observed.</short>
<descr>
<p>
<var>IFPObserved</var> is an interface which can be implemented in objects that must be observable. 
Objects that wish to observe the object can register themselves with the
<link id="FPOAttachObserver"/> call, and must be detached using the <link
id="FPODetachObserver"/> call.
</p>
<p>
This interface is not reference counted, so care must be taken that the
<var>ooFree</var> message is sent with <link id="FPONotifyObservers"/> 
when the object is freed.
</p>
</descr>
<seealso>
<link id="FPONotifyObservers"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IFPObserved.FPOAttachObserver">
<short>Attach a new observer to the object</short>
<descr>
<p>
<var>FPOAttachObserver</var> must be called with an object instance <var>AObserver</var> that implements
the <link id="IFPObserver"/> interface. The <link id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link> 
method of the interface will be called whenever <link id="FPONotifyObservers"/>
is used to notify observers of a change. Objects implementing this interface
should check that <var>AObserver</var> actually implements the <link id="IFPObserver"/> interface.
</p>
<p>
Do not make assumptions on how the interface behaves if <var>FPOAttachObserver</var>
is called more than once with the same interface. It may add the object
to the list of observers unconditionally (in which case it will be notified twice) or it
may check that it is not yet in the list.
</p>
</descr>
<errors>
If <var>AObserver</var> does not implement the <link id="IFPObserver"/>
interface, an <link id="EObserver"/> exception must be raised. 
No other errors should be raised, other than a possible out of memory error.
</errors>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link>
<link id="FPONotifyObservers"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IFPObserved.FPODetachObserver">
<short>Remove an observer from the list of observers.</short>
<descr>
<p>
<var>FPODetachObserver</var> removes the <var>AObserver</var> object from the list of
observers. If it was not in the list, then this is silently accepted.
Once removed, it will no longer receive notifications when <link
id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link> is called.
</p>  
<p>
If the object was added more than once using <link id="FPOAttachObserver"/>, 
then it depends on the implementor of the interface whether or <var>FPODetachObserver</var> must be called an equal
number of times.
</p>
</descr>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link>
<link id="FPONotifyObservers"/>
<link id="FPOAttachObserver"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IFPObserved.FPONotifyObservers">
<short>Notify all observers</short>
<descr>
<p>
<var>FPONotifyObservers</var> notifies all observers of the object that a
change has occurred. It calls <link id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link>
on the <link id="IFPObserver"/> interface of all attached objects, and
passes on <var>ASender</var> (normally this is <var>Self</var>),
<var>AOperation</var> and <var>Data</var>. What <var>Data</var> is, depends on the
implementor of the interface.
</p>
<p>
There is no guaranteed order in which the change notifications are delivered
to the observers. This is an implementation-specific detail, which should
not be relied upon in any way.
</p>
</descr>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserver.FPOObservedChanged">FPOObservedChanged</link>
<link id="FPODetachObserver"/>
<link id="FPOAttachObserver"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.IFPObserver
  ********************************************************************
-->

<!-- interface Visibility: default -->
<element name="IFPObserver">
<short>Interface for an object to observe other objects.</short>
<descr>
<var>IFPObserver</var> is the interface an object must implement if it
wishes to receive change notifications from another object. The presence of
this interface will be checked when the object registers itself using
<link id="IFPObserver.FPOAttachObserver"/>. The change notifications arrive
because the <link id="FPOObservedChanged"/> method is called by the observed
object.
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserved.FPOAttachObserver">FPOAttachObserver</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="IFPObserver.FPOObservedChanged">
<short>Entry point for change notifications</short>
<descr>
<var>FPOObservedChanged</var> is the method that is called by an observed
object (<link id="IFPObserved"/>) when it calls <link id="IFPObserved.FPONotifyObservers">FPONotifyObservers</link>
The <var>Sender</var> is the object under observation, the
<var>Operation</var> and <var>Data</var> are the parameters used in the call
to <var>FPONotifyObservers</var>. 
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserved.FPONotifyObservers">FPONotifyObservers</link>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.EObserver
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="EObserver">
<short>Error raised when an observer error occurs</short>
<descr>
<var>EObserver</var> is an error that is raised when an object is registered
as an observer, and it does not implement the <link id="IFPObserver"/>
interface.
</descr>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserved.FPOAttachObserver"/>
</seealso>
</element>

<!-- enumeration type Visibility: public -->
<element name="TFPList.TDirection">
<short>Search direction for IndexOfItem</short>
<descr>
<var>TFPList.TDirection</var> is used to indicate where the <link id="TFPList.IndexOfItem"/>
search algorithm starts it search: at the beginning of the list or at the
end of the list.
</descr>
<seealso>
<link id="TFPList.IndexOfItem"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPList.TDirection.FromBeginning">
<short>Start search at the beginning</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TFPList.TDirection.FromEnd">
<short>Start search at the end.</short>
</element>

<!-- function Visibility: public -->
<element name="TFPList.IndexOfItem">
<short>Search an item in the list</short>
<descr>
<p>
<var>IndexOfItem</var> has the same function as the <link id="IndexOf"/>
function: it searches for <var>Item</var> in the list, and returns the index
of the first found matching pointer. If none is found, -1 is returned. 
</p>
<p>In difference with the <var>IndexOf</var> function, it accepts a parameter
<var>Direction</var> indicating the search direction: from the beginning of
the list till the end of the list, or from the end of the list till the
beginning. The <var>IndexOf</var> function starts at the beginning of the
list. The search direction is only important if the item can appear multiple
times in the list.
</p>
</descr>
<seealso>
<link id="TFPList.TDirection"/>
<link id="TFPList.IndexOf"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TList.FPOAttachObserver">
<short>Add an observer to the list of observers</short>
<descr>
<var>FPOAttachObserver</var> is part of the implementation of the <link id="IFPObserved"/> interface in <var>Tlist</var>.
It adds a new observer to the list of observers. Calling this multiple times will add the observed object multiple times 
to the list.
</descr>
<errors>
An <var>EObserver</var> exception may be raised if <var>AObject</var> does not implement the
<link id="IFPObserver"/> interface.
</errors>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserved.FPOAttachObserver"/>
<link id="IFPObserved"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TList.FPODetachObserver">
<short>Remove an observer from the list of observers</short>
<descr>
<var>FPODetachObserver</var> is part of the implementation of the <link id="IFPObserved"/> interface in <var>Tlist</var>.
It removes the first found instance of the observer from the list of observers.
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserved.FPODetachObserver"/>
<link id="IFPObserver"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TList.FPONotifyObservers">
<short>Notify observers of changes in the list</short>
<descr>
<p>
<var>FPONotifyObservers</var> is called to notify observers of changes in the list.
The following notifications are sent:
</p>
<dl>
<dt>ooAddItem</dt><dd>when a pointer is added. <var>Data</var> is the pointer that is added.</dd>
<dt>ooDeleteItem</dt><dd>when a pointer is deleted or extracted. <var>Data</var> is the pointer that is deleted or extracted.</dd>
<dt>ooChange</dt><dd>called when 2 pointers are exchanged.</dd>
<dt>ooFree</dt><dd>Called when the list is freed.</dd>
</dl>
</descr>
<seealso>
<link id="FPODetachObserver"/>
<link id="FPOAttachObserver"/>
<link id="Add"/>
<link id="Exchange"/>
<link id="Delete"/>
<link id="Extract"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TPersistent.FPOAttachObserver">
<short>Add an observer to the list of observers.</short>
<descr>
<var>FPOAttachObserver</var> is part of the implementation of the <link id="IFPObserved"/> interface in <var>TPersistent</var>.
It adds a new observer to the list of observers. Calling this multiple times will add the observed object multiple times 
to the list.
</descr>
<errors>
An <var>EObserver</var> exception may be raised if <var>AObject</var> does not implement the <link id="IFPObserver"/> interface.
</errors>
<seealso>
<link id="IFPObserver"/>
<link id="IFPObserved.FPOAttachObserver"/>
<link id="IFPObserved"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TPersistent.FPODetachObserver">
<short>Remove an observer from the list of observers</short>
<descr>
<var>FPODetachObserver</var> is part of the implementation of the <link id="IFPObserved"/> interface in <var>TPersistent</var>.
It removes the first found instance of the observer from the list of observers.
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserved.FPODetachObserver"/>
<link id="IFPObserver"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TPersistent.FPONotifyObservers">
<short>Notify observers of changes.</short>
<descr>
<p>
<var>FPONotifyObservers</var> can be called to notify observers of changes
in the object. This method simply passes on the parameters that it receives 
to all attached <link id="IFPObserver"/> interfaces.
</p>
<p>
<var>TPersistent</var> does not call <var>FPONotifyObservers</var>. 
It is implemented for the benefit of descendant classes.
</p>
</descr>
<seealso>
<link id="IFPObserved"/>
<link id="IFPObserved.FPONotifyObservers"/>
<link id="IFPObserver"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TStrings.AddText">
<short>Add text to the string list.</short>
<descr>
<var>AddText</var> adds <var>S</var> to the strings. It is identical in
function to setting <link id="Text"/> but does not clear the list of
strings first: <var>S</var> is split into lines, and each line is added to
the list.
</descr>
<seealso>
<link id="TString.Text"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.Classes.TBytesStream
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TBytesStream">
<short>Stream of bytes</short>
<descr>
<var>TBytesStream</var> is a stream that uses an array of byte (<link id="TBytes"/>) to keep the stream data.
it overrides the <link id="TMemoryStream"/> memory allocation routine to use
the array of bytes. The array of bytes is exposed through the <link id="Bytes"/> property.
</descr>
<seealso>
<link id="TBytes"/>
<link id="TMemoryStream"/>
<link id="Bytes"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TBytesStream.Create">
<short>Create a new instance of the stream, initializing it with an array of bytes</short>
<descr>
<var>Create</var> creates a new instance and initializes the memory with the data in <var>ABytes</var>.
</descr>
<seealso>
<link id="TBytes"/> 
<link id="TMemoryStream"/>
<link id="Bytes"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TBytesStream.Bytes">
<short>The stream data as an array of bytes.</short>
<descr>
<var>Bytes</var> provides byte-sized access to the array of bytes that represent the stream data.
As a pointer value, it equals <link id="TCustomMemoryStream.Memory"/>,
meaning that <var>Memory</var> points to the first byte in the array.
</descr>
<seealso>
<link id="TBytes"/>
<link id="TMemoryStream"/>
<link id="TCustomMemoryStream.Memory"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteStr">
<short>Write a string to the binary stream</short>
<descr>
<var>WriteStr</var> writes a string value to the binary stream. It is
exposed so it can be used in <var>DefineProperties</var>.
</descr>
</element>

<!--
  ********************************************************************
    #rtl.Classes.EThreadExternalException
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="EThreadExternalException">
<short>Exception raised when an invalid operation is attempted on an
external thread</short>
<descr>
<var>EThreadExternalException</var> is raised by for example <link id="TThread.CheckTerminated"/>
and <link id="TThread.SetReturnValue"/> when the thread was not created by
the Free Pascal program, but by an external code base (for example a DLL, or
the calling application in a DLL).
</descr>
<errors>
</errors>
<seealso>
<link id="TThread.CheckTerminated"/>
<link id="TThread.SetReturnValue"/>
</seealso>
</element>


<!-- record type Visibility: public -->
<element name="TThread.TSystemTimes">
<short>Record for returning processor usage</short>
<descr>
<var>TThread.TSystemTimes</var> is used in <link id="TThread.GetSystemTimes"/>
to report processor usage. The fields are in microseconds.
</descr>
<seealso>
<link id="TThread.GetSystemTimes"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TThread.TSystemTimes.IdleTime">
<short>Processor idle time</short>
</element>

<!-- variable Visibility: default -->
<element name="TThread.TSystemTimes.UserTime">
<short>User code execution time</short>
</element>

<!-- variable Visibility: default -->
<element name="TThread.TSystemTimes.KernelTime">
<short>Kernel (OS) code execution time</short>
</element>

<!-- variable Visibility: default -->
<element name="TThread.TSystemTimes.NiceTime">
<short>Nice (reduced priority) code execution time</short>
</element>

<!-- class function Visibility: public -->
<element name="TThread.CreateAnonymousThread">
<short>Execute code in an anonymous thread</short>
<descr>
<p>
<var>CreateAnonymousThread</var> will create an instance of a <var>TThread</var> descendant
and calls <var>aProc</var> in this procedure. This can be used to quickly
execute a method in another thread without having to expliticly declare a thread for
such purposes. It returns the created <var>TThread</var> instance, which can
be checked for termination etc.
</p>
<p>
Note that this method differs slightly from Delphi in that FPC does not yet support anonymous
methods, so the signature of <var>aProc</var> differs slightly.
</p>
</descr>
<seealso>
<link id="TThread.CheckTerminated"/>
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.NameThreadForDebugging">
<short>Set a thread name</short>
<descr>
<p>
<var>NameThreadForDebugging</var> sets the name of thread
<var>aThreadID</var> to <var>aThreadName</var>. The thread name can be
unicode or ansistring. This is mainly useful for debugging purposes, as
thread names are more easily recognizable than IDs.
</p>
<p>
Note that this requires OS support. 
Currently this is not implemented for any FPC platform and is supported for
Delphi compatibility only.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.SetReturnValue">
<short>Set return value of a thread</short>
<descr>
<var>TThread.SetReturnValue</var> sets the return value of an internally
created thread.
</descr>
<errors>
If the thread was not created by the FPC program, an <link
id="EThreadExternalException"/> exception is raised.
</errors>
<seealso>
<link id="EThreadExternalException"/> 
<link id="TThread.CheckTerminated"/>
</seealso>
</element>

<!-- class function Visibility: public -->
<element name="TThread.CheckTerminated">
<short>Check if the current thread has finished executing.</short>
<descr>
<var>TThread.CheckTerminated</var> can be used to check if the current
thread has finished executing (i.e. <var>Execute</var> has finished. 
This can be called from methods in other classes where the current thread instance is not available.
</descr>
<errors>
If the thread was not created by the FPC program, an <link
id="EThreadExternalException"/> exception is raised.
</errors>
<seealso>
<link id="EThreadExternalException"/> 
<link id="TThread.SetReturnValue"/>
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.Queue" alwaysvisible="1">
<short>Queue a method for execution in the main thread</short>
<descr>
<p>
<var>Queue</var> schedules a method <var>aMethod</var> for execution in the
main thread. In difference with <link id="TThread.Synchronize"/>,
<var>Queue</var> just posts the method for execution in a queue, and 
does not wait for it to be executed, so this call returns at once.
</p>
<p>
In the class procedure overloaded version of this call, the thread for which the method must be
posted is the first argument. In the protected version of this call (used in
the tthread instance), this argument is not there, and the thread instance
is used.
</p>
<p>
When a thread finishes it's execution, all its queued calls are removed from
the queue list.
</p>
</descr>
<seealso>
<link id="TThread.Synchronize"/>
<link id="TThread.RemoveQueuedEvents"/> 
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.RemoveQueuedEvents">
<short>Remove methods scheduled for execution from queue</short>
<descr>
<var>RemoveQueuedEvents</var> removes methods from the list of methods
waiting for execution in the main thread. If only <var>aThread</var> is
specified, all methods scheduled for execution by that thread are removed.
If only <var>aMethod</var> is specified, then all calls to that method are
removed, regardless of the thread. If both arguments are specified, then
all calls to the given method by the given thread are removed.
</descr>
<seealso>
<link id="TThread.Synchronize"/>
<link id="TThread.Queue"/>
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.SpinWait">
<short>Prevent thread execution in a spin-wait loop</short>
<descr>
<p>
<var>SpinWait</var> blocks the execution of the thread in a spin-wait loop:
it simply executes some simple instructions.
</p>
<p>
This can be used to create short time delays without an immediate thread
switch (e.g. <link id="SysUtils.Sleep"/> can cause a thread switch).
The input parameter (aIterations) specifies the number of spin loops. 
</p>
</descr>
<seealso>
<link id="SysUtils.Sleep"/>
<link id="TThread.Sleep"/>
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.Sleep">
<short>Prevent thread execution</short>
<descr>
<p>
<var>Sleep</var> blocks the execution of the thread for
<var>aMilliseconds</var>.
This function simply calls <link id="sysutils.sleep"/>
</p>
<p>
In difference with <link id="TThread.SpinWait"/>, a thread switch may occur
during the sleep.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="SysUtils.Sleep"/>
<link id="TThread.SpinWait"/> 
</seealso>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.Yield">
<short>Yield execution to other threads</short>
<descr>
<var>TThread.Yield</var> yields the processor to other threads. It can be
called from methods outside the thread class itself.
</descr>
</element>

<!-- class procedure Visibility: public -->
<element name="TThread.GetSystemTimes">
<short>Return CPU stats</short>
<descr>
<var>GetSystemTimes</var> is provided for Delphi compatibility only, it
currently returns empty values only.
</descr>
<seealso>
<link id="TSystemTimes"/>
</seealso>
</element>

<!-- class function Visibility: public -->
<element name="TThread.GetTickCount">
<short>Return tick count (32-bit)</short>
<descr>
<var>GetTickCount</var> is deprecated and should not be used. Use <link
id="TThread.GetTickCount64"/> instead.
</descr>
<seealso>
<link id="TThread.GetTickCount64"/>
</seealso>
</element>

<!-- class function Visibility: public -->
<element name="TThread.GetTickCount64">
<short>Return tick count (64-bit)</short>
<descr>
<var>GetTickCount64</var> simply calls <link id="SysUtils.GetTickCount64"/>
and is implemented for Delphi compatibility only.
</descr>
<seealso>
<link id="SysUtils.GetTickCount64"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThread.CurrentThread">
<short>Return current thread instance</short>
<descr>
<p>
<var>TThread.CurrentThread</var> can be used to get the current thread instance. 
This is useful in code that is not inside a TThread implementation, but
which needs access to the current thread.
</p>
<p>
For threads that were created outside of FPC code (DLLs or a calling
program) this will return a dummy TThread instance.
</p>
</descr>
<seealso>
<link id="TThread.ExternalThread"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThread.ProcessorCount">
<short>Return the processor count for this system</short>
<descr>
<p>
<var>ProcessorCount</var> returns the processor count for this system.
</p>
<p>
Whether this is the number of cores or the number of CPUs present in the
hardware, is deliberately unspecified. The number of cores can also vary
during the lifetime of the program, and the FPC implementation does not
guarantee that this will always match, the value is set at program start.
</p>
<p>
As such, the number specified should only be used as an indication of how
many threads can be executed at once by the system.
</p>
</descr>
<seealso>
<link id="TThread.IsSingleProcessor"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThread.IsSingleProcessor">
<short>Is the current system single processor or not</short>
<descr>
<var>Thread.IsSingleProcessor</var> returns <var>True</var> if <link
id="TThread.ProcessorCount"/> is less than or equal to 1, <var>False</var> otherwise.
</descr>
<seealso>
<link id="TThread.ProcessorCount"/> 
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThread.ExternalThread">
<short>Is the thread instance an external thread ?</short>
<descr>
<var>ExternalThread</var> returns <var>True</var> if the thread is an
externally created thread. If the thread was created by the FPC program,
this returns <var>False</var>. This is useful for examining instances returned
by <link id="TThread.CurrentThread"/>.
</descr>
<seealso>
<link id="TThread.CurrentThread"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TThread.Finished">
<short>Has the thread finished executing</short>
<descr>
<var>Finished</var> is <var>True</var> when <link id="TThread.Execue"/> has
finished executing, but the thread is still cleaning up (calling
OnTerminate, etc).
</descr>
<seealso>
<link id="TThread.Execue"/>
<link id="TThread.OnTerminate"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStrings.LineBreak">
<short>LineBreak character to use</short>
<descr>
<var>LineBreak</var> is the character used to separate lines when reading or
writing  <link id="TStrings.Text"/>, and it is also used when reading from file.
</descr>
<seealso>
<link id="TStrings.Text"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStrings.SkipLastLineBreak">
<short>Do not add a linebreak to the last item</short>
<descr>
<var>SkipLastLineBreak</var> can be set to <var>True</var> to omit a
linebreak character after the last string in the  <link
id="TStrings.Text"/>. This also means when writing to file, that the file
will not have a terminating linebreak character.
</descr>
<seealso>
<link id="TStrings.LineBreak"/>
<link id="TStrings.Text"/>
</seealso>
</element>

<!-- enumeration type Visibility: default -->
<element name="TStringsSortStyle">
<short>Determines how the strings are sorted</short>
<descr>
<p>
<var>TStringsSortStyle</var> is the type used in the <link id="TStringList.SortStyle"/>
property, and describes how the strings are sorted when the <link id="TStringList.Sorted"/> 
property is <var>True</var>. It has the following values:
</p>
<dl>
<dt>sslNone</dt><dd><printshort id="TStringsSortStyle.sslNone"/></dd>
<dt>sslUser</dt><dd><printshort id="TStringsSortStyle.sslUser"/></dd>
<dt>sslAuto</dt><dd><printshort id="TStringsSortStyle.sslAuto"/></dd>
</dl>
</descr>
<seealso>
<link id="TStringList.Sorted"/>
<link id="TStringList.SortStyle"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStringsSortStyle.sslNone">
<short>The strings are not sorted</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStringsSortStyle.sslUser">
<short>The strings are kept sorted by the user.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TStringsSortStyle.sslAuto">
<short>The <var>TStrings</var> instance keeps the strings sorted.</short>
</element>

<!-- set type Visibility: default -->
<element name="TStringsSortStyles">
<short>Set of <var>TStringsSortStyle</var></short>
<descr>
<var>TStringsSortStyles</var> is the set type for enumeration <link id="TStringsSortStyle"/>.
</descr>
<seealso>
<link id="TStringsSortStyle"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TStringList.SortStyle">
<short>Sort style for strings</short>
<descr>
<p>
<var>SortStyle</var> sets the sort style for the <var>TStringList</var> instance.
Setting it to <var>sslAuto</var> will keep the list sorted automatically at all times.
</p>
<p>
<link id="TstringList.Find">Find</link> (and hence <link id="TStrings.IndexOf">IndexOf</link>) will use
a binary search if <var>SortStyle</var> differs from <var>sslNone</var>. if
<var>SortStyle</var> is <var>sslNone</var>, then it will raise an exception.
</p>
</descr>
<seealso>
<link id="TStringsSortStyle"/>
<link id="TStrings.Sorted"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TStream.WriteDescendent">
<short>Write descendent of a component</short>
<descr>
<var>WriteDescendent</var> will create a <link id="TWriter"/> writer class and write <var>Instance</var> as a descendent of <var>Ancestor</var>
using the writer. This is used to create diff streams: only the properties
where <var>Instance</var> differs from <var>Ancestor</var> are written to the stream.
</descr>
<seealso>
<link id="TWriter.WriteDescendent"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TStream.WriteDescendentRes">
<short>Write descendent of a component as resource</short>
<descr>
<var>WriteDescendentRes</var> calls <var>WriteDescendent</var> as a resource stream.
</descr>   
<seealso> 
<link id="TWriter.WriteDescendent"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectReader.ReadSignature">
<short>Read resource signature</short>
<descr>
<var>ReadSignature</var> reads the streaming signature from a stream. 
This method does nothing. 
It must be implemented by descendents that have a signature header in the stream.
(such as binary streams)
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteSignature"/>
<link id="TBinaryObjectReader.ReadSignature"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectReader.ReadSignature">
<short>Reads the filer signature</short>
<descr>
<var>ReadSignature</var> is overridden by <var>TBinaryObjectReader</var> to
read the signature (<var>TPF0</var>) from binary streams.
</descr>
<errors>
If the stream does not start with the correct signature, an <link
id="EReadError"/> exception is raised.
</errors>
<seealso>
<link id="TAbstractObjectReader.ReadSignature"/>
<link id="TAbstractObjectWriter.WriteSignature"/>
<link id="TBinaryObjectWriter.WriteSignature"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TReader.ReadSignature">
<short>Read stream signature from the stream</short>
<descr>
<var>ReadSignature</var> is called when starting to read a root component from a stream.
Some streams contain a signature (header) to detect whether the stream contains correct data.
</descr>
<errors>
If the stream does not start with the correct signature, an <link
id="EReadError"/> exception
will be raised.
</errors>
<seealso>
<link id="TAbstractObjectReader.ReadSignature"/>
<link id="TAbstractObjectWriter.WriteSignature"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAbstractObjectWriter.WriteSignature">
<short>Write stream signature to the stream</short>
<descr>
<var>WriteSignature</var> writes the streaming signature to a stream.
This method does nothing, it must be implemented by descendents that have a signature header in the stream.
(such as binary streams)
</descr>
<seealso>
<link id="TAbstractObjectReader.ReadSignature"/>
<link id="TBinaryObjectWriter.WriteSignature"/>   
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TBinaryObjectWriter.WriteSignature">
<short>Write stream signature to the stream</short>
<descr>
<var>WriteSignature</var> is overridden by <var>TBinaryObjectWriter</var> to
write the signature (<var>TPF0</var>) to binary streams.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteSignature"/>
<link id="TAbstractObjectReader.ReadSignature"/>
<link id="TBinaryObjectReader.ReadSignature"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteDescendent">
<short>Write descendent to stream</short>
<descr>
<var>WriteDescendent</var> writes <var>ARoot</var> as a descendent of <var>AAncestor</var>
This is used to create diff streams: only the properties where <var>ARoot</var> differs from
<var>AAncestor</var> are written to the stream.
</descr>
<seealso>
<link id="TStream.WriteDescendent"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TWriter.WriteSignature">
<short>Write a signature to the stream</short>
<descr>
<var>WriteSignature</var> writes the streaming signature (if any) to a stream.
It is called once, at the start of writing the root component to a stream.
</descr>
<seealso>
<link id="TAbstractObjectWriter.WriteSignature"/>
<link id="TBinaryObjectWriter.WriteSignature"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadReportStatus">
<short>Thread status report callback prototype</short>
<descr>
<var>TThreadReportStatus</var> is the callback prototype for the <link id="TThread.ExecuteInThread"/> method.
This callback is used to report thread status to the main thread: the <var>Status</var> string can be used to 
report the status of thread execution.
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadExecuteStatusHandler"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadStatusNotifyEvent">
<short>Signature of thread status report event handler</short>
<descr>
<p>
<var>TThreadStatusNotifyEvent</var> is the signature of the method to be provided
when executing something in a thread using <link id="TThread.ExecuteInThread"/>
when status reporting is required.
</p>
<p>
This event handler will be called in the main thread. When called, it has the
thread whose status is reported in <var>Sender</var>, and the status message
in <var>ReportStatus</var> is passed to the method. 
</p>
<p>
Note that the thread reporting its status is blocked while the callback is being handled: 
The status is be reported to the main thread using <link id="TThread.synchronize"/>.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadReportStatus"/>
<link id="TThreadExecuteStatusHandler"/>
</seealso>

</element>

<!-- alias type Visibility: default -->
<element name="TThreadExecuteHandler">
<short>Signature of method to execute in a thread, without status reporting</short>
<descr>
<p>
<var>TThreadExecuteHandler</var> is the signature of the method to be used
when executing something in a thread using <link id="TThread.ExecuteInThread"/>
when no status reporting is required.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadReportStatus"/>
<link id="TThreadStatusNotifyEvent"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadExecuteStatusHandler">
<short>Signature of method to execute in a thread, with status reporting</short>
<descr>
<p>
<var>TThreadExecuteStatusHandler</var> is the signature of the method to be used
when executing something in a thread using <link id="TThread.ExecuteInThread"/>
when status reporting is required.
</p>
<p>
On entry in the method, <var>ReportStatus</var> is passed to the method, and the
method can call <var>ReportStatus</var> at various stages to report about
the status of the method: The status will be reported to the main thread
using <link id="TThread.synchronize"/>, and calls <var>ReportStatus</var>
will be blocked as long as the status was not reported.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadReportStatus"/>
<link id="TThreadStatusNotifyEvent"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TNotifyCallBack">
<short>Thread termination callback handler</short>
<descr>
<var>TNotifyCallBack</var> is used to notify about thread termination when using static callbacks.
When called, the <var>Sender</var> will contain the thread which is
terminating, and <var>AData</var> is the <var>AData</var> parameter passed
to <link id="TThread.ExecuteInThread"/>.
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThread"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadStatusNotifyCallBack">
<short>Signature of thread status report callback</short>
<descr>
<p>
<var>TThreadStatusNotifyCallBack</var> is the signature of the callback to be provided
when executing a static procedure in a thread using <link id="TThread.ExecuteInThread"/>
when status reporting is required.   
</p>
<p>
This callback will be called in the main thread. When called, it has the
thread whose status is reported in <var>Sender</var>, 
<var>AData</var> is the <var>AData</var> parameter passed to <link id="TThread.ExecuteInThread"/>.
Finally, the status message in <var>ReportStatus</var> is passed to the callback.
</p>
<p>
Note that the thread reporting its status is blocked while the callback is
being handled: The status is be reported to the main thread using <link id="TThread.synchronize"/>.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadReportStatus"/>
<link id="TThreadExecuteStatusHandler"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadExecuteCallBack">
<short>Signature of procedure to execute in a thread, without status reporting</short>
<descr>
<p>
<var>TThreadExecuteCallBack</var> is the signature of the static procedure to be used
when executing something in a thread using <link id="TThread.ExecuteInThread"/>
when no status reporting is required.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/>
<link id="TThreadReportStatus"/>
<link id="TThreadStatusNotifyEvent"/>
<link id="TThreadExecuteStatusCallBack"/>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadExecuteStatusCallBack">
<short>Signature of procedure to execute in a thread, with status reporting</short>
<descr>
<p>
<var>TThreadExecuteStatusCallBack</var> is the signature of a procedure to be used
when executing something in a thread using <link id="TThread.ExecuteInThread"/>
when status reporting is required.
</p>
<p>
On entry in the method, <var>AData</var> is the <var>AData</var> parameter passed to <link id="TThread.ExecuteInThread"/>. 
<var>ReportStatus</var> is passed to the method, and the threaded procedure can call <var>ReportStatus</var> 
at various stages to report about the status of the method: The status will be reported to the main thread
using <link id="TThread.synchronize"/>, so calls to <var>ReportStatus</var> will be blocked as long as the 
status was not reported.
</p>
</descr>
<seealso>
<link id="TThread.ExecuteInThread"/> 
<link id="TThreadReportStatus"/>
<link id="TThreadStatusNotifyCallback"/>
</seealso>
</element>

<!-- class function Visibility: public -->
<element name="TThread.ExecuteInThread">
<short>Execute a method or static procedure in a thread</short>
<descr>
<p>
<var>TThread.ExecuteInThread</var> is a class method which allows to quickly
execute a method or procedure in a thread. The method or procedure to be
executed is passed in <var>Method</var>, this can be a method or a plain
(static) procedure.
</p>
<p>
The caller can be notified of thread termination: In the optional argument <var>AOnTerminate</var> a
callback (procedure or method, depending on the signature) can be specified that will be called when 
the thread terminated. This callback is executed in the main thread.
</p>
<p> 
The signature of <var>AMethod</var> determines whether status reporting is enabled or not. 
If the method of type <link id="TThreadExecuteStatusHandler"/> or <link id="TThreadExecuteStatusCallback"/>, 
then an extra <var>AOnStatus</var> callback must be specified. This callback
will be called in the main thread whenever the thread wishes to be report its
status. The status callback should not do extensive work, because while the 
status callback is called, thread execution is suspended.
</p>
<p>
When using a plain procedure, extra data can be passed on to the procedure
in <var>AData</var>. The <var>AData</var> pointer will be passed to the 
thread method, and also to the thread status callback and thread termination
callback.
</p>
</descr>
<seealso>
<link id="TThreadExecuteHandler"/>
<link id="TThreadExecuteStatusHandler"/>
<link id="TThreadExecuteStatusCallback"/>
<link id="TThreadExecuteCallback"/>
</seealso>
<example file="classesex/tthrc"/>
<example file="classesex/tthre"/>
<example file="classesex/tthrcs"/>
<example file="classesex/tthres"/>
</element>

<!-- procedure Visibility: default -->
<element name="GroupDescendentsWith">
<short>Provided for Delphi compatibility</short>
<descr>
<var>GroupDescendentsWith</var> exists for Delphi compatibility, it doesn't
actually do anything in Free Pascal.
</descr>
<seealso>
<link id="RegisterClasses"/>
</seealso>
</element>

<!-- Template for copy&paste:
<element name="">
<short>
</short>
<descr>
</descr>
</element>
-->

</module>
</package>
</fpdoc-descriptions>
